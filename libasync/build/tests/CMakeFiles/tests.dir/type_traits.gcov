        -:    0:Source:/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits
        -:    0:Graph:/Users/wjp/Desktop/workspace/libasync/libasync/build/tests/CMakeFiles/tests.dir/SystemIntegrationTOT.cc.gcno
        -:    0:Data:-
        -:    0:Runs:0
        -:    0:Programs:0
        -:    1:// -*- C++ -*-
        -:    2://===------------------------ type_traits ---------------------------------===//
        -:    3://
        -:    4://                     The LLVM Compiler Infrastructure
        -:    5://
        -:    6:// This file is dual licensed under the MIT and the University of Illinois Open
        -:    7:// Source Licenses. See LICENSE.TXT for details.
        -:    8://
        -:    9://===----------------------------------------------------------------------===//
        -:   10:
        -:   11:#ifndef _LIBCPP_TYPE_TRAITS
        -:   12:#define _LIBCPP_TYPE_TRAITS
        -:   13:
        -:   14:/*
        -:   15:    type_traits synopsis
        -:   16:
        -:   17:namespace std
        -:   18:{
        -:   19:
        -:   20:    // helper class:
        -:   21:    template <class T, T v> struct integral_constant;
        -:   22:    typedef integral_constant<bool, true>  true_type;   // C++11
        -:   23:    typedef integral_constant<bool, false> false_type;  // C++11
        -:   24:    
        -:   25:    template <bool B>                                   // C++14
        -:   26:    using bool_constant = integral_constant<bool, B>;   // C++14
        -:   27:    typedef bool_constant<true> true_type;              // C++14
        -:   28:    typedef bool_constant<false> false_type;            // C++14
        -:   29:
        -:   30:    // helper traits
        -:   31:    template <bool, class T = void> struct enable_if;
        -:   32:    template <bool, class T, class F> struct conditional;
        -:   33:
        -:   34:    // Primary classification traits:
        -:   35:    template <class T> struct is_void;
        -:   36:    template <class T> struct is_null_pointer;  // C++14
        -:   37:    template <class T> struct is_integral;
        -:   38:    template <class T> struct is_floating_point;
        -:   39:    template <class T> struct is_array;
        -:   40:    template <class T> struct is_pointer;
        -:   41:    template <class T> struct is_lvalue_reference;
        -:   42:    template <class T> struct is_rvalue_reference;
        -:   43:    template <class T> struct is_member_object_pointer;
        -:   44:    template <class T> struct is_member_function_pointer;
        -:   45:    template <class T> struct is_enum;
        -:   46:    template <class T> struct is_union;
        -:   47:    template <class T> struct is_class;
        -:   48:    template <class T> struct is_function;
        -:   49:
        -:   50:    // Secondary classification traits:
        -:   51:    template <class T> struct is_reference;
        -:   52:    template <class T> struct is_arithmetic;
        -:   53:    template <class T> struct is_fundamental;
        -:   54:    template <class T> struct is_member_pointer;
        -:   55:    template <class T> struct is_scalar;
        -:   56:    template <class T> struct is_object;
        -:   57:    template <class T> struct is_compound;
        -:   58:
        -:   59:    // Const-volatile properties and transformations:
        -:   60:    template <class T> struct is_const;
        -:   61:    template <class T> struct is_volatile;
        -:   62:    template <class T> struct remove_const;
        -:   63:    template <class T> struct remove_volatile;
        -:   64:    template <class T> struct remove_cv;
        -:   65:    template <class T> struct add_const;
        -:   66:    template <class T> struct add_volatile;
        -:   67:    template <class T> struct add_cv;
        -:   68:
        -:   69:    // Reference transformations:
        -:   70:    template <class T> struct remove_reference;
        -:   71:    template <class T> struct add_lvalue_reference;
        -:   72:    template <class T> struct add_rvalue_reference;
        -:   73:
        -:   74:    // Pointer transformations:
        -:   75:    template <class T> struct remove_pointer;
        -:   76:    template <class T> struct add_pointer;
        -:   77:
        -:   78:    // Integral properties:
        -:   79:    template <class T> struct is_signed;
        -:   80:    template <class T> struct is_unsigned;
        -:   81:    template <class T> struct make_signed;
        -:   82:    template <class T> struct make_unsigned;
        -:   83:
        -:   84:    // Array properties and transformations:
        -:   85:    template <class T> struct rank;
        -:   86:    template <class T, unsigned I = 0> struct extent;
        -:   87:    template <class T> struct remove_extent;
        -:   88:    template <class T> struct remove_all_extents;
        -:   89:
        -:   90:    // Member introspection:
        -:   91:    template <class T> struct is_pod;
        -:   92:    template <class T> struct is_trivial;
        -:   93:    template <class T> struct is_trivially_copyable;
        -:   94:    template <class T> struct is_standard_layout;
        -:   95:    template <class T> struct is_literal_type;
        -:   96:    template <class T> struct is_empty;
        -:   97:    template <class T> struct is_polymorphic;
        -:   98:    template <class T> struct is_abstract;
        -:   99:    template <class T> struct is_final; // C++14
        -:  100:
        -:  101:    template <class T, class... Args> struct is_constructible;
        -:  102:    template <class T>                struct is_default_constructible;
        -:  103:    template <class T>                struct is_copy_constructible;
        -:  104:    template <class T>                struct is_move_constructible;
        -:  105:    template <class T, class U>       struct is_assignable;
        -:  106:    template <class T>                struct is_copy_assignable;
        -:  107:    template <class T>                struct is_move_assignable;
        -:  108:    template <class T>                struct is_destructible;
        -:  109:
        -:  110:    template <class T, class... Args> struct is_trivially_constructible;
        -:  111:    template <class T>                struct is_trivially_default_constructible;
        -:  112:    template <class T>                struct is_trivially_copy_constructible;
        -:  113:    template <class T>                struct is_trivially_move_constructible;
        -:  114:    template <class T, class U>       struct is_trivially_assignable;
        -:  115:    template <class T>                struct is_trivially_copy_assignable;
        -:  116:    template <class T>                struct is_trivially_move_assignable;
        -:  117:    template <class T>                struct is_trivially_destructible;
        -:  118:
        -:  119:    template <class T, class... Args> struct is_nothrow_constructible;
        -:  120:    template <class T>                struct is_nothrow_default_constructible;
        -:  121:    template <class T>                struct is_nothrow_copy_constructible;
        -:  122:    template <class T>                struct is_nothrow_move_constructible;
        -:  123:    template <class T, class U>       struct is_nothrow_assignable;
        -:  124:    template <class T>                struct is_nothrow_copy_assignable;
        -:  125:    template <class T>                struct is_nothrow_move_assignable;
        -:  126:    template <class T>                struct is_nothrow_destructible;
        -:  127:
        -:  128:    template <class T> struct has_virtual_destructor;
        -:  129:
        -:  130:    // Relationships between types:
        -:  131:    template <class T, class U> struct is_same;
        -:  132:    template <class Base, class Derived> struct is_base_of;
        -:  133:    template <class From, class To> struct is_convertible;
        -:  134:
        -:  135:    // Alignment properties and transformations:
        -:  136:    template <class T> struct alignment_of;
        -:  137:    template <size_t Len, size_t Align = most_stringent_alignment_requirement>
        -:  138:        struct aligned_storage;
        -:  139:    template <size_t Len, class... Types> struct aligned_union;
        -:  140:
        -:  141:    template <class T> struct decay;
        -:  142:    template <class... T> struct common_type;
        -:  143:    template <class T> struct underlying_type;
        -:  144:    template <class> class result_of; // undefined
        -:  145:    template <class Fn, class... ArgTypes> class result_of<Fn(ArgTypes...)>;
        -:  146:
        -:  147:    // const-volatile modifications:
        -:  148:    template <class T>
        -:  149:      using remove_const_t    = typename remove_const<T>::type;  // C++14
        -:  150:    template <class T>
        -:  151:      using remove_volatile_t = typename remove_volatile<T>::type;  // C++14
        -:  152:    template <class T>
        -:  153:      using remove_cv_t       = typename remove_cv<T>::type;  // C++14
        -:  154:    template <class T>
        -:  155:      using add_const_t       = typename add_const<T>::type;  // C++14
        -:  156:    template <class T>
        -:  157:      using add_volatile_t    = typename add_volatile<T>::type;  // C++14
        -:  158:    template <class T>
        -:  159:      using add_cv_t          = typename add_cv<T>::type;  // C++14
        -:  160:  
        -:  161:    // reference modifications:
        -:  162:    template <class T>
        -:  163:      using remove_reference_t     = typename remove_reference<T>::type;  // C++14
        -:  164:    template <class T>
        -:  165:      using add_lvalue_reference_t = typename add_lvalue_reference<T>::type;  // C++14
        -:  166:    template <class T>
        -:  167:      using add_rvalue_reference_t = typename add_rvalue_reference<T>::type;  // C++14
        -:  168:  
        -:  169:    // sign modifications:
        -:  170:    template <class T>
        -:  171:      using make_signed_t   = typename make_signed<T>::type;  // C++14
        -:  172:    template <class T>
        -:  173:      using make_unsigned_t = typename make_unsigned<T>::type;  // C++14
        -:  174:  
        -:  175:    // array modifications:
        -:  176:    template <class T>
        -:  177:      using remove_extent_t      = typename remove_extent<T>::type;  // C++14
        -:  178:    template <class T>
        -:  179:      using remove_all_extents_t = typename remove_all_extents<T>::type;  // C++14
        -:  180:
        -:  181:    // pointer modifications:
        -:  182:    template <class T>
        -:  183:      using remove_pointer_t = typename remove_pointer<T>::type;  // C++14
        -:  184:    template <class T>
        -:  185:      using add_pointer_t    = typename add_pointer<T>::type;  // C++14
        -:  186:
        -:  187:    // other transformations:
        -:  188:    template <size_t Len, std::size_t Align=default-alignment>
        -:  189:      using aligned_storage_t = typename aligned_storage<Len,Align>::type;  // C++14
        -:  190:    template <std::size_t Len, class... Types>
        -:  191:      using aligned_union_t   = typename aligned_union<Len,Types...>::type;  // C++14
        -:  192:    template <class T>
        -:  193:      using decay_t           = typename decay<T>::type;  // C++14
        -:  194:    template <bool b, class T=void>
        -:  195:      using enable_if_t       = typename enable_if<b,T>::type;  // C++14
        -:  196:    template <bool b, class T, class F>
        -:  197:      using conditional_t     = typename conditional<b,T,F>::type;  // C++14
        -:  198:    template <class... T>
        -:  199:      using common_type_t     = typename common_type<T...>::type;  // C++14
        -:  200:    template <class T>
        -:  201:      using underlying_type_t = typename underlying_type<T>::type;  // C++14
        -:  202:    template <class F, class... ArgTypes>
        -:  203:      using result_of_t       = typename result_of<F(ArgTypes...)>::type;  // C++14
        -:  204:
        -:  205:    template <class...>
        -:  206:      using void_t = void;
        -:  207:}  // C++17
        -:  208:
        -:  209:*/
        -:  210:#include <__config>
        -:  211:#include <cstddef>
        -:  212:
        -:  213:#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
        -:  214:#pragma GCC system_header
        -:  215:#endif
        -:  216:
        -:  217:_LIBCPP_BEGIN_NAMESPACE_STD
        -:  218:
        -:  219:template <class>
        -:  220:struct __void_t { typedef void type; };
        -:  221:
        -:  222:template <class _Tp>
        -:  223:struct __identity { typedef _Tp type; };
        -:  224:
        -:  225:template <class _Tp, bool>
        -:  226:struct _LIBCPP_TYPE_VIS_ONLY __dependent_type : public _Tp {};
        -:  227:
        -:  228:template <bool _Bp, class _If, class _Then>
        -:  229:    struct _LIBCPP_TYPE_VIS_ONLY conditional {typedef _If type;};
        -:  230:template <class _If, class _Then>
        -:  231:    struct _LIBCPP_TYPE_VIS_ONLY conditional<false, _If, _Then> {typedef _Then type;};
        -:  232:
        -:  233:#if _LIBCPP_STD_VER > 11
        -:  234:template <bool _Bp, class _If, class _Then> using conditional_t = typename conditional<_Bp, _If, _Then>::type;
        -:  235:#endif
        -:  236:
        -:  237:template <bool, class _Tp> struct _LIBCPP_TYPE_VIS_ONLY __lazy_enable_if {};
        -:  238:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY __lazy_enable_if<true, _Tp> {typedef typename _Tp::type type;};
        -:  239:
        -:  240:template <bool, class _Tp = void> struct _LIBCPP_TYPE_VIS_ONLY enable_if {};
        -:  241:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY enable_if<true, _Tp> {typedef _Tp type;};
        -:  242:
        -:  243:#if _LIBCPP_STD_VER > 11
        -:  244:template <bool _Bp, class _Tp = void> using enable_if_t = typename enable_if<_Bp, _Tp>::type;
        -:  245:#endif
        -:  246:
        -:  247:
        -:  248:struct __two {char __lx[2];};
        -:  249:
        -:  250:// helper class:
        -:  251:
        -:  252:template <class _Tp, _Tp __v>
        -:  253:struct _LIBCPP_TYPE_VIS_ONLY integral_constant
        -:  254:{
        -:  255:    static _LIBCPP_CONSTEXPR const _Tp      value = __v;
        -:  256:    typedef _Tp               value_type;
        -:  257:    typedef integral_constant type;
        -:  258:    _LIBCPP_INLINE_VISIBILITY
        -:  259:        _LIBCPP_CONSTEXPR operator value_type() const _NOEXCEPT {return value;}
        -:  260:#if _LIBCPP_STD_VER > 11
        -:  261:    _LIBCPP_INLINE_VISIBILITY
        -:  262:         constexpr value_type operator ()() const _NOEXCEPT {return value;}
        -:  263:#endif
        -:  264:};
        -:  265:
        -:  266:template <class _Tp, _Tp __v>
        -:  267:_LIBCPP_CONSTEXPR const _Tp integral_constant<_Tp, __v>::value;
        -:  268:
        -:  269:#if _LIBCPP_STD_VER > 14
        -:  270:template <bool __b>
        -:  271:using bool_constant = integral_constant<bool, __b>;
        -:  272:#define	_LIBCPP_BOOL_CONSTANT(__b) bool_constant<(__b)>
        -:  273:#else
        -:  274:#define	_LIBCPP_BOOL_CONSTANT(__b) integral_constant<bool,(__b)>
        -:  275:#endif
        -:  276:
        -:  277:typedef _LIBCPP_BOOL_CONSTANT(true)  true_type;
        -:  278:typedef _LIBCPP_BOOL_CONSTANT(false) false_type;
        -:  279:
        -:  280:// is_const
        -:  281:
        -:  282:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_const            : public false_type {};
        -:  283:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_const<_Tp const> : public true_type {};
        -:  284:
        -:  285:// is_volatile
        -:  286:
        -:  287:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_volatile               : public false_type {};
        -:  288:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_volatile<_Tp volatile> : public true_type {};
        -:  289:
        -:  290:// remove_const
        -:  291:
        -:  292:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_const            {typedef _Tp type;};
        -:  293:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_const<const _Tp> {typedef _Tp type;};
        -:  294:#if _LIBCPP_STD_VER > 11
        -:  295:template <class _Tp> using remove_const_t = typename remove_const<_Tp>::type;
        -:  296:#endif
        -:  297:
        -:  298:// remove_volatile
        -:  299:
        -:  300:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_volatile               {typedef _Tp type;};
        -:  301:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_volatile<volatile _Tp> {typedef _Tp type;};
        -:  302:#if _LIBCPP_STD_VER > 11
        -:  303:template <class _Tp> using remove_volatile_t = typename remove_volatile<_Tp>::type;
        -:  304:#endif
        -:  305:
        -:  306:// remove_cv
        -:  307:
        -:  308:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_cv
        -:  309:{typedef typename remove_volatile<typename remove_const<_Tp>::type>::type type;};
        -:  310:#if _LIBCPP_STD_VER > 11
        -:  311:template <class _Tp> using remove_cv_t = typename remove_cv<_Tp>::type;
        -:  312:#endif
        -:  313:
        -:  314:// is_void
        -:  315:
        -:  316:template <class _Tp> struct __libcpp_is_void       : public false_type {};
        -:  317:template <>          struct __libcpp_is_void<void> : public true_type {};
        -:  318:
        -:  319:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_void
        -:  320:    : public __libcpp_is_void<typename remove_cv<_Tp>::type> {};
        -:  321:
        -:  322:// __is_nullptr_t
        -:  323:
        -:  324:template <class _Tp> struct __is_nullptr_t_impl       : public false_type {};
        -:  325:template <>          struct __is_nullptr_t_impl<nullptr_t> : public true_type {};
        -:  326:
        -:  327:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY __is_nullptr_t
        -:  328:    : public __is_nullptr_t_impl<typename remove_cv<_Tp>::type> {};
        -:  329:
        -:  330:#if _LIBCPP_STD_VER > 11
        -:  331:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_null_pointer
        -:  332:    : public __is_nullptr_t_impl<typename remove_cv<_Tp>::type> {};
        -:  333:#endif
        -:  334:
        -:  335:// is_integral
        -:  336:
        -:  337:template <class _Tp> struct __libcpp_is_integral                     : public false_type {};
        -:  338:template <>          struct __libcpp_is_integral<bool>               : public true_type {};
        -:  339:template <>          struct __libcpp_is_integral<char>               : public true_type {};
        -:  340:template <>          struct __libcpp_is_integral<signed char>        : public true_type {};
        -:  341:template <>          struct __libcpp_is_integral<unsigned char>      : public true_type {};
        -:  342:template <>          struct __libcpp_is_integral<wchar_t>            : public true_type {};
        -:  343:#ifndef _LIBCPP_HAS_NO_UNICODE_CHARS
        -:  344:template <>          struct __libcpp_is_integral<char16_t>           : public true_type {};
        -:  345:template <>          struct __libcpp_is_integral<char32_t>           : public true_type {};
        -:  346:#endif  // _LIBCPP_HAS_NO_UNICODE_CHARS
        -:  347:template <>          struct __libcpp_is_integral<short>              : public true_type {};
        -:  348:template <>          struct __libcpp_is_integral<unsigned short>     : public true_type {};
        -:  349:template <>          struct __libcpp_is_integral<int>                : public true_type {};
        -:  350:template <>          struct __libcpp_is_integral<unsigned int>       : public true_type {};
        -:  351:template <>          struct __libcpp_is_integral<long>               : public true_type {};
        -:  352:template <>          struct __libcpp_is_integral<unsigned long>      : public true_type {};
        -:  353:template <>          struct __libcpp_is_integral<long long>          : public true_type {};
        -:  354:template <>          struct __libcpp_is_integral<unsigned long long> : public true_type {};
        -:  355:#ifndef _LIBCPP_HAS_NO_INT128
        -:  356:template <>          struct __libcpp_is_integral<__int128_t>         : public true_type {};
        -:  357:template <>          struct __libcpp_is_integral<__uint128_t>        : public true_type {};
        -:  358:#endif
        -:  359:
        -:  360:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_integral
        -:  361:    : public __libcpp_is_integral<typename remove_cv<_Tp>::type> {};
        -:  362:
        -:  363:// is_floating_point
        -:  364:
        -:  365:template <class _Tp> struct __libcpp_is_floating_point              : public false_type {};
        -:  366:template <>          struct __libcpp_is_floating_point<float>       : public true_type {};
        -:  367:template <>          struct __libcpp_is_floating_point<double>      : public true_type {};
        -:  368:template <>          struct __libcpp_is_floating_point<long double> : public true_type {};
        -:  369:
        -:  370:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_floating_point
        -:  371:    : public __libcpp_is_floating_point<typename remove_cv<_Tp>::type> {};
        -:  372:
        -:  373:// is_array
        -:  374:
        -:  375:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_array
        -:  376:    : public false_type {};
        -:  377:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_array<_Tp[]>
        -:  378:    : public true_type {};
        -:  379:template <class _Tp, size_t _Np> struct _LIBCPP_TYPE_VIS_ONLY is_array<_Tp[_Np]>
        -:  380:    : public true_type {};
        -:  381:
        -:  382:// is_pointer
        -:  383:
        -:  384:template <class _Tp> struct __libcpp_is_pointer       : public false_type {};
        -:  385:template <class _Tp> struct __libcpp_is_pointer<_Tp*> : public true_type {};
        -:  386:
        -:  387:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_pointer
        -:  388:    : public __libcpp_is_pointer<typename remove_cv<_Tp>::type> {};
        -:  389:
        -:  390:// is_reference
        -:  391:
        -:  392:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_lvalue_reference       : public false_type {};
        -:  393:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_lvalue_reference<_Tp&> : public true_type {};
        -:  394:
        -:  395:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_rvalue_reference        : public false_type {};
        -:  396:#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -:  397:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_rvalue_reference<_Tp&&> : public true_type {};
        -:  398:#endif
        -:  399:
        -:  400:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_reference        : public false_type {};
        -:  401:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_reference<_Tp&>  : public true_type {};
        -:  402:#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -:  403:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_reference<_Tp&&> : public true_type {};
        -:  404:#endif
        -:  405:
        -:  406:// is_union
        -:  407:
        -:  408:#if __has_feature(is_union) || (_GNUC_VER >= 403)
        -:  409:
        -:  410:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_union
        -:  411:    : public integral_constant<bool, __is_union(_Tp)> {};
        -:  412:
        -:  413:#else
        -:  414:
        -:  415:template <class _Tp> struct __libcpp_union : public false_type {};
        -:  416:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_union
        -:  417:    : public __libcpp_union<typename remove_cv<_Tp>::type> {};
        -:  418:
        -:  419:#endif
        -:  420:
        -:  421:// is_class
        -:  422:
        -:  423:#if __has_feature(is_class) || (_GNUC_VER >= 403)
        -:  424:
        -:  425:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_class
        -:  426:    : public integral_constant<bool, __is_class(_Tp)> {};
        -:  427:
        -:  428:#else
        -:  429:
        -:  430:namespace __is_class_imp
        -:  431:{
        -:  432:template <class _Tp> char  __test(int _Tp::*);
        -:  433:template <class _Tp> __two __test(...);
        -:  434:}
        -:  435:
        -:  436:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_class
        -:  437:    : public integral_constant<bool, sizeof(__is_class_imp::__test<_Tp>(0)) == 1 && !is_union<_Tp>::value> {};
        -:  438:
        -:  439:#endif
        -:  440:
        -:  441:// is_same
        -:  442:
        -:  443:template <class _Tp, class _Up> struct _LIBCPP_TYPE_VIS_ONLY is_same           : public false_type {};
        -:  444:template <class _Tp>            struct _LIBCPP_TYPE_VIS_ONLY is_same<_Tp, _Tp> : public true_type {};
        -:  445:
        -:  446:// is_function
        -:  447:
        -:  448:namespace __libcpp_is_function_imp
        -:  449:{
        -:  450:struct __dummy_type {};
        -:  451:template <class _Tp> char  __test(_Tp*);
        -:  452:template <class _Tp> char __test(__dummy_type);
        -:  453:template <class _Tp> __two __test(...);
        -:  454:template <class _Tp> _Tp&  __source(int);
        -:  455:template <class _Tp> __dummy_type __source(...);
        -:  456:}
        -:  457:
        -:  458:template <class _Tp, bool = is_class<_Tp>::value ||
        -:  459:                            is_union<_Tp>::value ||
        -:  460:                            is_void<_Tp>::value  ||
        -:  461:                            is_reference<_Tp>::value ||
        -:  462:                            __is_nullptr_t<_Tp>::value >
        -:  463:struct __libcpp_is_function
        -:  464:    : public integral_constant<bool, sizeof(__libcpp_is_function_imp::__test<_Tp>(__libcpp_is_function_imp::__source<_Tp>(0))) == 1>
        -:  465:    {};
        -:  466:template <class _Tp> struct __libcpp_is_function<_Tp, true> : public false_type {};
        -:  467:
        -:  468:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_function
        -:  469:    : public __libcpp_is_function<_Tp> {};
        -:  470:
        -:  471:// is_member_function_pointer
        -:  472:
        -:  473:// template <class _Tp> struct            __libcpp_is_member_function_pointer             : public false_type {};
        -:  474:// template <class _Tp, class _Up> struct __libcpp_is_member_function_pointer<_Tp _Up::*> : public is_function<_Tp> {};
        -:  475:// 
        -:  476:
        -:  477:template <class _MP, bool _IsMemberFunctionPtr, bool _IsMemberObjectPtr>
        -:  478:struct __member_pointer_traits_imp
        -:  479:{  // forward declaration; specializations later
        -:  480:};
        -:  481:
        -:  482:
        -:  483:template <class _Tp> struct __libcpp_is_member_function_pointer
        -:  484:    : public false_type {};
        -:  485:
        -:  486:template <class _Ret, class _Class>
        -:  487:struct __libcpp_is_member_function_pointer<_Ret _Class::*>
        -:  488:    : public is_function<_Ret> {};
        -:  489:
        -:  490:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_member_function_pointer
        -:  491:    : public __libcpp_is_member_function_pointer<typename remove_cv<_Tp>::type>::type {};
        -:  492:
        -:  493:// is_member_pointer
        -:  494:
        -:  495:template <class _Tp>            struct __libcpp_is_member_pointer             : public false_type {};
        -:  496:template <class _Tp, class _Up> struct __libcpp_is_member_pointer<_Tp _Up::*> : public true_type {};
        -:  497:
        -:  498:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_member_pointer
        -:  499:    : public __libcpp_is_member_pointer<typename remove_cv<_Tp>::type> {};
        -:  500:
        -:  501:// is_member_object_pointer
        -:  502:
        -:  503:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_member_object_pointer
        -:  504:    : public integral_constant<bool, is_member_pointer<_Tp>::value &&
        -:  505:                                    !is_member_function_pointer<_Tp>::value> {};
        -:  506:
        -:  507:// is_enum
        -:  508:
        -:  509:#if __has_feature(is_enum) || (_GNUC_VER >= 403)
        -:  510:
        -:  511:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_enum
        -:  512:    : public integral_constant<bool, __is_enum(_Tp)> {};
        -:  513:
        -:  514:#else
        -:  515:
        -:  516:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_enum
        -:  517:    : public integral_constant<bool, !is_void<_Tp>::value             &&
        -:  518:                                     !is_integral<_Tp>::value         &&
        -:  519:                                     !is_floating_point<_Tp>::value   &&
        -:  520:                                     !is_array<_Tp>::value            &&
        -:  521:                                     !is_pointer<_Tp>::value          &&
        -:  522:                                     !is_reference<_Tp>::value        &&
        -:  523:                                     !is_member_pointer<_Tp>::value   &&
        -:  524:                                     !is_union<_Tp>::value            &&
        -:  525:                                     !is_class<_Tp>::value            &&
        -:  526:                                     !is_function<_Tp>::value         > {};
        -:  527:
        -:  528:#endif
        -:  529:
        -:  530:// is_arithmetic
        -:  531:
        -:  532:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_arithmetic
        -:  533:    : public integral_constant<bool, is_integral<_Tp>::value      ||
        -:  534:                                     is_floating_point<_Tp>::value> {};
        -:  535:
        -:  536:// is_fundamental
        -:  537:
        -:  538:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_fundamental
        -:  539:    : public integral_constant<bool, is_void<_Tp>::value        ||
        -:  540:                                     __is_nullptr_t<_Tp>::value ||
        -:  541:                                     is_arithmetic<_Tp>::value> {};
        -:  542:
        -:  543:// is_scalar
        -:  544:
        -:  545:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_scalar
        -:  546:    : public integral_constant<bool, is_arithmetic<_Tp>::value     ||
        -:  547:                                     is_member_pointer<_Tp>::value ||
        -:  548:                                     is_pointer<_Tp>::value        ||
        -:  549:                                     __is_nullptr_t<_Tp>::value    ||
        -:  550:                                     is_enum<_Tp>::value           > {};
        -:  551:
        -:  552:template <> struct _LIBCPP_TYPE_VIS_ONLY is_scalar<nullptr_t> : public true_type {};
        -:  553:
        -:  554:// is_object
        -:  555:
        -:  556:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_object
        -:  557:    : public integral_constant<bool, is_scalar<_Tp>::value ||
        -:  558:                                     is_array<_Tp>::value  ||
        -:  559:                                     is_union<_Tp>::value  ||
        -:  560:                                     is_class<_Tp>::value  > {};
        -:  561:
        -:  562:// is_compound
        -:  563:
        -:  564:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_compound
        -:  565:    : public integral_constant<bool, !is_fundamental<_Tp>::value> {};
        -:  566:
        -:  567:// add_const
        -:  568:
        -:  569:template <class _Tp, bool = is_reference<_Tp>::value ||
        -:  570:                            is_function<_Tp>::value  ||
        -:  571:                            is_const<_Tp>::value     >
        -:  572:struct __add_const             {typedef _Tp type;};
        -:  573:
        -:  574:template <class _Tp>
        -:  575:struct __add_const<_Tp, false> {typedef const _Tp type;};
        -:  576:
        -:  577:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY add_const
        -:  578:    {typedef typename __add_const<_Tp>::type type;};
        -:  579:
        -:  580:#if _LIBCPP_STD_VER > 11
        -:  581:template <class _Tp> using add_const_t = typename add_const<_Tp>::type;
        -:  582:#endif
        -:  583:
        -:  584:// add_volatile
        -:  585:
        -:  586:template <class _Tp, bool = is_reference<_Tp>::value ||
        -:  587:                            is_function<_Tp>::value  ||
        -:  588:                            is_volatile<_Tp>::value  >
        -:  589:struct __add_volatile             {typedef _Tp type;};
        -:  590:
        -:  591:template <class _Tp>
        -:  592:struct __add_volatile<_Tp, false> {typedef volatile _Tp type;};
        -:  593:
        -:  594:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY add_volatile
        -:  595:    {typedef typename __add_volatile<_Tp>::type type;};
        -:  596:
        -:  597:#if _LIBCPP_STD_VER > 11
        -:  598:template <class _Tp> using add_volatile_t = typename add_volatile<_Tp>::type;
        -:  599:#endif
        -:  600:
        -:  601:// add_cv
        -:  602:
        -:  603:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY add_cv
        -:  604:    {typedef typename add_const<typename add_volatile<_Tp>::type>::type type;};
        -:  605:
        -:  606:#if _LIBCPP_STD_VER > 11
        -:  607:template <class _Tp> using add_cv_t = typename add_cv<_Tp>::type;
        -:  608:#endif
        -:  609:
        -:  610:// remove_reference
        -:  611:
        -:  612:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_reference        {typedef _Tp type;};
        -:  613:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_reference<_Tp&>  {typedef _Tp type;};
        -:  614:#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -:  615:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_reference<_Tp&&> {typedef _Tp type;};
        -:  616:#endif
        -:  617:
        -:  618:#if _LIBCPP_STD_VER > 11
        -:  619:template <class _Tp> using remove_reference_t = typename remove_reference<_Tp>::type;
        -:  620:#endif
        -:  621:
        -:  622:// add_lvalue_reference
        -:  623:
        -:  624:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY add_lvalue_reference                      {typedef _Tp& type;};
        -:  625:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY add_lvalue_reference<_Tp&>                {typedef _Tp& type;};  // for older compiler
        -:  626:template <>          struct _LIBCPP_TYPE_VIS_ONLY add_lvalue_reference<void>                {typedef void type;};
        -:  627:template <>          struct _LIBCPP_TYPE_VIS_ONLY add_lvalue_reference<const void>          {typedef const void type;};
        -:  628:template <>          struct _LIBCPP_TYPE_VIS_ONLY add_lvalue_reference<volatile void>       {typedef volatile void type;};
        -:  629:template <>          struct _LIBCPP_TYPE_VIS_ONLY add_lvalue_reference<const volatile void> {typedef const volatile void type;};
        -:  630:
        -:  631:#if _LIBCPP_STD_VER > 11
        -:  632:template <class _Tp> using add_lvalue_reference_t = typename add_lvalue_reference<_Tp>::type;
        -:  633:#endif
        -:  634:
        -:  635:#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -:  636:
        -:  637:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY  add_rvalue_reference                     {typedef _Tp&& type;};
        -:  638:template <>          struct _LIBCPP_TYPE_VIS_ONLY add_rvalue_reference<void>                {typedef void type;};
        -:  639:template <>          struct _LIBCPP_TYPE_VIS_ONLY add_rvalue_reference<const void>          {typedef const void type;};
        -:  640:template <>          struct _LIBCPP_TYPE_VIS_ONLY add_rvalue_reference<volatile void>       {typedef volatile void type;};
        -:  641:template <>          struct _LIBCPP_TYPE_VIS_ONLY add_rvalue_reference<const volatile void> {typedef const volatile void type;};
        -:  642:
        -:  643:#if _LIBCPP_STD_VER > 11
        -:  644:template <class _Tp> using add_rvalue_reference_t = typename add_rvalue_reference<_Tp>::type;
        -:  645:#endif
        -:  646:
        -:  647:#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -:  648:
        -:  649:#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -:  650:
        -:  651:template <class _Tp>
        -:  652:typename add_rvalue_reference<_Tp>::type
        -:  653:declval() _NOEXCEPT;
        -:  654:
        -:  655:#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -:  656:
        -:  657:template <class _Tp>
        -:  658:typename add_lvalue_reference<_Tp>::type
        -:  659:declval();
        -:  660:
        -:  661:#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -:  662:
        -:  663:// __uncvref
        -:  664:
        -:  665:template <class _Tp>
        -:  666:struct __uncvref  {
        -:  667:    typedef typename remove_cv<typename remove_reference<_Tp>::type>::type type;
        -:  668:};
        -:  669:
        -:  670:template <class _Tp>
        -:  671:struct __unconstref {
        -:  672:    typedef typename remove_const<typename remove_reference<_Tp>::type>::type type;
        -:  673:};
        -:  674:
        -:  675:// __is_same_uncvref
        -:  676:
        -:  677:template <class _Tp, class _Up>
        -:  678:struct __is_same_uncvref : is_same<typename __uncvref<_Tp>::type,
        -:  679:                                   typename __uncvref<_Up>::type> {};
        -:  680:
        -:  681:struct __any
        -:  682:{
        -:  683:    __any(...);
        -:  684:};
        -:  685:
        -:  686:// remove_pointer
        -:  687:
        -:  688:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_pointer                      {typedef _Tp type;};
        -:  689:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_pointer<_Tp*>                {typedef _Tp type;};
        -:  690:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_pointer<_Tp* const>          {typedef _Tp type;};
        -:  691:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_pointer<_Tp* volatile>       {typedef _Tp type;};
        -:  692:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_pointer<_Tp* const volatile> {typedef _Tp type;};
        -:  693:
        -:  694:#if _LIBCPP_STD_VER > 11
        -:  695:template <class _Tp> using remove_pointer_t = typename remove_pointer<_Tp>::type;
        -:  696:#endif
        -:  697:
        -:  698:// add_pointer
        -:  699:
        -:  700:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY add_pointer
        -:  701:    {typedef typename remove_reference<_Tp>::type* type;};
        -:  702:
        -:  703:#if _LIBCPP_STD_VER > 11
        -:  704:template <class _Tp> using add_pointer_t = typename add_pointer<_Tp>::type;
        -:  705:#endif
        -:  706:
        -:  707:// is_signed
        -:  708:
        -:  709:template <class _Tp, bool = is_integral<_Tp>::value>
        -:  710:struct __libcpp_is_signed_impl : public _LIBCPP_BOOL_CONSTANT(_Tp(-1) < _Tp(0)) {};
        -:  711:
        -:  712:template <class _Tp>
        -:  713:struct __libcpp_is_signed_impl<_Tp, false> : public true_type {};  // floating point
        -:  714:
        -:  715:template <class _Tp, bool = is_arithmetic<_Tp>::value>
        -:  716:struct __libcpp_is_signed : public __libcpp_is_signed_impl<_Tp> {};
        -:  717:
        -:  718:template <class _Tp> struct __libcpp_is_signed<_Tp, false> : public false_type {};
        -:  719:
        -:  720:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_signed : public __libcpp_is_signed<_Tp> {};
        -:  721:
        -:  722:// is_unsigned
        -:  723:
        -:  724:template <class _Tp, bool = is_integral<_Tp>::value>
        -:  725:struct __libcpp_is_unsigned_impl : public _LIBCPP_BOOL_CONSTANT(_Tp(0) < _Tp(-1)) {};
        -:  726:
        -:  727:template <class _Tp>
        -:  728:struct __libcpp_is_unsigned_impl<_Tp, false> : public false_type {};  // floating point
        -:  729:
        -:  730:template <class _Tp, bool = is_arithmetic<_Tp>::value>
        -:  731:struct __libcpp_is_unsigned : public __libcpp_is_unsigned_impl<_Tp> {};
        -:  732:
        -:  733:template <class _Tp> struct __libcpp_is_unsigned<_Tp, false> : public false_type {};
        -:  734:
        -:  735:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_unsigned : public __libcpp_is_unsigned<_Tp> {};
        -:  736:
        -:  737:// rank
        -:  738:
        -:  739:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY rank
        -:  740:    : public integral_constant<size_t, 0> {};
        -:  741:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY rank<_Tp[]>
        -:  742:    : public integral_constant<size_t, rank<_Tp>::value + 1> {};
        -:  743:template <class _Tp, size_t _Np> struct _LIBCPP_TYPE_VIS_ONLY rank<_Tp[_Np]>
        -:  744:    : public integral_constant<size_t, rank<_Tp>::value + 1> {};
        -:  745:
        -:  746:// extent
        -:  747:
        -:  748:template <class _Tp, unsigned _Ip = 0> struct _LIBCPP_TYPE_VIS_ONLY extent
        -:  749:    : public integral_constant<size_t, 0> {};
        -:  750:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY extent<_Tp[], 0>
        -:  751:    : public integral_constant<size_t, 0> {};
        -:  752:template <class _Tp, unsigned _Ip> struct _LIBCPP_TYPE_VIS_ONLY extent<_Tp[], _Ip>
        -:  753:    : public integral_constant<size_t, extent<_Tp, _Ip-1>::value> {};
        -:  754:template <class _Tp, size_t _Np> struct _LIBCPP_TYPE_VIS_ONLY extent<_Tp[_Np], 0>
        -:  755:    : public integral_constant<size_t, _Np> {};
        -:  756:template <class _Tp, size_t _Np, unsigned _Ip> struct _LIBCPP_TYPE_VIS_ONLY extent<_Tp[_Np], _Ip>
        -:  757:    : public integral_constant<size_t, extent<_Tp, _Ip-1>::value> {};
        -:  758:
        -:  759:// remove_extent
        -:  760:
        -:  761:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_extent
        -:  762:    {typedef _Tp type;};
        -:  763:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_extent<_Tp[]>
        -:  764:    {typedef _Tp type;};
        -:  765:template <class _Tp, size_t _Np> struct _LIBCPP_TYPE_VIS_ONLY remove_extent<_Tp[_Np]>
        -:  766:    {typedef _Tp type;};
        -:  767:
        -:  768:#if _LIBCPP_STD_VER > 11
        -:  769:template <class _Tp> using remove_extent_t = typename remove_extent<_Tp>::type;
        -:  770:#endif
        -:  771:
        -:  772:// remove_all_extents
        -:  773:
        -:  774:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_all_extents
        -:  775:    {typedef _Tp type;};
        -:  776:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_all_extents<_Tp[]>
        -:  777:    {typedef typename remove_all_extents<_Tp>::type type;};
        -:  778:template <class _Tp, size_t _Np> struct _LIBCPP_TYPE_VIS_ONLY remove_all_extents<_Tp[_Np]>
        -:  779:    {typedef typename remove_all_extents<_Tp>::type type;};
        -:  780:
        -:  781:#if _LIBCPP_STD_VER > 11
        -:  782:template <class _Tp> using remove_all_extents_t = typename remove_all_extents<_Tp>::type;
        -:  783:#endif
        -:  784:
        -:  785:// decay
        -:  786:
        -:  787:template <class _Tp>
        -:  788:struct _LIBCPP_TYPE_VIS_ONLY decay
        -:  789:{
        -:  790:private:
        -:  791:    typedef typename remove_reference<_Tp>::type _Up;
        -:  792:public:
        -:  793:    typedef typename conditional
        -:  794:                     <
        -:  795:                         is_array<_Up>::value,
        -:  796:                         typename remove_extent<_Up>::type*,
        -:  797:                         typename conditional
        -:  798:                         <
        -:  799:                              is_function<_Up>::value,
        -:  800:                              typename add_pointer<_Up>::type,
        -:  801:                              typename remove_cv<_Up>::type
        -:  802:                         >::type
        -:  803:                     >::type type;
        -:  804:};
        -:  805:
        -:  806:#if _LIBCPP_STD_VER > 11
        -:  807:template <class _Tp> using decay_t = typename decay<_Tp>::type;
        -:  808:#endif
        -:  809:
        -:  810:// is_abstract
        -:  811:
        -:  812:namespace __is_abstract_imp
        -:  813:{
        -:  814:template <class _Tp> char  __test(_Tp (*)[1]);
        -:  815:template <class _Tp> __two __test(...);
        -:  816:}
        -:  817:
        -:  818:template <class _Tp, bool = is_class<_Tp>::value>
        -:  819:struct __libcpp_abstract : public integral_constant<bool, sizeof(__is_abstract_imp::__test<_Tp>(0)) != 1> {};
        -:  820:
        -:  821:template <class _Tp> struct __libcpp_abstract<_Tp, false> : public false_type {};
        -:  822:
        -:  823:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_abstract : public __libcpp_abstract<_Tp> {};
        -:  824:
        -:  825:// is_final
        -:  826:
        -:  827:#if defined(_LIBCPP_HAS_IS_FINAL)
        -:  828:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY
        -:  829:__libcpp_is_final : public integral_constant<bool, __is_final(_Tp)> {};
        -:  830:#else
        -:  831:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY
        -:  832:__libcpp_is_final : public false_type {};
        -:  833:#endif
        -:  834:
        -:  835:#if defined(_LIBCPP_HAS_IS_FINAL) && _LIBCPP_STD_VER > 11
        -:  836:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY
        -:  837:is_final : public integral_constant<bool, __is_final(_Tp)> {};
        -:  838:#endif
        -:  839:
        -:  840:// is_base_of
        -:  841:
        -:  842:#ifdef _LIBCPP_HAS_IS_BASE_OF
        -:  843:
        -:  844:template <class _Bp, class _Dp>
        -:  845:struct _LIBCPP_TYPE_VIS_ONLY is_base_of
        -:  846:    : public integral_constant<bool, __is_base_of(_Bp, _Dp)> {};
        -:  847:
        -:  848:#else  // _LIBCPP_HAS_IS_BASE_OF
        -:  849:
        -:  850:namespace __is_base_of_imp
        -:  851:{
        -:  852:template <class _Tp>
        -:  853:struct _Dst
        -:  854:{
        -:  855:    _Dst(const volatile _Tp &);
        -:  856:};
        -:  857:template <class _Tp>
        -:  858:struct _Src
        -:  859:{
        -:  860:    operator const volatile _Tp &();
        -:  861:    template <class _Up> operator const _Dst<_Up> &();
        -:  862:};
        -:  863:template <size_t> struct __one { typedef char type; };
        -:  864:template <class _Bp, class _Dp> typename __one<sizeof(_Dst<_Bp>(declval<_Src<_Dp> >()))>::type __test(int);
        -:  865:template <class _Bp, class _Dp> __two __test(...);
        -:  866:}
        -:  867:
        -:  868:template <class _Bp, class _Dp>
        -:  869:struct _LIBCPP_TYPE_VIS_ONLY is_base_of
        -:  870:    : public integral_constant<bool, is_class<_Bp>::value &&
        -:  871:                                     sizeof(__is_base_of_imp::__test<_Bp, _Dp>(0)) == 2> {};
        -:  872:
        -:  873:#endif  // _LIBCPP_HAS_IS_BASE_OF
        -:  874:
        -:  875:// is_convertible
        -:  876:
        -:  877:#if __has_feature(is_convertible_to) && !defined(_LIBCPP_USE_IS_CONVERTIBLE_FALLBACK)
        -:  878:
        -:  879:template <class _T1, class _T2> struct _LIBCPP_TYPE_VIS_ONLY is_convertible
        -:  880:    : public integral_constant<bool, __is_convertible_to(_T1, _T2) &&
        -:  881:                                     !is_abstract<_T2>::value> {};
        -:  882:
        -:  883:#else  // __has_feature(is_convertible_to)
        -:  884:
        -:  885:namespace __is_convertible_imp
        -:  886:{
        -:  887:template <class _Tp> void  __test_convert(_Tp);
        -:  888:
        -:  889:template <class _From, class _To, class = void>
        -:  890:struct __is_convertible_test : public false_type {};
        -:  891:
        -:  892:template <class _From, class _To>
        -:  893:struct __is_convertible_test<_From, _To,
        -:  894:    decltype(__test_convert<_To>(_VSTD::declval<_From>()))> : public true_type
        -:  895:{};
        -:  896:
        -:  897:template <class _Tp> __two __test(...);
        -:  898:#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -:  899:template <class _Tp> _Tp&& __source();
        -:  900:#else
        -:  901:template <class _Tp> typename remove_reference<_Tp>::type& __source();
        -:  902:#endif
        -:  903:
        -:  904:template <class _Tp, bool _IsArray =    is_array<_Tp>::value,
        -:  905:                     bool _IsFunction = is_function<_Tp>::value,
        -:  906:                     bool _IsVoid =     is_void<_Tp>::value>
        -:  907:                     struct __is_array_function_or_void                          {enum {value = 0};};
        -:  908:template <class _Tp> struct __is_array_function_or_void<_Tp, true, false, false> {enum {value = 1};};
        -:  909:template <class _Tp> struct __is_array_function_or_void<_Tp, false, true, false> {enum {value = 2};};
        -:  910:template <class _Tp> struct __is_array_function_or_void<_Tp, false, false, true> {enum {value = 3};};
        -:  911:}
        -:  912:
        -:  913:template <class _Tp,
        -:  914:    unsigned = __is_convertible_imp::__is_array_function_or_void<typename remove_reference<_Tp>::type>::value>
        -:  915:struct __is_convertible_check
        -:  916:{
        -:  917:    static const size_t __v = 0;
        -:  918:};
        -:  919:
        -:  920:template <class _Tp>
        -:  921:struct __is_convertible_check<_Tp, 0>
        -:  922:{
        -:  923:    static const size_t __v = sizeof(_Tp);
        -:  924:};
        -:  925:
        -:  926:template <class _T1, class _T2,
        -:  927:    unsigned _T1_is_array_function_or_void = __is_convertible_imp::__is_array_function_or_void<_T1>::value,
        -:  928:    unsigned _T2_is_array_function_or_void = __is_convertible_imp::__is_array_function_or_void<_T2>::value>
        -:  929:struct __is_convertible
        -:  930:    : public integral_constant<bool,
        -:  931:        __is_convertible_imp::__is_convertible_test<_T1, _T2>::value
        -:  932:#if defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)
        -:  933:         && !(!is_function<_T1>::value && !is_reference<_T1>::value && is_reference<_T2>::value
        -:  934:              && (!is_const<typename remove_reference<_T2>::type>::value
        -:  935:                  || is_volatile<typename remove_reference<_T2>::type>::value)
        -:  936:                  && (is_same<typename remove_cv<_T1>::type,
        -:  937:                              typename remove_cv<typename remove_reference<_T2>::type>::type>::value
        -:  938:                      || is_base_of<typename remove_reference<_T2>::type, _T1>::value))
        -:  939:#endif
        -:  940:    >
        -:  941:{};
        -:  942:
        -:  943:template <class _T1, class _T2> struct __is_convertible<_T1, _T2, 1, 0> : false_type {};
        -:  944:
        -:  945:template <class _T1> struct __is_convertible<_T1, const _T1&, 1, 0> : true_type {};
        -:  946:template <class _T1> struct __is_convertible<const _T1, const _T1&, 1, 0> : true_type {};
        -:  947:#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -:  948:template <class _T1> struct __is_convertible<_T1, _T1&&, 1, 0> : true_type {};
        -:  949:template <class _T1> struct __is_convertible<_T1, const _T1&&, 1, 0> : true_type {};
        -:  950:template <class _T1> struct __is_convertible<_T1, volatile _T1&&, 1, 0> : true_type {};
        -:  951:template <class _T1> struct __is_convertible<_T1, const volatile _T1&&, 1, 0> : true_type {};
        -:  952:#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -:  953:
        -:  954:template <class _T1, class _T2> struct __is_convertible<_T1, _T2*, 1, 0>
        -:  955:    : public integral_constant<bool, __is_convertible<typename remove_all_extents<_T1>::type*, _T2*>::value> {};
        -:  956:
        -:  957:template <class _T1, class _T2> struct __is_convertible<_T1, _T2* const, 1, 0>
        -:  958:    : public integral_constant<bool, __is_convertible<typename remove_all_extents<_T1>::type*, _T2*const>::value> {};
        -:  959:
        -:  960:template <class _T1, class _T2> struct __is_convertible<_T1, _T2* volatile, 1, 0>
        -:  961:    : public integral_constant<bool, __is_convertible<typename remove_all_extents<_T1>::type*, _T2*volatile>::value> {};
        -:  962:
        -:  963:template <class _T1, class _T2> struct __is_convertible<_T1, _T2* const volatile, 1, 0>
        -:  964:    : public integral_constant<bool, __is_convertible<typename remove_all_extents<_T1>::type*, _T2*const volatile>::value> {};
        -:  965:
        -:  966:template <class _T1, class _T2> struct __is_convertible<_T1, _T2, 2, 0>                : public false_type {};
        -:  967:#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -:  968:template <class _T1>            struct __is_convertible<_T1, _T1&&, 2, 0>               : public true_type {};
        -:  969:#endif
        -:  970:template <class _T1>            struct __is_convertible<_T1, _T1&, 2, 0>               : public true_type {};
        -:  971:template <class _T1>            struct __is_convertible<_T1, _T1*, 2, 0>               : public true_type {};
        -:  972:template <class _T1>            struct __is_convertible<_T1, _T1*const, 2, 0>          : public true_type {};
        -:  973:template <class _T1>            struct __is_convertible<_T1, _T1*volatile, 2, 0>       : public true_type {};
        -:  974:template <class _T1>            struct __is_convertible<_T1, _T1*const volatile, 2, 0> : public true_type {};
        -:  975:
        -:  976:template <class _T1, class _T2> struct __is_convertible<_T1, _T2, 3, 0> : public false_type {};
        -:  977:
        -:  978:template <class _T1, class _T2> struct __is_convertible<_T1, _T2, 0, 1> : public false_type {};
        -:  979:template <class _T1, class _T2> struct __is_convertible<_T1, _T2, 1, 1> : public false_type {};
        -:  980:template <class _T1, class _T2> struct __is_convertible<_T1, _T2, 2, 1> : public false_type {};
        -:  981:template <class _T1, class _T2> struct __is_convertible<_T1, _T2, 3, 1> : public false_type {};
        -:  982:
        -:  983:template <class _T1, class _T2> struct __is_convertible<_T1, _T2, 0, 2> : public false_type {};
        -:  984:template <class _T1, class _T2> struct __is_convertible<_T1, _T2, 1, 2> : public false_type {};
        -:  985:template <class _T1, class _T2> struct __is_convertible<_T1, _T2, 2, 2> : public false_type {};
        -:  986:template <class _T1, class _T2> struct __is_convertible<_T1, _T2, 3, 2> : public false_type {};
        -:  987:
        -:  988:template <class _T1, class _T2> struct __is_convertible<_T1, _T2, 0, 3> : public false_type {};
        -:  989:template <class _T1, class _T2> struct __is_convertible<_T1, _T2, 1, 3> : public false_type {};
        -:  990:template <class _T1, class _T2> struct __is_convertible<_T1, _T2, 2, 3> : public false_type {};
        -:  991:template <class _T1, class _T2> struct __is_convertible<_T1, _T2, 3, 3> : public true_type {};
        -:  992:
        -:  993:template <class _T1, class _T2> struct _LIBCPP_TYPE_VIS_ONLY is_convertible
        -:  994:    : public __is_convertible<_T1, _T2>
        -:  995:{
        -:  996:    static const size_t __complete_check1 = __is_convertible_check<_T1>::__v;
        -:  997:    static const size_t __complete_check2 = __is_convertible_check<_T2>::__v;
        -:  998:};
        -:  999:
        -: 1000:#endif  // __has_feature(is_convertible_to)
        -: 1001:
        -: 1002:// is_empty
        -: 1003:
        -: 1004:#if __has_feature(is_empty) || (_GNUC_VER >= 407)
        -: 1005:
        -: 1006:template <class _Tp>
        -: 1007:struct _LIBCPP_TYPE_VIS_ONLY is_empty
        -: 1008:    : public integral_constant<bool, __is_empty(_Tp)> {};
        -: 1009:
        -: 1010:#else  // __has_feature(is_empty)
        -: 1011:
        -: 1012:template <class _Tp>
        -: 1013:struct __is_empty1
        -: 1014:    : public _Tp
        -: 1015:{
        -: 1016:    double __lx;
        -: 1017:};
        -: 1018:
        -: 1019:struct __is_empty2
        -: 1020:{
        -: 1021:    double __lx;
        -: 1022:};
        -: 1023:
        -: 1024:template <class _Tp, bool = is_class<_Tp>::value>
        -: 1025:struct __libcpp_empty : public integral_constant<bool, sizeof(__is_empty1<_Tp>) == sizeof(__is_empty2)> {};
        -: 1026:
        -: 1027:template <class _Tp> struct __libcpp_empty<_Tp, false> : public false_type {};
        -: 1028:
        -: 1029:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_empty : public __libcpp_empty<_Tp> {};
        -: 1030:
        -: 1031:#endif  // __has_feature(is_empty)
        -: 1032:
        -: 1033:// is_polymorphic
        -: 1034:
        -: 1035:#if __has_feature(is_polymorphic) || defined(_LIBCPP_MSVC)
        -: 1036:
        -: 1037:template <class _Tp>
        -: 1038:struct _LIBCPP_TYPE_VIS_ONLY is_polymorphic
        -: 1039:    : public integral_constant<bool, __is_polymorphic(_Tp)> {};
        -: 1040:
        -: 1041:#else
        -: 1042:
        -: 1043:template<typename _Tp> char &__is_polymorphic_impl(
        -: 1044:    typename enable_if<sizeof((_Tp*)dynamic_cast<const volatile void*>(declval<_Tp*>())) != 0,
        -: 1045:                       int>::type);
        -: 1046:template<typename _Tp> __two &__is_polymorphic_impl(...);
        -: 1047:
        -: 1048:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_polymorphic
        -: 1049:    : public integral_constant<bool, sizeof(__is_polymorphic_impl<_Tp>(0)) == 1> {};
        -: 1050:
        -: 1051:#endif // __has_feature(is_polymorphic)
        -: 1052:
        -: 1053:// has_virtual_destructor
        -: 1054:
        -: 1055:#if __has_feature(has_virtual_destructor) || (_GNUC_VER >= 403)
        -: 1056:
        -: 1057:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY has_virtual_destructor
        -: 1058:    : public integral_constant<bool, __has_virtual_destructor(_Tp)> {};
        -: 1059:
        -: 1060:#else
        -: 1061:
        -: 1062:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY has_virtual_destructor
        -: 1063:    : public false_type {};
        -: 1064:
        -: 1065:#endif
        -: 1066:
        -: 1067:// alignment_of
        -: 1068:
        -: 1069:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY alignment_of
        -: 1070:    : public integral_constant<size_t, __alignof__(_Tp)> {};
        -: 1071:
        -: 1072:// aligned_storage
        -: 1073:
        -: 1074:template <class _Hp, class _Tp>
        -: 1075:struct __type_list
        -: 1076:{
        -: 1077:    typedef _Hp _Head;
        -: 1078:    typedef _Tp _Tail;
        -: 1079:};
        -: 1080:
        -: 1081:struct __nat
        -: 1082:{
        -: 1083:#ifndef _LIBCPP_HAS_NO_DELETED_FUNCTIONS
        -: 1084:    __nat() = delete;
        -: 1085:    __nat(const __nat&) = delete;
        -: 1086:    __nat& operator=(const __nat&) = delete;
        -: 1087:    ~__nat() = delete;
        -: 1088:#endif
        -: 1089:};
        -: 1090:
        -: 1091:template <class _Tp>
        -: 1092:struct __align_type
        -: 1093:{
        -: 1094:    static const size_t value = alignment_of<_Tp>::value;
        -: 1095:    typedef _Tp type;
        -: 1096:};
        -: 1097:
        -: 1098:struct __struct_double {long double __lx;};
        -: 1099:struct __struct_double4 {double __lx[4];};
        -: 1100:
        -: 1101:typedef
        -: 1102:    __type_list<__align_type<unsigned char>,
        -: 1103:    __type_list<__align_type<unsigned short>,
        -: 1104:    __type_list<__align_type<unsigned int>,
        -: 1105:    __type_list<__align_type<unsigned long>,
        -: 1106:    __type_list<__align_type<unsigned long long>,
        -: 1107:    __type_list<__align_type<double>,
        -: 1108:    __type_list<__align_type<long double>,
        -: 1109:    __type_list<__align_type<__struct_double>,
        -: 1110:    __type_list<__align_type<__struct_double4>,
        -: 1111:    __type_list<__align_type<int*>,
        -: 1112:    __nat
        -: 1113:    > > > > > > > > > > __all_types;
        -: 1114:
        -: 1115:template <class _TL, size_t _Align> struct __find_pod;
        -: 1116:
        -: 1117:template <class _Hp, size_t _Align>
        -: 1118:struct __find_pod<__type_list<_Hp, __nat>, _Align>
        -: 1119:{
        -: 1120:    typedef typename conditional<
        -: 1121:                             _Align == _Hp::value,
        -: 1122:                             typename _Hp::type,
        -: 1123:                             void
        -: 1124:                         >::type type;
        -: 1125:};
        -: 1126:
        -: 1127:template <class _Hp, class _Tp, size_t _Align>
        -: 1128:struct __find_pod<__type_list<_Hp, _Tp>, _Align>
        -: 1129:{
        -: 1130:    typedef typename conditional<
        -: 1131:                             _Align == _Hp::value,
        -: 1132:                             typename _Hp::type,
        -: 1133:                             typename __find_pod<_Tp, _Align>::type
        -: 1134:                         >::type type;
        -: 1135:};
        -: 1136:
        -: 1137:template <class _TL, size_t _Len> struct __find_max_align;
        -: 1138:
        -: 1139:template <class _Hp, size_t _Len>
        -: 1140:struct __find_max_align<__type_list<_Hp, __nat>, _Len> : public integral_constant<size_t, _Hp::value> {};
        -: 1141:
        -: 1142:template <size_t _Len, size_t _A1, size_t _A2>
        -: 1143:struct __select_align
        -: 1144:{
        -: 1145:private:
        -: 1146:    static const size_t __min = _A2 < _A1 ? _A2 : _A1;
        -: 1147:    static const size_t __max = _A1 < _A2 ? _A2 : _A1;
        -: 1148:public:
        -: 1149:    static const size_t value = _Len < __max ? __min : __max;
        -: 1150:};
        -: 1151:
        -: 1152:template <class _Hp, class _Tp, size_t _Len>
        -: 1153:struct __find_max_align<__type_list<_Hp, _Tp>, _Len>
        -: 1154:    : public integral_constant<size_t, __select_align<_Len, _Hp::value, __find_max_align<_Tp, _Len>::value>::value> {};
        -: 1155:
        -: 1156:template <size_t _Len, size_t _Align = __find_max_align<__all_types, _Len>::value>
        -: 1157:struct _LIBCPP_TYPE_VIS_ONLY aligned_storage
        -: 1158:{
        -: 1159:    typedef typename __find_pod<__all_types, _Align>::type _Aligner;
        -: 1160:    static_assert(!is_void<_Aligner>::value, "");
        -: 1161:    union type
        -: 1162:    {
        -: 1163:        _Aligner __align;
        -: 1164:        unsigned char __data[_Len];
        -: 1165:    };
        -: 1166:};
        -: 1167:
        -: 1168:#if _LIBCPP_STD_VER > 11
        -: 1169:template <size_t _Len, size_t _Align = __find_max_align<__all_types, _Len>::value>
        -: 1170:    using aligned_storage_t = typename aligned_storage<_Len, _Align>::type;
        -: 1171:#endif
        -: 1172:
        -: 1173:#define _CREATE_ALIGNED_STORAGE_SPECIALIZATION(n) \
        -: 1174:template <size_t _Len>\
        -: 1175:struct _LIBCPP_TYPE_VIS_ONLY aligned_storage<_Len, n>\
        -: 1176:{\
        -: 1177:    struct _ALIGNAS(n) type\
        -: 1178:    {\
        -: 1179:        unsigned char __lx[_Len];\
        -: 1180:    };\
        -: 1181:}
        -: 1182:
        -: 1183:_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x1);
        -: 1184:_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x2);
        -: 1185:_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x4);
        -: 1186:_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x8);
        -: 1187:_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x10);
        -: 1188:_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x20);
        -: 1189:_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x40);
        -: 1190:_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x80);
        -: 1191:_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x100);
        -: 1192:_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x200);
        -: 1193:_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x400);
        -: 1194:_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x800);
        -: 1195:_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x1000);
        -: 1196:_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x2000);
        -: 1197:// MSDN says that MSVC does not support alignment beyond 8192 (=0x2000)
        -: 1198:#if !defined(_LIBCPP_MSVC)
        -: 1199:_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x4000);
        -: 1200:#endif // !_LIBCPP_MSVC
        -: 1201:
        -: 1202:#undef _CREATE_ALIGNED_STORAGE_SPECIALIZATION
        -: 1203:
        -: 1204:#ifndef _LIBCPP_HAS_NO_VARIADICS
        -: 1205:
        -: 1206:// aligned_union
        -: 1207:
        -: 1208:template <size_t _I0, size_t ..._In>
        -: 1209:struct __static_max;
        -: 1210:
        -: 1211:template <size_t _I0>
        -: 1212:struct __static_max<_I0>
        -: 1213:{
        -: 1214:    static const size_t value = _I0;
        -: 1215:};
        -: 1216:
        -: 1217:template <size_t _I0, size_t _I1, size_t ..._In>
        -: 1218:struct __static_max<_I0, _I1, _In...>
        -: 1219:{
        -: 1220:    static const size_t value = _I0 >= _I1 ? __static_max<_I0, _In...>::value :
        -: 1221:                                             __static_max<_I1, _In...>::value;
        -: 1222:};
        -: 1223:
        -: 1224:template <size_t _Len, class _Type0, class ..._Types>
        -: 1225:struct aligned_union
        -: 1226:{
        -: 1227:    static const size_t alignment_value = __static_max<__alignof__(_Type0),
        -: 1228:                                                       __alignof__(_Types)...>::value;
        -: 1229:    static const size_t __len = __static_max<_Len, sizeof(_Type0),
        -: 1230:                                             sizeof(_Types)...>::value;
        -: 1231:    typedef typename aligned_storage<__len, alignment_value>::type type;
        -: 1232:};
        -: 1233:
        -: 1234:#if _LIBCPP_STD_VER > 11
        -: 1235:template <size_t _Len, class ..._Types> using aligned_union_t = typename aligned_union<_Len, _Types...>::type;
        -: 1236:#endif
        -: 1237:
        -: 1238:#endif  // _LIBCPP_HAS_NO_VARIADICS
        -: 1239:
        -: 1240:template <class _Tp>
        -: 1241:struct __numeric_type
        -: 1242:{
        -: 1243:   static void __test(...);
        -: 1244:   static float __test(float);
        -: 1245:   static double __test(char);
        -: 1246:   static double __test(int);
        -: 1247:   static double __test(unsigned);
        -: 1248:   static double __test(long);
        -: 1249:   static double __test(unsigned long);
        -: 1250:   static double __test(long long);
        -: 1251:   static double __test(unsigned long long);
        -: 1252:   static double __test(double);
        -: 1253:   static long double __test(long double);
        -: 1254:
        -: 1255:   typedef decltype(__test(declval<_Tp>())) type;
        -: 1256:   static const bool value = !is_same<type, void>::value;
        -: 1257:};
        -: 1258:
        -: 1259:template <>
        -: 1260:struct __numeric_type<void>
        -: 1261:{
        -: 1262:   static const bool value = true;
        -: 1263:};
        -: 1264:
        -: 1265:// __promote
        -: 1266:
        -: 1267:template <class _A1, class _A2 = void, class _A3 = void,
        -: 1268:          bool = __numeric_type<_A1>::value &&
        -: 1269:                 __numeric_type<_A2>::value &&
        -: 1270:                 __numeric_type<_A3>::value>
        -: 1271:class __promote_imp
        -: 1272:{
        -: 1273:public:
        -: 1274:    static const bool value = false;
        -: 1275:};
        -: 1276:
        -: 1277:template <class _A1, class _A2, class _A3>
        -: 1278:class __promote_imp<_A1, _A2, _A3, true>
        -: 1279:{
        -: 1280:private:
        -: 1281:    typedef typename __promote_imp<_A1>::type __type1;
        -: 1282:    typedef typename __promote_imp<_A2>::type __type2;
        -: 1283:    typedef typename __promote_imp<_A3>::type __type3;
        -: 1284:public:
        -: 1285:    typedef decltype(__type1() + __type2() + __type3()) type;
        -: 1286:    static const bool value = true;
        -: 1287:};
        -: 1288:
        -: 1289:template <class _A1, class _A2>
        -: 1290:class __promote_imp<_A1, _A2, void, true>
        -: 1291:{
        -: 1292:private:
        -: 1293:    typedef typename __promote_imp<_A1>::type __type1;
        -: 1294:    typedef typename __promote_imp<_A2>::type __type2;
        -: 1295:public:
        -: 1296:    typedef decltype(__type1() + __type2()) type;
        -: 1297:    static const bool value = true;
        -: 1298:};
        -: 1299:
        -: 1300:template <class _A1>
        -: 1301:class __promote_imp<_A1, void, void, true>
        -: 1302:{
        -: 1303:public:
        -: 1304:    typedef typename __numeric_type<_A1>::type type;
        -: 1305:    static const bool value = true;
        -: 1306:};
        -: 1307:
        -: 1308:template <class _A1, class _A2 = void, class _A3 = void>
        -: 1309:class __promote : public __promote_imp<_A1, _A2, _A3> {};
        -: 1310:
        -: 1311:#ifdef _LIBCPP_STORE_AS_OPTIMIZATION
        -: 1312:
        -: 1313:// __transform
        -: 1314:
        -: 1315:template <class _Tp, size_t = sizeof(_Tp), bool = is_scalar<_Tp>::value> struct __transform {typedef _Tp type;};
        -: 1316:template <class _Tp> struct __transform<_Tp, 1, true> {typedef unsigned char      type;};
        -: 1317:template <class _Tp> struct __transform<_Tp, 2, true> {typedef unsigned short     type;};
        -: 1318:template <class _Tp> struct __transform<_Tp, 4, true> {typedef unsigned int       type;};
        -: 1319:template <class _Tp> struct __transform<_Tp, 8, true> {typedef unsigned long long type;};
        -: 1320:
        -: 1321:#endif  // _LIBCPP_STORE_AS_OPTIMIZATION
        -: 1322:
        -: 1323:// make_signed / make_unsigned
        -: 1324:
        -: 1325:typedef
        -: 1326:    __type_list<signed char,
        -: 1327:    __type_list<signed short,
        -: 1328:    __type_list<signed int,
        -: 1329:    __type_list<signed long,
        -: 1330:    __type_list<signed long long,
        -: 1331:#ifndef _LIBCPP_HAS_NO_INT128
        -: 1332:    __type_list<__int128_t,
        -: 1333:#endif
        -: 1334:    __nat
        -: 1335:#ifndef _LIBCPP_HAS_NO_INT128
        -: 1336:    >
        -: 1337:#endif
        -: 1338:    > > > > > __signed_types;
        -: 1339:
        -: 1340:typedef
        -: 1341:    __type_list<unsigned char,
        -: 1342:    __type_list<unsigned short,
        -: 1343:    __type_list<unsigned int,
        -: 1344:    __type_list<unsigned long,
        -: 1345:    __type_list<unsigned long long,
        -: 1346:#ifndef _LIBCPP_HAS_NO_INT128
        -: 1347:    __type_list<__uint128_t,
        -: 1348:#endif
        -: 1349:    __nat
        -: 1350:#ifndef _LIBCPP_HAS_NO_INT128
        -: 1351:    >
        -: 1352:#endif
        -: 1353:    > > > > > __unsigned_types;
        -: 1354:
        -: 1355:template <class _TypeList, size_t _Size, bool = _Size <= sizeof(typename _TypeList::_Head)> struct __find_first;
        -: 1356:
        -: 1357:template <class _Hp, class _Tp, size_t _Size>
        -: 1358:struct __find_first<__type_list<_Hp, _Tp>, _Size, true>
        -: 1359:{
        -: 1360:    typedef _Hp type;
        -: 1361:};
        -: 1362:
        -: 1363:template <class _Hp, class _Tp, size_t _Size>
        -: 1364:struct __find_first<__type_list<_Hp, _Tp>, _Size, false>
        -: 1365:{
        -: 1366:    typedef typename __find_first<_Tp, _Size>::type type;
        -: 1367:};
        -: 1368:
        -: 1369:template <class _Tp, class _Up, bool = is_const<typename remove_reference<_Tp>::type>::value,
        -: 1370:                             bool = is_volatile<typename remove_reference<_Tp>::type>::value>
        -: 1371:struct __apply_cv
        -: 1372:{
        -: 1373:    typedef _Up type;
        -: 1374:};
        -: 1375:
        -: 1376:template <class _Tp, class _Up>
        -: 1377:struct __apply_cv<_Tp, _Up, true, false>
        -: 1378:{
        -: 1379:    typedef const _Up type;
        -: 1380:};
        -: 1381:
        -: 1382:template <class _Tp, class _Up>
        -: 1383:struct __apply_cv<_Tp, _Up, false, true>
        -: 1384:{
        -: 1385:    typedef volatile _Up type;
        -: 1386:};
        -: 1387:
        -: 1388:template <class _Tp, class _Up>
        -: 1389:struct __apply_cv<_Tp, _Up, true, true>
        -: 1390:{
        -: 1391:    typedef const volatile _Up type;
        -: 1392:};
        -: 1393:
        -: 1394:template <class _Tp, class _Up>
        -: 1395:struct __apply_cv<_Tp&, _Up, false, false>
        -: 1396:{
        -: 1397:    typedef _Up& type;
        -: 1398:};
        -: 1399:
        -: 1400:template <class _Tp, class _Up>
        -: 1401:struct __apply_cv<_Tp&, _Up, true, false>
        -: 1402:{
        -: 1403:    typedef const _Up& type;
        -: 1404:};
        -: 1405:
        -: 1406:template <class _Tp, class _Up>
        -: 1407:struct __apply_cv<_Tp&, _Up, false, true>
        -: 1408:{
        -: 1409:    typedef volatile _Up& type;
        -: 1410:};
        -: 1411:
        -: 1412:template <class _Tp, class _Up>
        -: 1413:struct __apply_cv<_Tp&, _Up, true, true>
        -: 1414:{
        -: 1415:    typedef const volatile _Up& type;
        -: 1416:};
        -: 1417:
        -: 1418:template <class _Tp, bool = is_integral<_Tp>::value || is_enum<_Tp>::value>
        -: 1419:struct __make_signed {};
        -: 1420:
        -: 1421:template <class _Tp>
        -: 1422:struct __make_signed<_Tp, true>
        -: 1423:{
        -: 1424:    typedef typename __find_first<__signed_types, sizeof(_Tp)>::type type;
        -: 1425:};
        -: 1426:
        -: 1427:template <> struct __make_signed<bool,               true> {};
        -: 1428:template <> struct __make_signed<  signed short,     true> {typedef short     type;};
        -: 1429:template <> struct __make_signed<unsigned short,     true> {typedef short     type;};
        -: 1430:template <> struct __make_signed<  signed int,       true> {typedef int       type;};
        -: 1431:template <> struct __make_signed<unsigned int,       true> {typedef int       type;};
        -: 1432:template <> struct __make_signed<  signed long,      true> {typedef long      type;};
        -: 1433:template <> struct __make_signed<unsigned long,      true> {typedef long      type;};
        -: 1434:template <> struct __make_signed<  signed long long, true> {typedef long long type;};
        -: 1435:template <> struct __make_signed<unsigned long long, true> {typedef long long type;};
        -: 1436:#ifndef _LIBCPP_HAS_NO_INT128
        -: 1437:template <> struct __make_signed<__int128_t,         true> {typedef __int128_t type;};
        -: 1438:template <> struct __make_signed<__uint128_t,        true> {typedef __int128_t type;};
        -: 1439:#endif
        -: 1440:
        -: 1441:template <class _Tp>
        -: 1442:struct _LIBCPP_TYPE_VIS_ONLY make_signed
        -: 1443:{
        -: 1444:    typedef typename __apply_cv<_Tp, typename __make_signed<typename remove_cv<_Tp>::type>::type>::type type;
        -: 1445:};
        -: 1446:
        -: 1447:#if _LIBCPP_STD_VER > 11
        -: 1448:template <class _Tp> using make_signed_t = typename make_signed<_Tp>::type;
        -: 1449:#endif
        -: 1450:
        -: 1451:template <class _Tp, bool = is_integral<_Tp>::value || is_enum<_Tp>::value>
        -: 1452:struct __make_unsigned {};
        -: 1453:
        -: 1454:template <class _Tp>
        -: 1455:struct __make_unsigned<_Tp, true>
        -: 1456:{
        -: 1457:    typedef typename __find_first<__unsigned_types, sizeof(_Tp)>::type type;
        -: 1458:};
        -: 1459:
        -: 1460:template <> struct __make_unsigned<bool,               true> {};
        -: 1461:template <> struct __make_unsigned<  signed short,     true> {typedef unsigned short     type;};
        -: 1462:template <> struct __make_unsigned<unsigned short,     true> {typedef unsigned short     type;};
        -: 1463:template <> struct __make_unsigned<  signed int,       true> {typedef unsigned int       type;};
        -: 1464:template <> struct __make_unsigned<unsigned int,       true> {typedef unsigned int       type;};
        -: 1465:template <> struct __make_unsigned<  signed long,      true> {typedef unsigned long      type;};
        -: 1466:template <> struct __make_unsigned<unsigned long,      true> {typedef unsigned long      type;};
        -: 1467:template <> struct __make_unsigned<  signed long long, true> {typedef unsigned long long type;};
        -: 1468:template <> struct __make_unsigned<unsigned long long, true> {typedef unsigned long long type;};
        -: 1469:#ifndef _LIBCPP_HAS_NO_INT128
        -: 1470:template <> struct __make_unsigned<__int128_t,         true> {typedef __uint128_t        type;};
        -: 1471:template <> struct __make_unsigned<__uint128_t,        true> {typedef __uint128_t        type;};
        -: 1472:#endif
        -: 1473:
        -: 1474:template <class _Tp>
        -: 1475:struct _LIBCPP_TYPE_VIS_ONLY make_unsigned
        -: 1476:{
        -: 1477:    typedef typename __apply_cv<_Tp, typename __make_unsigned<typename remove_cv<_Tp>::type>::type>::type type;
        -: 1478:};
        -: 1479:
        -: 1480:#if _LIBCPP_STD_VER > 11
        -: 1481:template <class _Tp> using make_unsigned_t = typename make_unsigned<_Tp>::type;
        -: 1482:#endif
        -: 1483:
        -: 1484:#ifdef _LIBCPP_HAS_NO_VARIADICS
        -: 1485:
        -: 1486:template <class _Tp, class _Up = void, class _Vp = void>
        -: 1487:struct _LIBCPP_TYPE_VIS_ONLY common_type
        -: 1488:{
        -: 1489:public:
        -: 1490:    typedef typename common_type<typename common_type<_Tp, _Up>::type, _Vp>::type type;
        -: 1491:};
        -: 1492:
        -: 1493:template <class _Tp>
        -: 1494:struct _LIBCPP_TYPE_VIS_ONLY common_type<_Tp, void, void>
        -: 1495:{
        -: 1496:public:
        -: 1497:    typedef typename decay<_Tp>::type type;
        -: 1498:};
        -: 1499:
        -: 1500:template <class _Tp, class _Up>
        -: 1501:struct _LIBCPP_TYPE_VIS_ONLY common_type<_Tp, _Up, void>
        -: 1502:{
        -: 1503:private:
        -: 1504:#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -: 1505:    static _Tp&& __t();
        -: 1506:    static _Up&& __u();
        -: 1507:#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -: 1508:    static _Tp __t();
        -: 1509:    static _Up __u();
        -: 1510:#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -: 1511:public:
        -: 1512:    typedef typename remove_reference<decltype(true ? __t() : __u())>::type type;
        -: 1513:};
        -: 1514:
        -: 1515:#else  // _LIBCPP_HAS_NO_VARIADICS
        -: 1516:
        -: 1517:template <class ..._Tp> struct common_type;
        -: 1518:
        -: 1519:template <class _Tp>
        -: 1520:struct _LIBCPP_TYPE_VIS_ONLY common_type<_Tp>
        -: 1521:{
        -: 1522:    typedef typename decay<_Tp>::type type;
        -: 1523:};
        -: 1524:
        -: 1525:template <class _Tp, class _Up>
        -: 1526:struct _LIBCPP_TYPE_VIS_ONLY common_type<_Tp, _Up>
        -: 1527:{
        -: 1528:private:
        -: 1529:    static _Tp&& __t();
        -: 1530:    static _Up&& __u();
        -: 1531:    static bool __f();
        -: 1532:public:
        -: 1533:    typedef typename decay<decltype(__f() ? __t() : __u())>::type type;
        -: 1534:};
        -: 1535:
        -: 1536:template <class _Tp, class _Up, class ..._Vp>
        -: 1537:struct _LIBCPP_TYPE_VIS_ONLY common_type<_Tp, _Up, _Vp...>
        -: 1538:{
        -: 1539:    typedef typename common_type<typename common_type<_Tp, _Up>::type, _Vp...>::type type;
        -: 1540:};
        -: 1541:
        -: 1542:#if _LIBCPP_STD_VER > 11
        -: 1543:template <class ..._Tp> using common_type_t = typename common_type<_Tp...>::type;
        -: 1544:#endif
        -: 1545:
        -: 1546:#endif  // _LIBCPP_HAS_NO_VARIADICS
        -: 1547:
        -: 1548:// is_assignable
        -: 1549:
        -: 1550:template<typename, typename _Tp> struct __select_2nd { typedef _Tp type; };
        -: 1551:
        -: 1552:template <class _Tp, class _Arg>
        -: 1553:typename __select_2nd<decltype((_VSTD::declval<_Tp>() = _VSTD::declval<_Arg>())), true_type>::type
        -: 1554:#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -: 1555:__is_assignable_test(_Tp&&, _Arg&&);
        -: 1556:#else
        -: 1557:__is_assignable_test(_Tp, _Arg&);
        -: 1558:#endif
        -: 1559:
        -: 1560:template <class _Arg>
        -: 1561:false_type
        -: 1562:#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -: 1563:__is_assignable_test(__any, _Arg&&);
        -: 1564:#else
        -: 1565:__is_assignable_test(__any, _Arg&);
        -: 1566:#endif
        -: 1567:
        -: 1568:template <class _Tp, class _Arg, bool = is_void<_Tp>::value || is_void<_Arg>::value>
        -: 1569:struct __is_assignable_imp
        -: 1570:    : public common_type
        -: 1571:        <
        -: 1572:            decltype(_VSTD::__is_assignable_test(declval<_Tp>(), declval<_Arg>()))
        -: 1573:        >::type {};
        -: 1574:
        -: 1575:template <class _Tp, class _Arg>
        -: 1576:struct __is_assignable_imp<_Tp, _Arg, true>
        -: 1577:    : public false_type
        -: 1578:{
        -: 1579:};
        -: 1580:
        -: 1581:template <class _Tp, class _Arg>
        -: 1582:struct is_assignable
        -: 1583:    : public __is_assignable_imp<_Tp, _Arg> {};
        -: 1584:
        -: 1585:// is_copy_assignable
        -: 1586:
        -: 1587:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_copy_assignable
        -: 1588:    : public is_assignable<typename add_lvalue_reference<_Tp>::type,
        -: 1589:                  typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {};
        -: 1590:
        -: 1591:// is_move_assignable
        -: 1592:
        -: 1593:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_move_assignable
        -: 1594:#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -: 1595:    : public is_assignable<typename add_lvalue_reference<_Tp>::type,
        -: 1596:                     const typename add_rvalue_reference<_Tp>::type> {};
        -: 1597:#else
        -: 1598:    : public is_copy_assignable<_Tp> {};
        -: 1599:#endif
        -: 1600:
        -: 1601:// is_destructible
        -: 1602:
        -: 1603://  if it's a reference, return true
        -: 1604://  if it's a function, return false
        -: 1605://  if it's   void,     return false
        -: 1606://  if it's an array of unknown bound, return false
        -: 1607://  Otherwise, return "std::declval<_Up&>().~_Up()" is well-formed
        -: 1608://    where _Up is remove_all_extents<_Tp>::type
        -: 1609:
        -: 1610:template <class>
        -: 1611:struct __is_destructible_apply { typedef int type; };
        -: 1612:
        -: 1613:template <typename _Tp>
        -: 1614:struct __is_destructor_wellformed {
        -: 1615:    template <typename _Tp1>
        -: 1616:    static char  __test (
        -: 1617:        typename __is_destructible_apply<decltype(_VSTD::declval<_Tp1&>().~_Tp1())>::type
        -: 1618:    );
        -: 1619:
        -: 1620:    template <typename _Tp1>
        -: 1621:    static __two __test (...);
        -: 1622:    
        -: 1623:    static const bool value = sizeof(__test<_Tp>(12)) == sizeof(char);
        -: 1624:};
        -: 1625:
        -: 1626:template <class _Tp, bool>
        -: 1627:struct __destructible_imp;
        -: 1628:
        -: 1629:template <class _Tp>
        -: 1630:struct __destructible_imp<_Tp, false> 
        -: 1631:   : public _VSTD::integral_constant<bool, 
        -: 1632:        __is_destructor_wellformed<typename _VSTD::remove_all_extents<_Tp>::type>::value> {};
        -: 1633:
        -: 1634:template <class _Tp>
        -: 1635:struct __destructible_imp<_Tp, true>
        -: 1636:    : public _VSTD::true_type {};
        -: 1637:
        -: 1638:template <class _Tp, bool>
        -: 1639:struct __destructible_false;
        -: 1640:
        -: 1641:template <class _Tp>
        -: 1642:struct __destructible_false<_Tp, false> : public __destructible_imp<_Tp, _VSTD::is_reference<_Tp>::value> {};
        -: 1643:
        -: 1644:template <class _Tp>
        -: 1645:struct __destructible_false<_Tp, true> : public _VSTD::false_type {};
        -: 1646:
        -: 1647:template <class _Tp>
        -: 1648:struct is_destructible
        -: 1649:    : public __destructible_false<_Tp, _VSTD::is_function<_Tp>::value> {};
        -: 1650:
        -: 1651:template <class _Tp>
        -: 1652:struct is_destructible<_Tp[]>
        -: 1653:    : public _VSTD::false_type {};
        -: 1654:
        -: 1655:template <>
        -: 1656:struct is_destructible<void>
        -: 1657:    : public _VSTD::false_type {};
        -: 1658:
        -: 1659:// move
        -: 1660:
        -: 1661:#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -: 1662:
        -: 1663:template <class _Tp>
        -: 1664:inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11
        -: 1665:typename remove_reference<_Tp>::type&&
        -: 1666:move(_Tp&& __t) _NOEXCEPT
        -: 1667:{
        -: 1668:    typedef typename remove_reference<_Tp>::type _Up;
        -: 1669:    return static_cast<_Up&&>(__t);
        -: 1670:}
        -: 1671:
        -: 1672:template <class _Tp>
        -: 1673:inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11
        -: 1674:_Tp&&
        -: 1675:forward(typename std::remove_reference<_Tp>::type& __t) _NOEXCEPT
        -: 1676:{
    #####: 1677:    return static_cast<_Tp&&>(__t);
        -: 1678:}
        -: 1679:
        -: 1680:template <class _Tp>
        -: 1681:inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11
        -: 1682:_Tp&&
        -: 1683:forward(typename std::remove_reference<_Tp>::type&& __t) _NOEXCEPT
        -: 1684:{
        -: 1685:    static_assert(!std::is_lvalue_reference<_Tp>::value,
        -: 1686:                  "Can not forward an rvalue as an lvalue.");
        -: 1687:    return static_cast<_Tp&&>(__t);
        -: 1688:}
        -: 1689:
        -: 1690:#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -: 1691:
        -: 1692:template <class _Tp>
        -: 1693:inline _LIBCPP_INLINE_VISIBILITY
        -: 1694:_Tp&
        -: 1695:move(_Tp& __t)
        -: 1696:{
        -: 1697:    return __t;
        -: 1698:}
        -: 1699:
        -: 1700:template <class _Tp>
        -: 1701:inline _LIBCPP_INLINE_VISIBILITY
        -: 1702:const _Tp&
        -: 1703:move(const _Tp& __t)
        -: 1704:{
        -: 1705:    return __t;
        -: 1706:}
        -: 1707:
        -: 1708:template <class _Tp>
        -: 1709:inline _LIBCPP_INLINE_VISIBILITY
        -: 1710:_Tp&
        -: 1711:forward(typename std::remove_reference<_Tp>::type& __t) _NOEXCEPT
        -: 1712:{
        -: 1713:    return __t;
        -: 1714:}
        -: 1715:
        -: 1716:
        -: 1717:template <class _Tp>
        -: 1718:class __rv
        -: 1719:{
        -: 1720:    typedef typename remove_reference<_Tp>::type _Trr;
        -: 1721:    _Trr& t_;
        -: 1722:public:
        -: 1723:    _LIBCPP_INLINE_VISIBILITY
        -: 1724:    _Trr* operator->() {return &t_;}
        -: 1725:    _LIBCPP_INLINE_VISIBILITY
        -: 1726:    explicit __rv(_Trr& __t) : t_(__t) {}
        -: 1727:};
        -: 1728:
        -: 1729:#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -: 1730:
        -: 1731:#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -: 1732:
        -: 1733:template <class _Tp>
        -: 1734:inline _LIBCPP_INLINE_VISIBILITY
        -: 1735:typename decay<_Tp>::type
        -: 1736:__decay_copy(_Tp&& __t)
        -: 1737:{
        -: 1738:    return _VSTD::forward<_Tp>(__t);
        -: 1739:}
        -: 1740:
        -: 1741:#else
        -: 1742:
        -: 1743:template <class _Tp>
        -: 1744:inline _LIBCPP_INLINE_VISIBILITY
        -: 1745:typename decay<_Tp>::type
        -: 1746:__decay_copy(const _Tp& __t)
        -: 1747:{
        -: 1748:    return _VSTD::forward<_Tp>(__t);
        -: 1749:}
        -: 1750:
        -: 1751:#endif
        -: 1752:
        -: 1753:#ifndef _LIBCPP_HAS_NO_VARIADICS
        -: 1754:
        -: 1755:template <class _Rp, class _Class, class ..._Param>
        -: 1756:struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...), true, false>
        -: 1757:{
        -: 1758:    typedef _Class _ClassType;
        -: 1759:    typedef _Rp _ReturnType;
        -: 1760:    typedef _Rp (_FnType) (_Param...);
        -: 1761:};
        -: 1762:
        -: 1763:template <class _Rp, class _Class, class ..._Param>
        -: 1764:struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...), true, false>
        -: 1765:{
        -: 1766:    typedef _Class _ClassType;
        -: 1767:    typedef _Rp _ReturnType;
        -: 1768:    typedef _Rp (_FnType) (_Param..., ...);
        -: 1769:};
        -: 1770:
        -: 1771:template <class _Rp, class _Class, class ..._Param>
        -: 1772:struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const, true, false>
        -: 1773:{
        -: 1774:    typedef _Class const _ClassType;
        -: 1775:    typedef _Rp _ReturnType;
        -: 1776:    typedef _Rp (_FnType) (_Param...);
        -: 1777:};
        -: 1778:
        -: 1779:template <class _Rp, class _Class, class ..._Param>
        -: 1780:struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const, true, false>
        -: 1781:{
        -: 1782:    typedef _Class const _ClassType;
        -: 1783:    typedef _Rp _ReturnType;
        -: 1784:    typedef _Rp (_FnType) (_Param..., ...);
        -: 1785:};
        -: 1786:
        -: 1787:template <class _Rp, class _Class, class ..._Param>
        -: 1788:struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) volatile, true, false>
        -: 1789:{
        -: 1790:    typedef _Class volatile _ClassType;
        -: 1791:    typedef _Rp _ReturnType;
        -: 1792:    typedef _Rp (_FnType) (_Param...);
        -: 1793:};
        -: 1794:
        -: 1795:template <class _Rp, class _Class, class ..._Param>
        -: 1796:struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) volatile, true, false>
        -: 1797:{
        -: 1798:    typedef _Class volatile _ClassType;
        -: 1799:    typedef _Rp _ReturnType;
        -: 1800:    typedef _Rp (_FnType) (_Param..., ...);
        -: 1801:};
        -: 1802:
        -: 1803:template <class _Rp, class _Class, class ..._Param>
        -: 1804:struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const volatile, true, false>
        -: 1805:{
        -: 1806:    typedef _Class const volatile _ClassType;
        -: 1807:    typedef _Rp _ReturnType;
        -: 1808:    typedef _Rp (_FnType) (_Param...);
        -: 1809:};
        -: 1810:
        -: 1811:template <class _Rp, class _Class, class ..._Param>
        -: 1812:struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const volatile, true, false>
        -: 1813:{
        -: 1814:    typedef _Class const volatile _ClassType;
        -: 1815:    typedef _Rp _ReturnType;
        -: 1816:    typedef _Rp (_FnType) (_Param..., ...);
        -: 1817:};
        -: 1818:
        -: 1819:#if __has_feature(cxx_reference_qualified_functions) || \
        -: 1820:    (defined(_GNUC_VER) && _GNUC_VER >= 409)
        -: 1821:
        -: 1822:template <class _Rp, class _Class, class ..._Param>
        -: 1823:struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) &, true, false>
        -: 1824:{
        -: 1825:    typedef _Class& _ClassType;
        -: 1826:    typedef _Rp _ReturnType;
        -: 1827:    typedef _Rp (_FnType) (_Param...);
        -: 1828:};
        -: 1829:
        -: 1830:template <class _Rp, class _Class, class ..._Param>
        -: 1831:struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) &, true, false>
        -: 1832:{
        -: 1833:    typedef _Class& _ClassType;
        -: 1834:    typedef _Rp _ReturnType;
        -: 1835:    typedef _Rp (_FnType) (_Param..., ...);
        -: 1836:};
        -: 1837:
        -: 1838:template <class _Rp, class _Class, class ..._Param>
        -: 1839:struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const&, true, false>
        -: 1840:{
        -: 1841:    typedef _Class const& _ClassType;
        -: 1842:    typedef _Rp _ReturnType;
        -: 1843:    typedef _Rp (_FnType) (_Param...);
        -: 1844:};
        -: 1845:
        -: 1846:template <class _Rp, class _Class, class ..._Param>
        -: 1847:struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const&, true, false>
        -: 1848:{
        -: 1849:    typedef _Class const& _ClassType;
        -: 1850:    typedef _Rp _ReturnType;
        -: 1851:    typedef _Rp (_FnType) (_Param..., ...);
        -: 1852:};
        -: 1853:
        -: 1854:template <class _Rp, class _Class, class ..._Param>
        -: 1855:struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) volatile&, true, false>
        -: 1856:{
        -: 1857:    typedef _Class volatile& _ClassType;
        -: 1858:    typedef _Rp _ReturnType;
        -: 1859:    typedef _Rp (_FnType) (_Param...);
        -: 1860:};
        -: 1861:
        -: 1862:template <class _Rp, class _Class, class ..._Param>
        -: 1863:struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) volatile&, true, false>
        -: 1864:{
        -: 1865:    typedef _Class volatile& _ClassType;
        -: 1866:    typedef _Rp _ReturnType;
        -: 1867:    typedef _Rp (_FnType) (_Param..., ...);
        -: 1868:};
        -: 1869:
        -: 1870:template <class _Rp, class _Class, class ..._Param>
        -: 1871:struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const volatile&, true, false>
        -: 1872:{
        -: 1873:    typedef _Class const volatile& _ClassType;
        -: 1874:    typedef _Rp _ReturnType;
        -: 1875:    typedef _Rp (_FnType) (_Param...);
        -: 1876:};
        -: 1877:
        -: 1878:template <class _Rp, class _Class, class ..._Param>
        -: 1879:struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const volatile&, true, false>
        -: 1880:{
        -: 1881:    typedef _Class const volatile& _ClassType;
        -: 1882:    typedef _Rp _ReturnType;
        -: 1883:    typedef _Rp (_FnType) (_Param..., ...);
        -: 1884:};
        -: 1885:
        -: 1886:template <class _Rp, class _Class, class ..._Param>
        -: 1887:struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) &&, true, false>
        -: 1888:{
        -: 1889:    typedef _Class&& _ClassType;
        -: 1890:    typedef _Rp _ReturnType;
        -: 1891:    typedef _Rp (_FnType) (_Param...);
        -: 1892:};
        -: 1893:
        -: 1894:template <class _Rp, class _Class, class ..._Param>
        -: 1895:struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) &&, true, false>
        -: 1896:{
        -: 1897:    typedef _Class&& _ClassType;
        -: 1898:    typedef _Rp _ReturnType;
        -: 1899:    typedef _Rp (_FnType) (_Param..., ...);
        -: 1900:};
        -: 1901:
        -: 1902:template <class _Rp, class _Class, class ..._Param>
        -: 1903:struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const&&, true, false>
        -: 1904:{
        -: 1905:    typedef _Class const&& _ClassType;
        -: 1906:    typedef _Rp _ReturnType;
        -: 1907:    typedef _Rp (_FnType) (_Param...);
        -: 1908:};
        -: 1909:
        -: 1910:template <class _Rp, class _Class, class ..._Param>
        -: 1911:struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const&&, true, false>
        -: 1912:{
        -: 1913:    typedef _Class const&& _ClassType;
        -: 1914:    typedef _Rp _ReturnType;
        -: 1915:    typedef _Rp (_FnType) (_Param..., ...);
        -: 1916:};
        -: 1917:
        -: 1918:template <class _Rp, class _Class, class ..._Param>
        -: 1919:struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) volatile&&, true, false>
        -: 1920:{
        -: 1921:    typedef _Class volatile&& _ClassType;
        -: 1922:    typedef _Rp _ReturnType;
        -: 1923:    typedef _Rp (_FnType) (_Param...);
        -: 1924:};
        -: 1925:
        -: 1926:template <class _Rp, class _Class, class ..._Param>
        -: 1927:struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) volatile&&, true, false>
        -: 1928:{
        -: 1929:    typedef _Class volatile&& _ClassType;
        -: 1930:    typedef _Rp _ReturnType;
        -: 1931:    typedef _Rp (_FnType) (_Param..., ...);
        -: 1932:};
        -: 1933:
        -: 1934:template <class _Rp, class _Class, class ..._Param>
        -: 1935:struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const volatile&&, true, false>
        -: 1936:{
        -: 1937:    typedef _Class const volatile&& _ClassType;
        -: 1938:    typedef _Rp _ReturnType;
        -: 1939:    typedef _Rp (_FnType) (_Param...);
        -: 1940:};
        -: 1941:
        -: 1942:template <class _Rp, class _Class, class ..._Param>
        -: 1943:struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const volatile&&, true, false>
        -: 1944:{
        -: 1945:    typedef _Class const volatile&& _ClassType;
        -: 1946:    typedef _Rp _ReturnType;
        -: 1947:    typedef _Rp (_FnType) (_Param..., ...);
        -: 1948:};
        -: 1949:
        -: 1950:#endif  // __has_feature(cxx_reference_qualified_functions) || _GNUC_VER >= 409
        -: 1951:
        -: 1952:#else  // _LIBCPP_HAS_NO_VARIADICS
        -: 1953:
        -: 1954:template <class _Rp, class _Class>
        -: 1955:struct __member_pointer_traits_imp<_Rp (_Class::*)(), true, false>
        -: 1956:{
        -: 1957:    typedef _Class _ClassType;
        -: 1958:    typedef _Rp _ReturnType;
        -: 1959:    typedef _Rp (_FnType) ();
        -: 1960:};
        -: 1961:
        -: 1962:template <class _Rp, class _Class>
        -: 1963:struct __member_pointer_traits_imp<_Rp (_Class::*)(...), true, false>
        -: 1964:{
        -: 1965:    typedef _Class _ClassType;
        -: 1966:    typedef _Rp _ReturnType;
        -: 1967:    typedef _Rp (_FnType) (...);
        -: 1968:};
        -: 1969:
        -: 1970:template <class _Rp, class _Class, class _P0>
        -: 1971:struct __member_pointer_traits_imp<_Rp (_Class::*)(_P0), true, false>
        -: 1972:{
        -: 1973:    typedef _Class _ClassType;
        -: 1974:    typedef _Rp _ReturnType;
        -: 1975:    typedef _Rp (_FnType) (_P0);
        -: 1976:};
        -: 1977:
        -: 1978:template <class _Rp, class _Class, class _P0>
        -: 1979:struct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, ...), true, false>
        -: 1980:{
        -: 1981:    typedef _Class _ClassType;
        -: 1982:    typedef _Rp _ReturnType;
        -: 1983:    typedef _Rp (_FnType) (_P0, ...);
        -: 1984:};
        -: 1985:
        -: 1986:template <class _Rp, class _Class, class _P0, class _P1>
        -: 1987:struct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1), true, false>
        -: 1988:{
        -: 1989:    typedef _Class _ClassType;
        -: 1990:    typedef _Rp _ReturnType;
        -: 1991:    typedef _Rp (_FnType) (_P0, _P1);
        -: 1992:};
        -: 1993:
        -: 1994:template <class _Rp, class _Class, class _P0, class _P1>
        -: 1995:struct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, ...), true, false>
        -: 1996:{
        -: 1997:    typedef _Class _ClassType;
        -: 1998:    typedef _Rp _ReturnType;
        -: 1999:    typedef _Rp (_FnType) (_P0, _P1, ...);
        -: 2000:};
        -: 2001:
        -: 2002:template <class _Rp, class _Class, class _P0, class _P1, class _P2>
        -: 2003:struct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2), true, false>
        -: 2004:{
        -: 2005:    typedef _Class _ClassType;
        -: 2006:    typedef _Rp _ReturnType;
        -: 2007:    typedef _Rp (_FnType) (_P0, _P1, _P2);
        -: 2008:};
        -: 2009:
        -: 2010:template <class _Rp, class _Class, class _P0, class _P1, class _P2>
        -: 2011:struct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2, ...), true, false>
        -: 2012:{
        -: 2013:    typedef _Class _ClassType;
        -: 2014:    typedef _Rp _ReturnType;
        -: 2015:    typedef _Rp (_FnType) (_P0, _P1, _P2, ...);
        -: 2016:};
        -: 2017:
        -: 2018:template <class _Rp, class _Class>
        -: 2019:struct __member_pointer_traits_imp<_Rp (_Class::*)() const, true, false>
        -: 2020:{
        -: 2021:    typedef _Class const _ClassType;
        -: 2022:    typedef _Rp _ReturnType;
        -: 2023:    typedef _Rp (_FnType) ();
        -: 2024:};
        -: 2025:
        -: 2026:template <class _Rp, class _Class>
        -: 2027:struct __member_pointer_traits_imp<_Rp (_Class::*)(...) const, true, false>
        -: 2028:{
        -: 2029:    typedef _Class const _ClassType;
        -: 2030:    typedef _Rp _ReturnType;
        -: 2031:    typedef _Rp (_FnType) (...);
        -: 2032:};
        -: 2033:
        -: 2034:template <class _Rp, class _Class, class _P0>
        -: 2035:struct __member_pointer_traits_imp<_Rp (_Class::*)(_P0) const, true, false>
        -: 2036:{
        -: 2037:    typedef _Class const _ClassType;
        -: 2038:    typedef _Rp _ReturnType;
        -: 2039:    typedef _Rp (_FnType) (_P0);
        -: 2040:};
        -: 2041:
        -: 2042:template <class _Rp, class _Class, class _P0>
        -: 2043:struct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, ...) const, true, false>
        -: 2044:{
        -: 2045:    typedef _Class const _ClassType;
        -: 2046:    typedef _Rp _ReturnType;
        -: 2047:    typedef _Rp (_FnType) (_P0, ...);
        -: 2048:};
        -: 2049:
        -: 2050:template <class _Rp, class _Class, class _P0, class _P1>
        -: 2051:struct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1) const, true, false>
        -: 2052:{
        -: 2053:    typedef _Class const _ClassType;
        -: 2054:    typedef _Rp _ReturnType;
        -: 2055:    typedef _Rp (_FnType) (_P0, _P1);
        -: 2056:};
        -: 2057:
        -: 2058:template <class _Rp, class _Class, class _P0, class _P1>
        -: 2059:struct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, ...) const, true, false>
        -: 2060:{
        -: 2061:    typedef _Class const _ClassType;
        -: 2062:    typedef _Rp _ReturnType;
        -: 2063:    typedef _Rp (_FnType) (_P0, _P1, ...);
        -: 2064:};
        -: 2065:
        -: 2066:template <class _Rp, class _Class, class _P0, class _P1, class _P2>
        -: 2067:struct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2) const, true, false>
        -: 2068:{
        -: 2069:    typedef _Class const _ClassType;
        -: 2070:    typedef _Rp _ReturnType;
        -: 2071:    typedef _Rp (_FnType) (_P0, _P1, _P2);
        -: 2072:};
        -: 2073:
        -: 2074:template <class _Rp, class _Class, class _P0, class _P1, class _P2>
        -: 2075:struct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2, ...) const, true, false>
        -: 2076:{
        -: 2077:    typedef _Class const _ClassType;
        -: 2078:    typedef _Rp _ReturnType;
        -: 2079:    typedef _Rp (_FnType) (_P0, _P1, _P2, ...);
        -: 2080:};
        -: 2081:
        -: 2082:template <class _Rp, class _Class>
        -: 2083:struct __member_pointer_traits_imp<_Rp (_Class::*)() volatile, true, false>
        -: 2084:{
        -: 2085:    typedef _Class volatile _ClassType;
        -: 2086:    typedef _Rp _ReturnType;
        -: 2087:    typedef _Rp (_FnType) ();
        -: 2088:};
        -: 2089:
        -: 2090:template <class _Rp, class _Class>
        -: 2091:struct __member_pointer_traits_imp<_Rp (_Class::*)(...) volatile, true, false>
        -: 2092:{
        -: 2093:    typedef _Class volatile _ClassType;
        -: 2094:    typedef _Rp _ReturnType;
        -: 2095:    typedef _Rp (_FnType) (...);
        -: 2096:};
        -: 2097:
        -: 2098:template <class _Rp, class _Class, class _P0>
        -: 2099:struct __member_pointer_traits_imp<_Rp (_Class::*)(_P0) volatile, true, false>
        -: 2100:{
        -: 2101:    typedef _Class volatile _ClassType;
        -: 2102:    typedef _Rp _ReturnType;
        -: 2103:    typedef _Rp (_FnType) (_P0);
        -: 2104:};
        -: 2105:
        -: 2106:template <class _Rp, class _Class, class _P0>
        -: 2107:struct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, ...) volatile, true, false>
        -: 2108:{
        -: 2109:    typedef _Class volatile _ClassType;
        -: 2110:    typedef _Rp _ReturnType;
        -: 2111:    typedef _Rp (_FnType) (_P0, ...);
        -: 2112:};
        -: 2113:
        -: 2114:template <class _Rp, class _Class, class _P0, class _P1>
        -: 2115:struct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1) volatile, true, false>
        -: 2116:{
        -: 2117:    typedef _Class volatile _ClassType;
        -: 2118:    typedef _Rp _ReturnType;
        -: 2119:    typedef _Rp (_FnType) (_P0, _P1);
        -: 2120:};
        -: 2121:
        -: 2122:template <class _Rp, class _Class, class _P0, class _P1>
        -: 2123:struct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, ...) volatile, true, false>
        -: 2124:{
        -: 2125:    typedef _Class volatile _ClassType;
        -: 2126:    typedef _Rp _ReturnType;
        -: 2127:    typedef _Rp (_FnType) (_P0, _P1, ...);
        -: 2128:};
        -: 2129:
        -: 2130:template <class _Rp, class _Class, class _P0, class _P1, class _P2>
        -: 2131:struct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2) volatile, true, false>
        -: 2132:{
        -: 2133:    typedef _Class volatile _ClassType;
        -: 2134:    typedef _Rp _ReturnType;
        -: 2135:    typedef _Rp (_FnType) (_P0, _P1, _P2);
        -: 2136:};
        -: 2137:
        -: 2138:template <class _Rp, class _Class, class _P0, class _P1, class _P2>
        -: 2139:struct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2, ...) volatile, true, false>
        -: 2140:{
        -: 2141:    typedef _Class volatile _ClassType;
        -: 2142:    typedef _Rp _ReturnType;
        -: 2143:    typedef _Rp (_FnType) (_P0, _P1, _P2, ...);
        -: 2144:};
        -: 2145:
        -: 2146:template <class _Rp, class _Class>
        -: 2147:struct __member_pointer_traits_imp<_Rp (_Class::*)() const volatile, true, false>
        -: 2148:{
        -: 2149:    typedef _Class const volatile _ClassType;
        -: 2150:    typedef _Rp _ReturnType;
        -: 2151:    typedef _Rp (_FnType) ();
        -: 2152:};
        -: 2153:
        -: 2154:template <class _Rp, class _Class>
        -: 2155:struct __member_pointer_traits_imp<_Rp (_Class::*)(...) const volatile, true, false>
        -: 2156:{
        -: 2157:    typedef _Class const volatile _ClassType;
        -: 2158:    typedef _Rp _ReturnType;
        -: 2159:    typedef _Rp (_FnType) (...);
        -: 2160:};
        -: 2161:
        -: 2162:template <class _Rp, class _Class, class _P0>
        -: 2163:struct __member_pointer_traits_imp<_Rp (_Class::*)(_P0) const volatile, true, false>
        -: 2164:{
        -: 2165:    typedef _Class const volatile _ClassType;
        -: 2166:    typedef _Rp _ReturnType;
        -: 2167:    typedef _Rp (_FnType) (_P0);
        -: 2168:};
        -: 2169:
        -: 2170:template <class _Rp, class _Class, class _P0>
        -: 2171:struct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, ...) const volatile, true, false>
        -: 2172:{
        -: 2173:    typedef _Class const volatile _ClassType;
        -: 2174:    typedef _Rp _ReturnType;
        -: 2175:    typedef _Rp (_FnType) (_P0, ...);
        -: 2176:};
        -: 2177:
        -: 2178:template <class _Rp, class _Class, class _P0, class _P1>
        -: 2179:struct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1) const volatile, true, false>
        -: 2180:{
        -: 2181:    typedef _Class const volatile _ClassType;
        -: 2182:    typedef _Rp _ReturnType;
        -: 2183:    typedef _Rp (_FnType) (_P0, _P1);
        -: 2184:};
        -: 2185:
        -: 2186:template <class _Rp, class _Class, class _P0, class _P1>
        -: 2187:struct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, ...) const volatile, true, false>
        -: 2188:{
        -: 2189:    typedef _Class const volatile _ClassType;
        -: 2190:    typedef _Rp _ReturnType;
        -: 2191:    typedef _Rp (_FnType) (_P0, _P1, ...);
        -: 2192:};
        -: 2193:
        -: 2194:template <class _Rp, class _Class, class _P0, class _P1, class _P2>
        -: 2195:struct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2) const volatile, true, false>
        -: 2196:{
        -: 2197:    typedef _Class const volatile _ClassType;
        -: 2198:    typedef _Rp _ReturnType;
        -: 2199:    typedef _Rp (_FnType) (_P0, _P1, _P2);
        -: 2200:};
        -: 2201:
        -: 2202:template <class _Rp, class _Class, class _P0, class _P1, class _P2>
        -: 2203:struct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2, ...) const volatile, true, false>
        -: 2204:{
        -: 2205:    typedef _Class const volatile _ClassType;
        -: 2206:    typedef _Rp _ReturnType;
        -: 2207:    typedef _Rp (_FnType) (_P0, _P1, _P2, ...);
        -: 2208:};
        -: 2209:
        -: 2210:#endif  // _LIBCPP_HAS_NO_VARIADICS
        -: 2211:
        -: 2212:template <class _Rp, class _Class>
        -: 2213:struct __member_pointer_traits_imp<_Rp _Class::*, false, true>
        -: 2214:{
        -: 2215:    typedef _Class _ClassType;
        -: 2216:    typedef _Rp _ReturnType;
        -: 2217:};
        -: 2218:
        -: 2219:template <class _MP>
        -: 2220:struct __member_pointer_traits
        -: 2221:    : public __member_pointer_traits_imp<typename remove_cv<_MP>::type,
        -: 2222:                    is_member_function_pointer<_MP>::value,
        -: 2223:                    is_member_object_pointer<_MP>::value>
        -: 2224:{
        -: 2225://     typedef ... _ClassType;
        -: 2226://     typedef ... _ReturnType;
        -: 2227://     typedef ... _FnType;
        -: 2228:};
        -: 2229:
        -: 2230:// result_of
        -: 2231:
        -: 2232:template <class _Callable> class result_of;
        -: 2233:
        -: 2234:#ifdef _LIBCPP_HAS_NO_VARIADICS
        -: 2235:
        -: 2236:template <class _Fn, bool, bool>
        -: 2237:class __result_of
        -: 2238:{
        -: 2239:};
        -: 2240:
        -: 2241:template <class _Fn>
        -: 2242:class __result_of<_Fn(), true, false>
        -: 2243:{
        -: 2244:public:
        -: 2245:    typedef decltype(declval<_Fn>()()) type;
        -: 2246:};
        -: 2247:
        -: 2248:template <class _Fn, class _A0>
        -: 2249:class __result_of<_Fn(_A0), true, false>
        -: 2250:{
        -: 2251:public:
        -: 2252:    typedef decltype(declval<_Fn>()(declval<_A0>())) type;
        -: 2253:};
        -: 2254:
        -: 2255:template <class _Fn, class _A0, class _A1>
        -: 2256:class __result_of<_Fn(_A0, _A1), true, false>
        -: 2257:{
        -: 2258:public:
        -: 2259:    typedef decltype(declval<_Fn>()(declval<_A0>(), declval<_A1>())) type;
        -: 2260:};
        -: 2261:
        -: 2262:template <class _Fn, class _A0, class _A1, class _A2>
        -: 2263:class __result_of<_Fn(_A0, _A1, _A2), true, false>
        -: 2264:{
        -: 2265:public:
        -: 2266:    typedef decltype(declval<_Fn>()(declval<_A0>(), declval<_A1>(), declval<_A2>())) type;
        -: 2267:};
        -: 2268:
        -: 2269:template <class _MP, class _Tp, bool _IsMemberFunctionPtr>
        -: 2270:struct __result_of_mp;
        -: 2271:
        -: 2272:// member function pointer
        -: 2273:
        -: 2274:template <class _MP, class _Tp>
        -: 2275:struct __result_of_mp<_MP, _Tp, true>
        -: 2276:    : public __identity<typename __member_pointer_traits<_MP>::_ReturnType>
        -: 2277:{
        -: 2278:};
        -: 2279:
        -: 2280:// member data pointer
        -: 2281:
        -: 2282:template <class _MP, class _Tp, bool>
        -: 2283:struct __result_of_mdp;
        -: 2284:
        -: 2285:template <class _Rp, class _Class, class _Tp>
        -: 2286:struct __result_of_mdp<_Rp _Class::*, _Tp, false>
        -: 2287:{
        -: 2288:    typedef typename __apply_cv<decltype(*_VSTD::declval<_Tp>()), _Rp>::type& type;
        -: 2289:};
        -: 2290:
        -: 2291:template <class _Rp, class _Class, class _Tp>
        -: 2292:struct __result_of_mdp<_Rp _Class::*, _Tp, true>
        -: 2293:{
        -: 2294:    typedef typename __apply_cv<_Tp, _Rp>::type& type;
        -: 2295:};
        -: 2296:
        -: 2297:template <class _Rp, class _Class, class _Tp>
        -: 2298:struct __result_of_mp<_Rp _Class::*, _Tp, false>
        -: 2299:    : public __result_of_mdp<_Rp _Class::*, _Tp,
        -: 2300:            is_base_of<_Class, typename remove_reference<_Tp>::type>::value>
        -: 2301:{
        -: 2302:};
        -: 2303:
        -: 2304:
        -: 2305:
        -: 2306:template <class _Fn, class _Tp>
        -: 2307:class __result_of<_Fn(_Tp), false, true>  // _Fn must be member pointer
        -: 2308:    : public __result_of_mp<typename remove_reference<_Fn>::type,
        -: 2309:                            _Tp,
        -: 2310:                            is_member_function_pointer<typename remove_reference<_Fn>::type>::value>
        -: 2311:{
        -: 2312:};
        -: 2313:
        -: 2314:template <class _Fn, class _Tp, class _A0>
        -: 2315:class __result_of<_Fn(_Tp, _A0), false, true>  // _Fn must be member pointer
        -: 2316:    : public __result_of_mp<typename remove_reference<_Fn>::type,
        -: 2317:                            _Tp,
        -: 2318:                            is_member_function_pointer<typename remove_reference<_Fn>::type>::value>
        -: 2319:{
        -: 2320:};
        -: 2321:
        -: 2322:template <class _Fn, class _Tp, class _A0, class _A1>
        -: 2323:class __result_of<_Fn(_Tp, _A0, _A1), false, true>  // _Fn must be member pointer
        -: 2324:    : public __result_of_mp<typename remove_reference<_Fn>::type,
        -: 2325:                            _Tp,
        -: 2326:                            is_member_function_pointer<typename remove_reference<_Fn>::type>::value>
        -: 2327:{
        -: 2328:};
        -: 2329:
        -: 2330:template <class _Fn, class _Tp, class _A0, class _A1, class _A2>
        -: 2331:class __result_of<_Fn(_Tp, _A0, _A1, _A2), false, true>  // _Fn must be member pointer
        -: 2332:    : public __result_of_mp<typename remove_reference<_Fn>::type,
        -: 2333:                            _Tp,
        -: 2334:                            is_member_function_pointer<typename remove_reference<_Fn>::type>::value>
        -: 2335:{
        -: 2336:};
        -: 2337:
        -: 2338:// result_of
        -: 2339:
        -: 2340:template <class _Fn>
        -: 2341:class _LIBCPP_TYPE_VIS_ONLY result_of<_Fn()>
        -: 2342:    : public __result_of<_Fn(),
        -: 2343:                         is_class<typename remove_reference<_Fn>::type>::value ||
        -: 2344:                         is_function<typename remove_pointer<typename remove_reference<_Fn>::type>::type>::value,
        -: 2345:                         is_member_pointer<typename remove_reference<_Fn>::type>::value
        -: 2346:                        >
        -: 2347:{
        -: 2348:};
        -: 2349:
        -: 2350:template <class _Fn, class _A0>
        -: 2351:class _LIBCPP_TYPE_VIS_ONLY result_of<_Fn(_A0)>
        -: 2352:    : public __result_of<_Fn(_A0),
        -: 2353:                         is_class<typename remove_reference<_Fn>::type>::value ||
        -: 2354:                         is_function<typename remove_pointer<typename remove_reference<_Fn>::type>::type>::value,
        -: 2355:                         is_member_pointer<typename remove_reference<_Fn>::type>::value
        -: 2356:                        >
        -: 2357:{
        -: 2358:};
        -: 2359:
        -: 2360:template <class _Fn, class _A0, class _A1>
        -: 2361:class _LIBCPP_TYPE_VIS_ONLY result_of<_Fn(_A0, _A1)>
        -: 2362:    : public __result_of<_Fn(_A0, _A1),
        -: 2363:                         is_class<typename remove_reference<_Fn>::type>::value ||
        -: 2364:                         is_function<typename remove_pointer<typename remove_reference<_Fn>::type>::type>::value,
        -: 2365:                         is_member_pointer<typename remove_reference<_Fn>::type>::value
        -: 2366:                        >
        -: 2367:{
        -: 2368:};
        -: 2369:
        -: 2370:template <class _Fn, class _A0, class _A1, class _A2>
        -: 2371:class _LIBCPP_TYPE_VIS_ONLY result_of<_Fn(_A0, _A1, _A2)>
        -: 2372:    : public __result_of<_Fn(_A0, _A1, _A2),
        -: 2373:                         is_class<typename remove_reference<_Fn>::type>::value ||
        -: 2374:                         is_function<typename remove_pointer<typename remove_reference<_Fn>::type>::type>::value,
        -: 2375:                         is_member_pointer<typename remove_reference<_Fn>::type>::value
        -: 2376:                        >
        -: 2377:{
        -: 2378:};
        -: 2379:
        -: 2380:#endif  // _LIBCPP_HAS_NO_VARIADICS
        -: 2381:
        -: 2382:// template <class T, class... Args> struct is_constructible;
        -: 2383:
        -: 2384:namespace __is_construct
        -: 2385:{
        -: 2386:struct __nat {};
        -: 2387:}
        -: 2388:
        -: 2389:#if __has_feature(is_constructible)
        -: 2390:
        -: 2391:template <class _Tp, class ..._Args>
        -: 2392:struct _LIBCPP_TYPE_VIS_ONLY is_constructible
        -: 2393:    : public integral_constant<bool, __is_constructible(_Tp, _Args...)>
        -: 2394:    {};
        -: 2395:
        -: 2396:#else
        -: 2397:
        -: 2398:#ifndef _LIBCPP_HAS_NO_VARIADICS
        -: 2399:
        -: 2400://      main is_constructible test
        -: 2401:
        -: 2402:template <class _Tp, class ..._Args>
        -: 2403:typename __select_2nd<decltype(_VSTD::move(_Tp(_VSTD::declval<_Args>()...))), true_type>::type
        -: 2404:__is_constructible_test(_Tp&&, _Args&& ...);
        -: 2405:
        -: 2406:template <class ..._Args>
        -: 2407:false_type
        -: 2408:__is_constructible_test(__any, _Args&& ...);
        -: 2409:
        -: 2410:template <bool, class _Tp, class... _Args>
        -: 2411:struct __libcpp_is_constructible // false, _Tp is not a scalar
        -: 2412:    : public common_type
        -: 2413:             <
        -: 2414:                 decltype(__is_constructible_test(declval<_Tp>(), declval<_Args>()...))
        -: 2415:             >::type
        -: 2416:    {};
        -: 2417:
        -: 2418://      function types are not constructible
        -: 2419:
        -: 2420:template <class _Rp, class... _A1, class... _A2>
        -: 2421:struct __libcpp_is_constructible<false, _Rp(_A1...), _A2...>
        -: 2422:    : public false_type
        -: 2423:    {};
        -: 2424:
        -: 2425://      handle scalars and reference types
        -: 2426:
        -: 2427://      Scalars are default constructible, references are not
        -: 2428:
        -: 2429:template <class _Tp>
        -: 2430:struct __libcpp_is_constructible<true, _Tp>
        -: 2431:    : public is_scalar<_Tp>
        -: 2432:    {};
        -: 2433:
        -: 2434://      Scalars and references are constructible from one arg if that arg is
        -: 2435://          implicitly convertible to the scalar or reference.
        -: 2436:
        -: 2437:template <class _Tp>
        -: 2438:struct __is_constructible_ref
        -: 2439:{
        -: 2440:    true_type static __lxx(_Tp);
        -: 2441:    false_type static __lxx(...);
        -: 2442:};
        -: 2443:
        -: 2444:template <class _Tp, class _A0>
        -: 2445:struct __libcpp_is_constructible<true, _Tp, _A0>
        -: 2446:    : public common_type
        -: 2447:             <
        -: 2448:                 decltype(__is_constructible_ref<_Tp>::__lxx(declval<_A0>()))
        -: 2449:             >::type
        -: 2450:    {};
        -: 2451:
        -: 2452://      Scalars and references are not constructible from multiple args.
        -: 2453:
        -: 2454:template <class _Tp, class _A0, class ..._Args>
        -: 2455:struct __libcpp_is_constructible<true, _Tp, _A0, _Args...>
        -: 2456:    : public false_type
        -: 2457:    {};
        -: 2458:
        -: 2459://      Treat scalars and reference types separately
        -: 2460:
        -: 2461:template <bool, class _Tp, class... _Args>
        -: 2462:struct __is_constructible_void_check
        -: 2463:    : public __libcpp_is_constructible<is_scalar<_Tp>::value || is_reference<_Tp>::value,
        -: 2464:                                _Tp, _Args...>
        -: 2465:    {};
        -: 2466:
        -: 2467://      If any of T or Args is void, is_constructible should be false
        -: 2468:
        -: 2469:template <class _Tp, class... _Args>
        -: 2470:struct __is_constructible_void_check<true, _Tp, _Args...>
        -: 2471:    : public false_type
        -: 2472:    {};
        -: 2473:
        -: 2474:template <class ..._Args> struct __contains_void;
        -: 2475:
        -: 2476:template <> struct __contains_void<> : false_type {};
        -: 2477:
        -: 2478:template <class _A0, class ..._Args>
        -: 2479:struct __contains_void<_A0, _Args...>
        -: 2480:{
        -: 2481:    static const bool value = is_void<_A0>::value ||
        -: 2482:                              __contains_void<_Args...>::value;
        -: 2483:};
        -: 2484:
        -: 2485://      is_constructible entry point
        -: 2486:
        -: 2487:template <class _Tp, class... _Args>
        -: 2488:struct _LIBCPP_TYPE_VIS_ONLY is_constructible
        -: 2489:    : public __is_constructible_void_check<__contains_void<_Tp, _Args...>::value
        -: 2490:                                        || is_abstract<_Tp>::value,
        -: 2491:                                           _Tp, _Args...>
        -: 2492:    {};
        -: 2493:
        -: 2494://      Array types are default constructible if their element type
        -: 2495://      is default constructible
        -: 2496:
        -: 2497:template <class _Ap, size_t _Np>
        -: 2498:struct __libcpp_is_constructible<false, _Ap[_Np]>
        -: 2499:    : public is_constructible<typename remove_all_extents<_Ap>::type>
        -: 2500:    {};
        -: 2501:
        -: 2502://      Otherwise array types are not constructible by this syntax
        -: 2503:
        -: 2504:template <class _Ap, size_t _Np, class ..._Args>
        -: 2505:struct __libcpp_is_constructible<false, _Ap[_Np], _Args...>
        -: 2506:    : public false_type
        -: 2507:    {};
        -: 2508:
        -: 2509://      Incomplete array types are not constructible
        -: 2510:
        -: 2511:template <class _Ap, class ..._Args>
        -: 2512:struct __libcpp_is_constructible<false, _Ap[], _Args...>
        -: 2513:    : public false_type
        -: 2514:    {};
        -: 2515:
        -: 2516:#else  // _LIBCPP_HAS_NO_VARIADICS
        -: 2517:
        -: 2518:// template <class T> struct is_constructible0;
        -: 2519:
        -: 2520://      main is_constructible0 test
        -: 2521:
        -: 2522:template <class _Tp>
        -: 2523:decltype((_Tp(), true_type()))
        -: 2524:__is_constructible0_test(_Tp&);
        -: 2525:
        -: 2526:false_type
        -: 2527:__is_constructible0_test(__any);
        -: 2528:
        -: 2529:template <class _Tp, class _A0>
        -: 2530:decltype((_Tp(_VSTD::declval<_A0>()), true_type()))
        -: 2531:__is_constructible1_test(_Tp&, _A0&);
        -: 2532:
        -: 2533:template <class _A0>
        -: 2534:false_type
        -: 2535:__is_constructible1_test(__any, _A0&);
        -: 2536:
        -: 2537:template <class _Tp, class _A0, class _A1>
        -: 2538:decltype((_Tp(_VSTD::declval<_A0>(), _VSTD::declval<_A1>()), true_type()))
        -: 2539:__is_constructible2_test(_Tp&, _A0&, _A1&);
        -: 2540:
        -: 2541:template <class _A0, class _A1>
        -: 2542:false_type
        -: 2543:__is_constructible2_test(__any, _A0&, _A1&);
        -: 2544:
        -: 2545:template <bool, class _Tp>
        -: 2546:struct __is_constructible0_imp // false, _Tp is not a scalar
        -: 2547:    : public common_type
        -: 2548:             <
        -: 2549:                 decltype(__is_constructible0_test(declval<_Tp&>()))
        -: 2550:             >::type
        -: 2551:    {};
        -: 2552:
        -: 2553:template <bool, class _Tp, class _A0>
        -: 2554:struct __is_constructible1_imp // false, _Tp is not a scalar
        -: 2555:    : public common_type
        -: 2556:             <
        -: 2557:                 decltype(__is_constructible1_test(declval<_Tp&>(), declval<_A0&>()))
        -: 2558:             >::type
        -: 2559:    {};
        -: 2560:
        -: 2561:template <bool, class _Tp, class _A0, class _A1>
        -: 2562:struct __is_constructible2_imp // false, _Tp is not a scalar
        -: 2563:    : public common_type
        -: 2564:             <
        -: 2565:                 decltype(__is_constructible2_test(declval<_Tp&>(), declval<_A0>(), declval<_A1>()))
        -: 2566:             >::type
        -: 2567:    {};
        -: 2568:
        -: 2569://      handle scalars and reference types
        -: 2570:
        -: 2571://      Scalars are default constructible, references are not
        -: 2572:
        -: 2573:template <class _Tp>
        -: 2574:struct __is_constructible0_imp<true, _Tp>
        -: 2575:    : public is_scalar<_Tp>
        -: 2576:    {};
        -: 2577:
        -: 2578:template <class _Tp, class _A0>
        -: 2579:struct __is_constructible1_imp<true, _Tp, _A0>
        -: 2580:    : public is_convertible<_A0, _Tp>
        -: 2581:    {};
        -: 2582:
        -: 2583:template <class _Tp, class _A0, class _A1>
        -: 2584:struct __is_constructible2_imp<true, _Tp, _A0, _A1>
        -: 2585:    : public false_type
        -: 2586:    {};
        -: 2587:
        -: 2588://      Treat scalars and reference types separately
        -: 2589:
        -: 2590:template <bool, class _Tp>
        -: 2591:struct __is_constructible0_void_check
        -: 2592:    : public __is_constructible0_imp<is_scalar<_Tp>::value || is_reference<_Tp>::value,
        -: 2593:                                _Tp>
        -: 2594:    {};
        -: 2595:
        -: 2596:template <bool, class _Tp, class _A0>
        -: 2597:struct __is_constructible1_void_check
        -: 2598:    : public __is_constructible1_imp<is_scalar<_Tp>::value || is_reference<_Tp>::value,
        -: 2599:                                _Tp, _A0>
        -: 2600:    {};
        -: 2601:
        -: 2602:template <bool, class _Tp, class _A0, class _A1>
        -: 2603:struct __is_constructible2_void_check
        -: 2604:    : public __is_constructible2_imp<is_scalar<_Tp>::value || is_reference<_Tp>::value,
        -: 2605:                                _Tp, _A0, _A1>
        -: 2606:    {};
        -: 2607:
        -: 2608://      If any of T or Args is void, is_constructible should be false
        -: 2609:
        -: 2610:template <class _Tp>
        -: 2611:struct __is_constructible0_void_check<true, _Tp>
        -: 2612:    : public false_type
        -: 2613:    {};
        -: 2614:
        -: 2615:template <class _Tp, class _A0>
        -: 2616:struct __is_constructible1_void_check<true, _Tp, _A0>
        -: 2617:    : public false_type
        -: 2618:    {};
        -: 2619:
        -: 2620:template <class _Tp, class _A0, class _A1>
        -: 2621:struct __is_constructible2_void_check<true, _Tp, _A0, _A1>
        -: 2622:    : public false_type
        -: 2623:    {};
        -: 2624:
        -: 2625://      is_constructible entry point
        -: 2626:
        -: 2627:template <class _Tp, class _A0 = __is_construct::__nat,
        -: 2628:                     class _A1 = __is_construct::__nat>
        -: 2629:struct _LIBCPP_TYPE_VIS_ONLY is_constructible
        -: 2630:    : public __is_constructible2_void_check<is_void<_Tp>::value
        -: 2631:                                        || is_abstract<_Tp>::value
        -: 2632:                                        || is_function<_Tp>::value
        -: 2633:                                        || is_void<_A0>::value
        -: 2634:                                        || is_void<_A1>::value,
        -: 2635:                                           _Tp, _A0, _A1>
        -: 2636:    {};
        -: 2637:
        -: 2638:template <class _Tp>
        -: 2639:struct _LIBCPP_TYPE_VIS_ONLY is_constructible<_Tp, __is_construct::__nat, __is_construct::__nat>
        -: 2640:    : public __is_constructible0_void_check<is_void<_Tp>::value
        -: 2641:                                        || is_abstract<_Tp>::value
        -: 2642:                                        || is_function<_Tp>::value,
        -: 2643:                                           _Tp>
        -: 2644:    {};
        -: 2645:
        -: 2646:template <class _Tp, class _A0>
        -: 2647:struct _LIBCPP_TYPE_VIS_ONLY is_constructible<_Tp, _A0, __is_construct::__nat>
        -: 2648:    : public __is_constructible1_void_check<is_void<_Tp>::value
        -: 2649:                                        || is_abstract<_Tp>::value
        -: 2650:                                        || is_function<_Tp>::value
        -: 2651:                                        || is_void<_A0>::value,
        -: 2652:                                           _Tp, _A0>
        -: 2653:    {};
        -: 2654:
        -: 2655://      Array types are default constructible if their element type
        -: 2656://      is default constructible
        -: 2657:
        -: 2658:template <class _Ap, size_t _Np>
        -: 2659:struct __is_constructible0_imp<false, _Ap[_Np]>
        -: 2660:    : public is_constructible<typename remove_all_extents<_Ap>::type>
        -: 2661:    {};
        -: 2662:
        -: 2663:template <class _Ap, size_t _Np, class _A0>
        -: 2664:struct __is_constructible1_imp<false, _Ap[_Np], _A0>
        -: 2665:    : public false_type
        -: 2666:    {};
        -: 2667:
        -: 2668:template <class _Ap, size_t _Np, class _A0, class _A1>
        -: 2669:struct __is_constructible2_imp<false, _Ap[_Np], _A0, _A1>
        -: 2670:    : public false_type
        -: 2671:    {};
        -: 2672:
        -: 2673://      Incomplete array types are not constructible
        -: 2674:
        -: 2675:template <class _Ap>
        -: 2676:struct __is_constructible0_imp<false, _Ap[]>
        -: 2677:    : public false_type
        -: 2678:    {};
        -: 2679:
        -: 2680:template <class _Ap, class _A0>
        -: 2681:struct __is_constructible1_imp<false, _Ap[], _A0>
        -: 2682:    : public false_type
        -: 2683:    {};
        -: 2684:
        -: 2685:template <class _Ap, class _A0, class _A1>
        -: 2686:struct __is_constructible2_imp<false, _Ap[], _A0, _A1>
        -: 2687:    : public false_type
        -: 2688:    {};
        -: 2689:
        -: 2690:#endif  // _LIBCPP_HAS_NO_VARIADICS
        -: 2691:#endif  // __has_feature(is_constructible)
        -: 2692:
        -: 2693:// is_default_constructible
        -: 2694:
        -: 2695:template <class _Tp>
        -: 2696:struct _LIBCPP_TYPE_VIS_ONLY is_default_constructible
        -: 2697:    : public is_constructible<_Tp>
        -: 2698:    {};
        -: 2699:
        -: 2700:// is_copy_constructible
        -: 2701:
        -: 2702:template <class _Tp>
        -: 2703:struct _LIBCPP_TYPE_VIS_ONLY is_copy_constructible
        -: 2704:    : public is_constructible<_Tp, 
        -: 2705:                  typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {};
        -: 2706:
        -: 2707:// is_move_constructible
        -: 2708:
        -: 2709:template <class _Tp>
        -: 2710:struct _LIBCPP_TYPE_VIS_ONLY is_move_constructible
        -: 2711:#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -: 2712:    : public is_constructible<_Tp, typename add_rvalue_reference<_Tp>::type>
        -: 2713:#else
        -: 2714:    : public is_copy_constructible<_Tp>
        -: 2715:#endif
        -: 2716:    {};
        -: 2717:
        -: 2718:// is_trivially_constructible
        -: 2719:
        -: 2720:#ifndef _LIBCPP_HAS_NO_VARIADICS
        -: 2721:
        -: 2722:#if __has_feature(is_trivially_constructible) || _GNUC_VER >= 501
        -: 2723:
        -: 2724:template <class _Tp, class... _Args>
        -: 2725:struct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible
        -: 2726:    : integral_constant<bool, __is_trivially_constructible(_Tp, _Args...)>
        -: 2727:{
        -: 2728:};
        -: 2729:
        -: 2730:#else  // !__has_feature(is_trivially_constructible)
        -: 2731:
        -: 2732:template <class _Tp, class... _Args>
        -: 2733:struct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible
        -: 2734:    : false_type
        -: 2735:{
        -: 2736:};
        -: 2737:
        -: 2738:template <class _Tp>
        -: 2739:struct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible<_Tp>
        -: 2740:#if __has_feature(has_trivial_constructor) || (_GNUC_VER >= 403)
        -: 2741:    : integral_constant<bool, __has_trivial_constructor(_Tp)>
        -: 2742:#else
        -: 2743:    : integral_constant<bool, is_scalar<_Tp>::value>
        -: 2744:#endif
        -: 2745:{
        -: 2746:};
        -: 2747:
        -: 2748:template <class _Tp>
        -: 2749:#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -: 2750:struct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible<_Tp, _Tp&&>
        -: 2751:#else
        -: 2752:struct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible<_Tp, _Tp>
        -: 2753:#endif
        -: 2754:    : integral_constant<bool, is_scalar<_Tp>::value>
        -: 2755:{
        -: 2756:};
        -: 2757:
        -: 2758:template <class _Tp>
        -: 2759:struct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible<_Tp, const _Tp&>
        -: 2760:    : integral_constant<bool, is_scalar<_Tp>::value>
        -: 2761:{
        -: 2762:};
        -: 2763:
        -: 2764:template <class _Tp>
        -: 2765:struct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible<_Tp, _Tp&>
        -: 2766:    : integral_constant<bool, is_scalar<_Tp>::value>
        -: 2767:{
        -: 2768:};
        -: 2769:
        -: 2770:#endif  // !__has_feature(is_trivially_constructible)
        -: 2771:
        -: 2772:#else  // _LIBCPP_HAS_NO_VARIADICS
        -: 2773:
        -: 2774:template <class _Tp, class _A0 = __is_construct::__nat,
        -: 2775:                     class _A1 = __is_construct::__nat>
        -: 2776:struct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible
        -: 2777:    : false_type
        -: 2778:{
        -: 2779:};
        -: 2780:
        -: 2781:#if __has_feature(is_trivially_constructible) || _GNUC_VER >= 501
        -: 2782:
        -: 2783:template <class _Tp>
        -: 2784:struct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible<_Tp, __is_construct::__nat,
        -: 2785:                                                       __is_construct::__nat>
        -: 2786:    : integral_constant<bool, __is_trivially_constructible(_Tp)>
        -: 2787:{
        -: 2788:};
        -: 2789:
        -: 2790:template <class _Tp>
        -: 2791:struct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible<_Tp, _Tp,
        -: 2792:                                                       __is_construct::__nat>
        -: 2793:    : integral_constant<bool, __is_trivially_constructible(_Tp, _Tp)>
        -: 2794:{
        -: 2795:};
        -: 2796:
        -: 2797:template <class _Tp>
        -: 2798:struct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible<_Tp, const _Tp&,
        -: 2799:                                                       __is_construct::__nat>
        -: 2800:    : integral_constant<bool, __is_trivially_constructible(_Tp, const _Tp&)>
        -: 2801:{
        -: 2802:};
        -: 2803:
        -: 2804:template <class _Tp>
        -: 2805:struct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible<_Tp, _Tp&,
        -: 2806:                                                       __is_construct::__nat>
        -: 2807:    : integral_constant<bool, __is_trivially_constructible(_Tp, _Tp&)>
        -: 2808:{
        -: 2809:};
        -: 2810:
        -: 2811:#else  // !__has_feature(is_trivially_constructible)
        -: 2812:
        -: 2813:template <class _Tp>
        -: 2814:struct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible<_Tp, __is_construct::__nat,
        -: 2815:                                                       __is_construct::__nat>
        -: 2816:    : integral_constant<bool, is_scalar<_Tp>::value>
        -: 2817:{
        -: 2818:};
        -: 2819:
        -: 2820:template <class _Tp>
        -: 2821:struct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible<_Tp, _Tp,
        -: 2822:                                                       __is_construct::__nat>
        -: 2823:    : integral_constant<bool, is_scalar<_Tp>::value>
        -: 2824:{
        -: 2825:};
        -: 2826:
        -: 2827:template <class _Tp>
        -: 2828:struct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible<_Tp, const _Tp&,
        -: 2829:                                                       __is_construct::__nat>
        -: 2830:    : integral_constant<bool, is_scalar<_Tp>::value>
        -: 2831:{
        -: 2832:};
        -: 2833:
        -: 2834:template <class _Tp>
        -: 2835:struct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible<_Tp, _Tp&,
        -: 2836:                                                       __is_construct::__nat>
        -: 2837:    : integral_constant<bool, is_scalar<_Tp>::value>
        -: 2838:{
        -: 2839:};
        -: 2840:
        -: 2841:#endif  // !__has_feature(is_trivially_constructible)
        -: 2842:
        -: 2843:#endif  // _LIBCPP_HAS_NO_VARIADICS
        -: 2844:
        -: 2845:// is_trivially_default_constructible
        -: 2846:
        -: 2847:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_trivially_default_constructible
        -: 2848:    : public is_trivially_constructible<_Tp>
        -: 2849:    {};
        -: 2850:
        -: 2851:// is_trivially_copy_constructible
        -: 2852:
        -: 2853:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_trivially_copy_constructible
        -: 2854:    : public is_trivially_constructible<_Tp, typename add_lvalue_reference<const _Tp>::type>
        -: 2855:    {};
        -: 2856:
        -: 2857:// is_trivially_move_constructible
        -: 2858:
        -: 2859:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_trivially_move_constructible
        -: 2860:#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -: 2861:    : public is_trivially_constructible<_Tp, typename add_rvalue_reference<_Tp>::type>
        -: 2862:#else
        -: 2863:    : public is_trivially_copy_constructible<_Tp>
        -: 2864:#endif
        -: 2865:    {};
        -: 2866:
        -: 2867:// is_trivially_assignable
        -: 2868:
        -: 2869:#if __has_feature(is_trivially_assignable) || _GNUC_VER >= 501
        -: 2870:
        -: 2871:template <class _Tp, class _Arg>
        -: 2872:struct is_trivially_assignable
        -: 2873:    : integral_constant<bool, __is_trivially_assignable(_Tp, _Arg)>
        -: 2874:{
        -: 2875:};
        -: 2876:
        -: 2877:#else  // !__has_feature(is_trivially_assignable)
        -: 2878:
        -: 2879:template <class _Tp, class _Arg>
        -: 2880:struct is_trivially_assignable
        -: 2881:    : public false_type {};
        -: 2882:
        -: 2883:template <class _Tp>
        -: 2884:struct is_trivially_assignable<_Tp&, _Tp>
        -: 2885:    : integral_constant<bool, is_scalar<_Tp>::value> {};
        -: 2886:
        -: 2887:template <class _Tp>
        -: 2888:struct is_trivially_assignable<_Tp&, _Tp&>
        -: 2889:    : integral_constant<bool, is_scalar<_Tp>::value> {};
        -: 2890:
        -: 2891:template <class _Tp>
        -: 2892:struct is_trivially_assignable<_Tp&, const _Tp&>
        -: 2893:    : integral_constant<bool, is_scalar<_Tp>::value> {};
        -: 2894:
        -: 2895:#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -: 2896:
        -: 2897:template <class _Tp>
        -: 2898:struct is_trivially_assignable<_Tp&, _Tp&&>
        -: 2899:    : integral_constant<bool, is_scalar<_Tp>::value> {};
        -: 2900:
        -: 2901:#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -: 2902:
        -: 2903:#endif  // !__has_feature(is_trivially_assignable)
        -: 2904:
        -: 2905:// is_trivially_copy_assignable
        -: 2906:
        -: 2907:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_trivially_copy_assignable
        -: 2908:    : public is_trivially_assignable<typename add_lvalue_reference<_Tp>::type,
        -: 2909:                  typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {};
        -: 2910:
        -: 2911:// is_trivially_move_assignable
        -: 2912:
        -: 2913:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_trivially_move_assignable
        -: 2914:    : public is_trivially_assignable<typename add_lvalue_reference<_Tp>::type,
        -: 2915:#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -: 2916:                                     typename add_rvalue_reference<_Tp>::type>
        -: 2917:#else
        -: 2918:                                     typename add_lvalue_reference<_Tp>::type>
        -: 2919:#endif
        -: 2920:    {};
        -: 2921:
        -: 2922:// is_trivially_destructible
        -: 2923:
        -: 2924:#if __has_feature(has_trivial_destructor) || (_GNUC_VER >= 403)
        -: 2925:
        -: 2926:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_trivially_destructible
        -: 2927:    : public integral_constant<bool, is_destructible<_Tp>::value && __has_trivial_destructor(_Tp)> {};
        -: 2928:
        -: 2929:#else
        -: 2930:
        -: 2931:template <class _Tp> struct __libcpp_trivial_destructor
        -: 2932:    : public integral_constant<bool, is_scalar<_Tp>::value ||
        -: 2933:                                     is_reference<_Tp>::value> {};
        -: 2934:
        -: 2935:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_trivially_destructible
        -: 2936:    : public __libcpp_trivial_destructor<typename remove_all_extents<_Tp>::type> {};
        -: 2937:
        -: 2938:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_trivially_destructible<_Tp[]>
        -: 2939:    : public false_type {};
        -: 2940:
        -: 2941:#endif
        -: 2942:
        -: 2943:// is_nothrow_constructible
        -: 2944:
        -: 2945:#if 0
        -: 2946:template <class _Tp, class... _Args>
        -: 2947:struct _LIBCPP_TYPE_VIS_ONLY is_nothrow_constructible
        -: 2948:    : public integral_constant<bool, __is_nothrow_constructible(_Tp(_Args...))>
        -: 2949:{
        -: 2950:};
        -: 2951:
        -: 2952:#else
        -: 2953:
        -: 2954:#ifndef _LIBCPP_HAS_NO_VARIADICS
        -: 2955:
        -: 2956:#if __has_feature(cxx_noexcept) || (_GNUC_VER >= 407 && __cplusplus >= 201103L)
        -: 2957:
        -: 2958:template <bool, bool, class _Tp, class... _Args> struct __libcpp_is_nothrow_constructible;
        -: 2959:
        -: 2960:template <class _Tp, class... _Args>
        -: 2961:struct __libcpp_is_nothrow_constructible</*is constructible*/true, /*is reference*/false, _Tp, _Args...>
        -: 2962:    : public integral_constant<bool, noexcept(_Tp(declval<_Args>()...))>
        -: 2963:{
        -: 2964:};
        -: 2965:
        -: 2966:template <class _Tp>
        -: 2967:void __implicit_conversion_to(_Tp) noexcept { }
        -: 2968:
        -: 2969:template <class _Tp, class _Arg>
        -: 2970:struct __libcpp_is_nothrow_constructible</*is constructible*/true, /*is reference*/true, _Tp, _Arg>
        -: 2971:    : public integral_constant<bool, noexcept(__implicit_conversion_to<_Tp>(declval<_Arg>()))>
        -: 2972:{
        -: 2973:};
        -: 2974:
        -: 2975:template <class _Tp, bool _IsReference, class... _Args>
        -: 2976:struct __libcpp_is_nothrow_constructible</*is constructible*/false, _IsReference, _Tp, _Args...>
        -: 2977:    : public false_type
        -: 2978:{
        -: 2979:};
        -: 2980:
        -: 2981:template <class _Tp, class... _Args>
        -: 2982:struct _LIBCPP_TYPE_VIS_ONLY is_nothrow_constructible
        -: 2983:    : __libcpp_is_nothrow_constructible<is_constructible<_Tp, _Args...>::value, is_reference<_Tp>::value, _Tp, _Args...>
        -: 2984:{
        -: 2985:};
        -: 2986:
        -: 2987:template <class _Tp, size_t _Ns>
        -: 2988:struct _LIBCPP_TYPE_VIS_ONLY is_nothrow_constructible<_Tp[_Ns]>
        -: 2989:    : __libcpp_is_nothrow_constructible<is_constructible<_Tp>::value, is_reference<_Tp>::value, _Tp>
        -: 2990:{
        -: 2991:};
        -: 2992:
        -: 2993:#else  // __has_feature(cxx_noexcept)
        -: 2994:
        -: 2995:template <class _Tp, class... _Args>
        -: 2996:struct _LIBCPP_TYPE_VIS_ONLY is_nothrow_constructible
        -: 2997:    : false_type
        -: 2998:{
        -: 2999:};
        -: 3000:
        -: 3001:template <class _Tp>
        -: 3002:struct _LIBCPP_TYPE_VIS_ONLY is_nothrow_constructible<_Tp>
        -: 3003:#if __has_feature(has_nothrow_constructor) || (_GNUC_VER >= 403)
        -: 3004:    : integral_constant<bool, __has_nothrow_constructor(_Tp)>
        -: 3005:#else
        -: 3006:    : integral_constant<bool, is_scalar<_Tp>::value>
        -: 3007:#endif
        -: 3008:{
        -: 3009:};
        -: 3010:
        -: 3011:template <class _Tp>
        -: 3012:#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -: 3013:struct _LIBCPP_TYPE_VIS_ONLY is_nothrow_constructible<_Tp, _Tp&&>
        -: 3014:#else
        -: 3015:struct _LIBCPP_TYPE_VIS_ONLY is_nothrow_constructible<_Tp, _Tp>
        -: 3016:#endif
        -: 3017:#if __has_feature(has_nothrow_copy) || (_GNUC_VER >= 403)
        -: 3018:    : integral_constant<bool, __has_nothrow_copy(_Tp)>
        -: 3019:#else
        -: 3020:    : integral_constant<bool, is_scalar<_Tp>::value>
        -: 3021:#endif
        -: 3022:{
        -: 3023:};
        -: 3024:
        -: 3025:template <class _Tp>
        -: 3026:struct _LIBCPP_TYPE_VIS_ONLY is_nothrow_constructible<_Tp, const _Tp&>
        -: 3027:#if __has_feature(has_nothrow_copy) || (_GNUC_VER >= 403)
        -: 3028:    : integral_constant<bool, __has_nothrow_copy(_Tp)>
        -: 3029:#else
        -: 3030:    : integral_constant<bool, is_scalar<_Tp>::value>
        -: 3031:#endif
        -: 3032:{
        -: 3033:};
        -: 3034:
        -: 3035:template <class _Tp>
        -: 3036:struct _LIBCPP_TYPE_VIS_ONLY is_nothrow_constructible<_Tp, _Tp&>
        -: 3037:#if __has_feature(has_nothrow_copy) || (_GNUC_VER >= 403)
        -: 3038:    : integral_constant<bool, __has_nothrow_copy(_Tp)>
        -: 3039:#else
        -: 3040:    : integral_constant<bool, is_scalar<_Tp>::value>
        -: 3041:#endif
        -: 3042:{
        -: 3043:};
        -: 3044:
        -: 3045:#endif  // __has_feature(cxx_noexcept)
        -: 3046:
        -: 3047:#else  // _LIBCPP_HAS_NO_VARIADICS
        -: 3048:
        -: 3049:template <class _Tp, class _A0 = __is_construct::__nat,
        -: 3050:                     class _A1 = __is_construct::__nat>
        -: 3051:struct _LIBCPP_TYPE_VIS_ONLY is_nothrow_constructible
        -: 3052:    : false_type
        -: 3053:{
        -: 3054:};
        -: 3055:
        -: 3056:template <class _Tp>
        -: 3057:struct _LIBCPP_TYPE_VIS_ONLY is_nothrow_constructible<_Tp, __is_construct::__nat,
        -: 3058:                                                       __is_construct::__nat>
        -: 3059:#if __has_feature(has_nothrow_constructor) || (_GNUC_VER >= 403)
        -: 3060:    : integral_constant<bool, __has_nothrow_constructor(_Tp)>
        -: 3061:#else
        -: 3062:    : integral_constant<bool, is_scalar<_Tp>::value>
        -: 3063:#endif
        -: 3064:{
        -: 3065:};
        -: 3066:
        -: 3067:template <class _Tp>
        -: 3068:struct _LIBCPP_TYPE_VIS_ONLY is_nothrow_constructible<_Tp, _Tp,
        -: 3069:                                                       __is_construct::__nat>
        -: 3070:#if __has_feature(has_nothrow_copy) || (_GNUC_VER >= 403)
        -: 3071:    : integral_constant<bool, __has_nothrow_copy(_Tp)>
        -: 3072:#else
        -: 3073:    : integral_constant<bool, is_scalar<_Tp>::value>
        -: 3074:#endif
        -: 3075:{
        -: 3076:};
        -: 3077:
        -: 3078:template <class _Tp>
        -: 3079:struct _LIBCPP_TYPE_VIS_ONLY is_nothrow_constructible<_Tp, const _Tp&,
        -: 3080:                                                       __is_construct::__nat>
        -: 3081:#if __has_feature(has_nothrow_copy) || (_GNUC_VER >= 403)
        -: 3082:    : integral_constant<bool, __has_nothrow_copy(_Tp)>
        -: 3083:#else
        -: 3084:    : integral_constant<bool, is_scalar<_Tp>::value>
        -: 3085:#endif
        -: 3086:{
        -: 3087:};
        -: 3088:
        -: 3089:template <class _Tp>
        -: 3090:struct _LIBCPP_TYPE_VIS_ONLY is_nothrow_constructible<_Tp, _Tp&,
        -: 3091:                                                       __is_construct::__nat>
        -: 3092:#if __has_feature(has_nothrow_copy) || (_GNUC_VER >= 403)
        -: 3093:    : integral_constant<bool, __has_nothrow_copy(_Tp)>
        -: 3094:#else
        -: 3095:    : integral_constant<bool, is_scalar<_Tp>::value>
        -: 3096:#endif
        -: 3097:{
        -: 3098:};
        -: 3099:
        -: 3100:#endif  // _LIBCPP_HAS_NO_VARIADICS
        -: 3101:#endif  // __has_feature(is_nothrow_constructible)
        -: 3102:
        -: 3103:// is_nothrow_default_constructible
        -: 3104:
        -: 3105:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_nothrow_default_constructible
        -: 3106:    : public is_nothrow_constructible<_Tp>
        -: 3107:    {};
        -: 3108:
        -: 3109:// is_nothrow_copy_constructible
        -: 3110:
        -: 3111:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_nothrow_copy_constructible
        -: 3112:    : public is_nothrow_constructible<_Tp,
        -: 3113:                  typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {};
        -: 3114:
        -: 3115:// is_nothrow_move_constructible
        -: 3116:
        -: 3117:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_nothrow_move_constructible
        -: 3118:#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -: 3119:    : public is_nothrow_constructible<_Tp, typename add_rvalue_reference<_Tp>::type>
        -: 3120:#else
        -: 3121:    : public is_nothrow_copy_constructible<_Tp>
        -: 3122:#endif
        -: 3123:    {};
        -: 3124:
        -: 3125:// is_nothrow_assignable
        -: 3126:
        -: 3127:#if __has_feature(cxx_noexcept) || (_GNUC_VER >= 407 && __cplusplus >= 201103L)
        -: 3128:
        -: 3129:template <bool, class _Tp, class _Arg> struct __libcpp_is_nothrow_assignable;
        -: 3130:
        -: 3131:template <class _Tp, class _Arg>
        -: 3132:struct __libcpp_is_nothrow_assignable<false, _Tp, _Arg>
        -: 3133:    : public false_type
        -: 3134:{
        -: 3135:};
        -: 3136:
        -: 3137:template <class _Tp, class _Arg>
        -: 3138:struct __libcpp_is_nothrow_assignable<true, _Tp, _Arg>
        -: 3139:    : public integral_constant<bool, noexcept(_VSTD::declval<_Tp>() = _VSTD::declval<_Arg>()) >
        -: 3140:{
        -: 3141:};
        -: 3142:
        -: 3143:template <class _Tp, class _Arg>
        -: 3144:struct _LIBCPP_TYPE_VIS_ONLY is_nothrow_assignable
        -: 3145:    : public __libcpp_is_nothrow_assignable<is_assignable<_Tp, _Arg>::value, _Tp, _Arg>
        -: 3146:{
        -: 3147:};
        -: 3148:
        -: 3149:#else  // __has_feature(cxx_noexcept)
        -: 3150:
        -: 3151:template <class _Tp, class _Arg>
        -: 3152:struct _LIBCPP_TYPE_VIS_ONLY is_nothrow_assignable
        -: 3153:    : public false_type {};
        -: 3154:
        -: 3155:template <class _Tp>
        -: 3156:struct _LIBCPP_TYPE_VIS_ONLY is_nothrow_assignable<_Tp&, _Tp>
        -: 3157:#if __has_feature(has_nothrow_assign) || (_GNUC_VER >= 403)
        -: 3158:    : integral_constant<bool, __has_nothrow_assign(_Tp)> {};
        -: 3159:#else
        -: 3160:    : integral_constant<bool, is_scalar<_Tp>::value> {};
        -: 3161:#endif
        -: 3162:
        -: 3163:template <class _Tp>
        -: 3164:struct _LIBCPP_TYPE_VIS_ONLY is_nothrow_assignable<_Tp&, _Tp&>
        -: 3165:#if __has_feature(has_nothrow_assign) || (_GNUC_VER >= 403)
        -: 3166:    : integral_constant<bool, __has_nothrow_assign(_Tp)> {};
        -: 3167:#else
        -: 3168:    : integral_constant<bool, is_scalar<_Tp>::value> {};
        -: 3169:#endif
        -: 3170:
        -: 3171:template <class _Tp>
        -: 3172:struct _LIBCPP_TYPE_VIS_ONLY is_nothrow_assignable<_Tp&, const _Tp&>
        -: 3173:#if __has_feature(has_nothrow_assign) || (_GNUC_VER >= 403)
        -: 3174:    : integral_constant<bool, __has_nothrow_assign(_Tp)> {};
        -: 3175:#else
        -: 3176:    : integral_constant<bool, is_scalar<_Tp>::value> {};
        -: 3177:#endif
        -: 3178:
        -: 3179:#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -: 3180:
        -: 3181:template <class _Tp>
        -: 3182:struct is_nothrow_assignable<_Tp&, _Tp&&>
        -: 3183:#if __has_feature(has_nothrow_assign) || (_GNUC_VER >= 403)
        -: 3184:    : integral_constant<bool, __has_nothrow_assign(_Tp)> {};
        -: 3185:#else
        -: 3186:    : integral_constant<bool, is_scalar<_Tp>::value> {};
        -: 3187:#endif
        -: 3188:
        -: 3189:#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -: 3190:
        -: 3191:#endif  // __has_feature(cxx_noexcept)
        -: 3192:
        -: 3193:// is_nothrow_copy_assignable
        -: 3194:
        -: 3195:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_nothrow_copy_assignable
        -: 3196:    : public is_nothrow_assignable<typename add_lvalue_reference<_Tp>::type,
        -: 3197:                  typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {};
        -: 3198:
        -: 3199:// is_nothrow_move_assignable
        -: 3200:
        -: 3201:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_nothrow_move_assignable
        -: 3202:    : public is_nothrow_assignable<typename add_lvalue_reference<_Tp>::type,
        -: 3203:#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -: 3204:                                     typename add_rvalue_reference<_Tp>::type>
        -: 3205:#else
        -: 3206:                                     typename add_lvalue_reference<_Tp>::type>
        -: 3207:#endif
        -: 3208:    {};
        -: 3209:
        -: 3210:// is_nothrow_destructible
        -: 3211:
        -: 3212:#if __has_feature(cxx_noexcept) || (_GNUC_VER >= 407 && __cplusplus >= 201103L)
        -: 3213:
        -: 3214:template <bool, class _Tp> struct __libcpp_is_nothrow_destructible;
        -: 3215:
        -: 3216:template <class _Tp>
        -: 3217:struct __libcpp_is_nothrow_destructible<false, _Tp>
        -: 3218:    : public false_type
        -: 3219:{
        -: 3220:};
        -: 3221:
        -: 3222:template <class _Tp>
        -: 3223:struct __libcpp_is_nothrow_destructible<true, _Tp>
        -: 3224:    : public integral_constant<bool, noexcept(_VSTD::declval<_Tp>().~_Tp()) >
        -: 3225:{
        -: 3226:};
        -: 3227:
        -: 3228:template <class _Tp>
        -: 3229:struct _LIBCPP_TYPE_VIS_ONLY is_nothrow_destructible
        -: 3230:    : public __libcpp_is_nothrow_destructible<is_destructible<_Tp>::value, _Tp>
        -: 3231:{
        -: 3232:};
        -: 3233:
        -: 3234:template <class _Tp, size_t _Ns>
        -: 3235:struct _LIBCPP_TYPE_VIS_ONLY is_nothrow_destructible<_Tp[_Ns]>
        -: 3236:    : public is_nothrow_destructible<_Tp>
        -: 3237:{
        -: 3238:};
        -: 3239:
        -: 3240:template <class _Tp>
        -: 3241:struct _LIBCPP_TYPE_VIS_ONLY is_nothrow_destructible<_Tp&>
        -: 3242:    : public true_type
        -: 3243:{
        -: 3244:};
        -: 3245:
        -: 3246:#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -: 3247:
        -: 3248:template <class _Tp>
        -: 3249:struct _LIBCPP_TYPE_VIS_ONLY is_nothrow_destructible<_Tp&&>
        -: 3250:    : public true_type
        -: 3251:{
        -: 3252:};
        -: 3253:
        -: 3254:#endif
        -: 3255:
        -: 3256:#else
        -: 3257:
        -: 3258:template <class _Tp> struct __libcpp_nothrow_destructor
        -: 3259:    : public integral_constant<bool, is_scalar<_Tp>::value ||
        -: 3260:                                     is_reference<_Tp>::value> {};
        -: 3261:
        -: 3262:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_nothrow_destructible
        -: 3263:    : public __libcpp_nothrow_destructor<typename remove_all_extents<_Tp>::type> {};
        -: 3264:
        -: 3265:template <class _Tp>
        -: 3266:struct _LIBCPP_TYPE_VIS_ONLY is_nothrow_destructible<_Tp[]>
        -: 3267:    : public false_type {};
        -: 3268:
        -: 3269:#endif
        -: 3270:
        -: 3271:// is_pod
        -: 3272:
        -: 3273:#if __has_feature(is_pod) || (_GNUC_VER >= 403)
        -: 3274:
        -: 3275:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_pod
        -: 3276:    : public integral_constant<bool, __is_pod(_Tp)> {};
        -: 3277:
        -: 3278:#else
        -: 3279:
        -: 3280:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_pod
        -: 3281:    : public integral_constant<bool, is_trivially_default_constructible<_Tp>::value   &&
        -: 3282:                                     is_trivially_copy_constructible<_Tp>::value      &&
        -: 3283:                                     is_trivially_copy_assignable<_Tp>::value    &&
        -: 3284:                                     is_trivially_destructible<_Tp>::value> {};
        -: 3285:
        -: 3286:#endif
        -: 3287:
        -: 3288:// is_literal_type;
        -: 3289:
        -: 3290:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_literal_type
        -: 3291:#ifdef _LIBCPP_IS_LITERAL
        -: 3292:    : public integral_constant<bool, _LIBCPP_IS_LITERAL(_Tp)>
        -: 3293:#else
        -: 3294:    : integral_constant<bool, is_scalar<typename remove_all_extents<_Tp>::type>::value ||
        -: 3295:                              is_reference<typename remove_all_extents<_Tp>::type>::value>
        -: 3296:#endif
        -: 3297:    {};
        -: 3298:    
        -: 3299:// is_standard_layout;
        -: 3300:
        -: 3301:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_standard_layout
        -: 3302:#if __has_feature(is_standard_layout) || (_GNUC_VER >= 407)
        -: 3303:    : public integral_constant<bool, __is_standard_layout(_Tp)>
        -: 3304:#else
        -: 3305:    : integral_constant<bool, is_scalar<typename remove_all_extents<_Tp>::type>::value>
        -: 3306:#endif
        -: 3307:    {};
        -: 3308:    
        -: 3309:// is_trivially_copyable;
        -: 3310:
        -: 3311:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_trivially_copyable
        -: 3312:#if __has_feature(is_trivially_copyable)
        -: 3313:    : public integral_constant<bool, __is_trivially_copyable(_Tp)>
        -: 3314:#elif _GNUC_VER >= 501
        -: 3315:    : public integral_constant<bool, !is_volatile<_Tp>::value && __is_trivially_copyable(_Tp)>
        -: 3316:#else
        -: 3317:    : integral_constant<bool, is_scalar<typename remove_all_extents<_Tp>::type>::value>
        -: 3318:#endif
        -: 3319:    {};
        -: 3320:    
        -: 3321:// is_trivial;
        -: 3322:
        -: 3323:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_trivial
        -: 3324:#if __has_feature(is_trivial) || _GNUC_VER >= 407
        -: 3325:    : public integral_constant<bool, __is_trivial(_Tp)>
        -: 3326:#else
        -: 3327:    : integral_constant<bool, is_trivially_copyable<_Tp>::value &&
        -: 3328:                                 is_trivially_default_constructible<_Tp>::value>
        -: 3329:#endif
        -: 3330:    {};
        -: 3331:
        -: 3332:#ifndef _LIBCPP_HAS_NO_VARIADICS
        -: 3333:
        -: 3334:// Check for complete types
        -: 3335:
        -: 3336:template <class ..._Tp> struct __check_complete;
        -: 3337:
        -: 3338:template <>
        -: 3339:struct __check_complete<>
        -: 3340:{
        -: 3341:};
        -: 3342:
        -: 3343:template <class _Hp, class _T0, class ..._Tp>
        -: 3344:struct __check_complete<_Hp, _T0, _Tp...>
        -: 3345:    : private __check_complete<_Hp>,
        -: 3346:      private __check_complete<_T0, _Tp...>
        -: 3347:{
        -: 3348:};
        -: 3349:
        -: 3350:template <class _Hp>
        -: 3351:struct __check_complete<_Hp, _Hp>
        -: 3352:    : private __check_complete<_Hp>
        -: 3353:{
        -: 3354:};
        -: 3355:
        -: 3356:template <class _Tp>
        -: 3357:struct __check_complete<_Tp>
        -: 3358:{
        -: 3359:    static_assert(sizeof(_Tp) > 0, "Type must be complete.");
        -: 3360:};
        -: 3361:
        -: 3362:template <class _Tp>
        -: 3363:struct __check_complete<_Tp&>
        -: 3364:    : private __check_complete<_Tp>
        -: 3365:{
        -: 3366:};
        -: 3367:
        -: 3368:template <class _Tp>
        -: 3369:struct __check_complete<_Tp&&>
        -: 3370:    : private __check_complete<_Tp>
        -: 3371:{
        -: 3372:};
        -: 3373:
        -: 3374:template <class _Rp, class ..._Param>
        -: 3375:struct __check_complete<_Rp (*)(_Param...)>
        -: 3376:    : private __check_complete<_Rp>
        -: 3377:{
        -: 3378:};
        -: 3379:
        -: 3380:template <class ..._Param>
        -: 3381:struct __check_complete<void (*)(_Param...)>
        -: 3382:{
        -: 3383:};
        -: 3384:
        -: 3385:template <class _Rp, class ..._Param>
        -: 3386:struct __check_complete<_Rp (_Param...)>
        -: 3387:    : private __check_complete<_Rp>
        -: 3388:{
        -: 3389:};
        -: 3390:
        -: 3391:template <class ..._Param>
        -: 3392:struct __check_complete<void (_Param...)>
        -: 3393:{
        -: 3394:};
        -: 3395:
        -: 3396:template <class _Rp, class _Class, class ..._Param>
        -: 3397:struct __check_complete<_Rp (_Class::*)(_Param...)>
        -: 3398:    : private __check_complete<_Class>
        -: 3399:{
        -: 3400:};
        -: 3401:
        -: 3402:template <class _Rp, class _Class, class ..._Param>
        -: 3403:struct __check_complete<_Rp (_Class::*)(_Param...) const>
        -: 3404:    : private __check_complete<_Class>
        -: 3405:{
        -: 3406:};
        -: 3407:
        -: 3408:template <class _Rp, class _Class, class ..._Param>
        -: 3409:struct __check_complete<_Rp (_Class::*)(_Param...) volatile>
        -: 3410:    : private __check_complete<_Class>
        -: 3411:{
        -: 3412:};
        -: 3413:
        -: 3414:template <class _Rp, class _Class, class ..._Param>
        -: 3415:struct __check_complete<_Rp (_Class::*)(_Param...) const volatile>
        -: 3416:    : private __check_complete<_Class>
        -: 3417:{
        -: 3418:};
        -: 3419:
        -: 3420:#if __has_feature(cxx_reference_qualified_functions)
        -: 3421:
        -: 3422:template <class _Rp, class _Class, class ..._Param>
        -: 3423:struct __check_complete<_Rp (_Class::*)(_Param...) &>
        -: 3424:    : private __check_complete<_Class>
        -: 3425:{
        -: 3426:};
        -: 3427:
        -: 3428:template <class _Rp, class _Class, class ..._Param>
        -: 3429:struct __check_complete<_Rp (_Class::*)(_Param...) const&>
        -: 3430:    : private __check_complete<_Class>
        -: 3431:{
        -: 3432:};
        -: 3433:
        -: 3434:template <class _Rp, class _Class, class ..._Param>
        -: 3435:struct __check_complete<_Rp (_Class::*)(_Param...) volatile&>
        -: 3436:    : private __check_complete<_Class>
        -: 3437:{
        -: 3438:};
        -: 3439:
        -: 3440:template <class _Rp, class _Class, class ..._Param>
        -: 3441:struct __check_complete<_Rp (_Class::*)(_Param...) const volatile&>
        -: 3442:    : private __check_complete<_Class>
        -: 3443:{
        -: 3444:};
        -: 3445:
        -: 3446:template <class _Rp, class _Class, class ..._Param>
        -: 3447:struct __check_complete<_Rp (_Class::*)(_Param...) &&>
        -: 3448:    : private __check_complete<_Class>
        -: 3449:{
        -: 3450:};
        -: 3451:
        -: 3452:template <class _Rp, class _Class, class ..._Param>
        -: 3453:struct __check_complete<_Rp (_Class::*)(_Param...) const&&>
        -: 3454:    : private __check_complete<_Class>
        -: 3455:{
        -: 3456:};
        -: 3457:
        -: 3458:template <class _Rp, class _Class, class ..._Param>
        -: 3459:struct __check_complete<_Rp (_Class::*)(_Param...) volatile&&>
        -: 3460:    : private __check_complete<_Class>
        -: 3461:{
        -: 3462:};
        -: 3463:
        -: 3464:template <class _Rp, class _Class, class ..._Param>
        -: 3465:struct __check_complete<_Rp (_Class::*)(_Param...) const volatile&&>
        -: 3466:    : private __check_complete<_Class>
        -: 3467:{
        -: 3468:};
        -: 3469:
        -: 3470:#endif
        -: 3471:
        -: 3472:template <class _Rp, class _Class>
        -: 3473:struct __check_complete<_Rp _Class::*>
        -: 3474:    : private __check_complete<_Class>
        -: 3475:{
        -: 3476:};
        -: 3477:
        -: 3478:// __invoke forward declarations
        -: 3479:
        -: 3480:// fall back - none of the bullets
        -: 3481:
        -: 3482:template <class ..._Args>
        -: 3483:auto
        -: 3484:__invoke(__any, _Args&& ...__args)
        -: 3485:    -> __nat;
        -: 3486:
        -: 3487:// bullets 1 and 2
        -: 3488:
        -: 3489:template <class _Fp, class _A0, class ..._Args,
        -: 3490:            class = typename enable_if
        -: 3491:            <
        -: 3492:                is_member_function_pointer<typename remove_reference<_Fp>::type>::value &&
        -: 3493:                is_base_of<typename remove_reference<typename __member_pointer_traits<typename remove_reference<_Fp>::type>::_ClassType>::type,
        -: 3494:                           typename remove_reference<_A0>::type>::value
        -: 3495:            >::type
        -: 3496:         >
        -: 3497:_LIBCPP_INLINE_VISIBILITY
        -: 3498:auto
        -: 3499:__invoke(_Fp&& __f, _A0&& __a0, _Args&& ...__args)
        -: 3500:    -> decltype((_VSTD::forward<_A0>(__a0).*__f)(_VSTD::forward<_Args>(__args)...));
        -: 3501:
        -: 3502:template <class _Fp, class _A0, class ..._Args,
        -: 3503:            class = typename enable_if
        -: 3504:            <
        -: 3505:                is_member_function_pointer<typename remove_reference<_Fp>::type>::value &&
        -: 3506:                !is_base_of<typename remove_reference<typename __member_pointer_traits<typename remove_reference<_Fp>::type>::_ClassType>::type,
        -: 3507:                           typename remove_reference<_A0>::type>::value
        -: 3508:            >::type
        -: 3509:         >
        -: 3510:_LIBCPP_INLINE_VISIBILITY
        -: 3511:auto
        -: 3512:__invoke(_Fp&& __f, _A0&& __a0, _Args&& ...__args)
        -: 3513:    -> decltype(((*_VSTD::forward<_A0>(__a0)).*__f)(_VSTD::forward<_Args>(__args)...));
        -: 3514:
        -: 3515:// bullets 3 and 4
        -: 3516:
        -: 3517:template <class _Fp, class _A0,
        -: 3518:            class = typename enable_if
        -: 3519:            <
        -: 3520:                is_member_object_pointer<typename remove_reference<_Fp>::type>::value &&
        -: 3521:                is_base_of<typename __member_pointer_traits<typename remove_reference<_Fp>::type>::_ClassType,
        -: 3522:                           typename remove_reference<_A0>::type>::value
        -: 3523:            >::type
        -: 3524:         >
        -: 3525:_LIBCPP_INLINE_VISIBILITY
        -: 3526:auto
        -: 3527:__invoke(_Fp&& __f, _A0&& __a0)
        -: 3528:    -> decltype(_VSTD::forward<_A0>(__a0).*__f);
        -: 3529:
        -: 3530:template <class _Fp, class _A0,
        -: 3531:            class = typename enable_if
        -: 3532:            <
        -: 3533:                is_member_object_pointer<typename remove_reference<_Fp>::type>::value &&
        -: 3534:                !is_base_of<typename __member_pointer_traits<typename remove_reference<_Fp>::type>::_ClassType,
        -: 3535:                           typename remove_reference<_A0>::type>::value
        -: 3536:            >::type
        -: 3537:         >
        -: 3538:_LIBCPP_INLINE_VISIBILITY
        -: 3539:auto
        -: 3540:__invoke(_Fp&& __f, _A0&& __a0)
        -: 3541:    -> decltype((*_VSTD::forward<_A0>(__a0)).*__f);
        -: 3542:
        -: 3543:// bullet 5
        -: 3544:
        -: 3545:template <class _Fp, class ..._Args>
        -: 3546:_LIBCPP_INLINE_VISIBILITY
        -: 3547:auto
        -: 3548:__invoke(_Fp&& __f, _Args&& ...__args)
        -: 3549:    -> decltype(_VSTD::forward<_Fp>(__f)(_VSTD::forward<_Args>(__args)...));
        -: 3550:
        -: 3551:// __invokable
        -: 3552:
        -: 3553:template <class _Fp, class ..._Args>
        -: 3554:struct __invokable_imp
        -: 3555:    : private __check_complete<_Fp>
        -: 3556:{
        -: 3557:    typedef decltype(
        -: 3558:            __invoke(_VSTD::declval<_Fp>(), _VSTD::declval<_Args>()...)
        -: 3559:                    ) type;
        -: 3560:    static const bool value = !is_same<type, __nat>::value;
        -: 3561:};
        -: 3562:
        -: 3563:template <class _Fp, class ..._Args>
        -: 3564:struct __invokable
        -: 3565:    : public integral_constant<bool,
        -: 3566:          __invokable_imp<_Fp, _Args...>::value>
        -: 3567:{
        -: 3568:};
        -: 3569:
        -: 3570:// __invoke_of
        -: 3571:
        -: 3572:template <bool _Invokable, class _Fp, class ..._Args>
        -: 3573:struct __invoke_of_imp  // false
        -: 3574:{
        -: 3575:};
        -: 3576:
        -: 3577:template <class _Fp, class ..._Args>
        -: 3578:struct __invoke_of_imp<true, _Fp, _Args...>
        -: 3579:{
        -: 3580:    typedef typename __invokable_imp<_Fp, _Args...>::type type;
        -: 3581:};
        -: 3582:
        -: 3583:template <class _Fp, class ..._Args>
        -: 3584:struct __invoke_of
        -: 3585:    : public __invoke_of_imp<__invokable<_Fp, _Args...>::value, _Fp, _Args...>
        -: 3586:{
        -: 3587:};
        -: 3588:
        -: 3589:template <class _Fp, class ..._Args>
        -: 3590:class _LIBCPP_TYPE_VIS_ONLY result_of<_Fp(_Args...)>
        -: 3591:    : public __invoke_of<_Fp, _Args...>
        -: 3592:{
        -: 3593:};
        -: 3594:
        -: 3595:#if _LIBCPP_STD_VER > 11
        -: 3596:template <class _Tp> using result_of_t = typename result_of<_Tp>::type;
        -: 3597:#endif
        -: 3598:
        -: 3599:#endif  // _LIBCPP_HAS_NO_VARIADICS
        -: 3600:
        -: 3601:template <class _Tp>
        -: 3602:inline _LIBCPP_INLINE_VISIBILITY
        -: 3603:#ifndef _LIBCPP_HAS_NO_ADVANCED_SFINAE
        -: 3604:typename enable_if
        -: 3605:<
        -: 3606:    is_move_constructible<_Tp>::value &&
        -: 3607:    is_move_assignable<_Tp>::value
        -: 3608:>::type
        -: 3609:#else
        -: 3610:void
        -: 3611:#endif
        -: 3612:swap(_Tp& __x, _Tp& __y) _NOEXCEPT_(is_nothrow_move_constructible<_Tp>::value &&
        -: 3613:                                    is_nothrow_move_assignable<_Tp>::value)
        -: 3614:{
        -: 3615:    _Tp __t(_VSTD::move(__x));
        -: 3616:    __x = _VSTD::move(__y);
        -: 3617:    __y = _VSTD::move(__t);
        -: 3618:}
        -: 3619:
        -: 3620:template <class _ForwardIterator1, class _ForwardIterator2>
        -: 3621:inline _LIBCPP_INLINE_VISIBILITY
        -: 3622:void
        -: 3623:iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)
        -: 3624:    //                                  _NOEXCEPT_(_NOEXCEPT_(swap(*__a, *__b)))
        -: 3625:               _NOEXCEPT_(_NOEXCEPT_(swap(*_VSTD::declval<_ForwardIterator1>(),
        -: 3626:                                          *_VSTD::declval<_ForwardIterator2>())))
        -: 3627:{
        -: 3628:    swap(*__a, *__b);
        -: 3629:}
        -: 3630:
        -: 3631:// __swappable
        -: 3632:
        -: 3633:namespace __detail
        -: 3634:{
        -: 3635:
        -: 3636:using _VSTD::swap;
        -: 3637:__nat swap(__any, __any);
        -: 3638:
        -: 3639:template <class _Tp>
        -: 3640:struct __swappable
        -: 3641:{
        -: 3642:    typedef decltype(swap(_VSTD::declval<_Tp&>(), _VSTD::declval<_Tp&>())) type;
        -: 3643:    static const bool value = !is_same<type, __nat>::value;
        -: 3644:};
        -: 3645:
        -: 3646:}  // __detail
        -: 3647:
        -: 3648:template <class _Tp>
        -: 3649:struct __is_swappable
        -: 3650:    : public integral_constant<bool, __detail::__swappable<_Tp>::value>
        -: 3651:{
        -: 3652:};
        -: 3653:
        -: 3654:#if __has_feature(cxx_noexcept) || (_GNUC_VER >= 407 && __cplusplus >= 201103L)
        -: 3655:
        -: 3656:template <bool, class _Tp>
        -: 3657:struct __is_nothrow_swappable_imp
        -: 3658:    : public integral_constant<bool, noexcept(swap(_VSTD::declval<_Tp&>(),
        -: 3659:                                                   _VSTD::declval<_Tp&>()))>
        -: 3660:{
        -: 3661:};
        -: 3662:
        -: 3663:template <class _Tp>
        -: 3664:struct __is_nothrow_swappable_imp<false, _Tp>
        -: 3665:    : public false_type
        -: 3666:{
        -: 3667:};
        -: 3668:
        -: 3669:template <class _Tp>
        -: 3670:struct __is_nothrow_swappable
        -: 3671:    : public __is_nothrow_swappable_imp<__is_swappable<_Tp>::value, _Tp>
        -: 3672:{
        -: 3673:};
        -: 3674:
        -: 3675:#else  // __has_feature(cxx_noexcept)
        -: 3676:
        -: 3677:template <class _Tp>
        -: 3678:struct __is_nothrow_swappable
        -: 3679:    : public false_type
        -: 3680:{
        -: 3681:};
        -: 3682:
        -: 3683:#endif  // __has_feature(cxx_noexcept)
        -: 3684:
        -: 3685:#ifdef _LIBCPP_UNDERLYING_TYPE
        -: 3686:
        -: 3687:template <class _Tp>
        -: 3688:struct underlying_type
        -: 3689:{
        -: 3690:    typedef _LIBCPP_UNDERLYING_TYPE(_Tp) type;
        -: 3691:};
        -: 3692:
        -: 3693:#if _LIBCPP_STD_VER > 11
        -: 3694:template <class _Tp> using underlying_type_t = typename underlying_type<_Tp>::type;
        -: 3695:#endif
        -: 3696:
        -: 3697:#else  // _LIBCPP_UNDERLYING_TYPE
        -: 3698:
        -: 3699:template <class _Tp, bool _Support = false>
        -: 3700:struct underlying_type
        -: 3701:{
        -: 3702:    static_assert(_Support, "The underyling_type trait requires compiler "
        -: 3703:                            "support. Either no such support exists or "
        -: 3704:                            "libc++ does not know how to use it.");
        -: 3705:};
        -: 3706:
        -: 3707:#endif // _LIBCPP_UNDERLYING_TYPE
        -: 3708:
        -: 3709:
        -: 3710:template <class _Tp, bool = std::is_enum<_Tp>::value>
        -: 3711:struct __sfinae_underlying_type
        -: 3712:{
        -: 3713:    typedef typename underlying_type<_Tp>::type type;
        -: 3714:    typedef decltype(((type)1) + 0) __promoted_type;
        -: 3715:};
        -: 3716:
        -: 3717:template <class _Tp>
        -: 3718:struct __sfinae_underlying_type<_Tp, false> {};
        -: 3719:
        -: 3720:inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_ALWAYS_INLINE
        -: 3721:int __convert_to_integral(int __val) { return __val; }
        -: 3722:
        -: 3723:inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_ALWAYS_INLINE
        -: 3724:unsigned __convert_to_integral(unsigned __val) { return __val; }
        -: 3725:
        -: 3726:inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_ALWAYS_INLINE
        -: 3727:long __convert_to_integral(long __val) { return __val; }
        -: 3728:
        -: 3729:inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_ALWAYS_INLINE
        -: 3730:unsigned long __convert_to_integral(unsigned long __val) { return __val; }
        -: 3731:
        -: 3732:inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_ALWAYS_INLINE
        -: 3733:long long __convert_to_integral(long long __val) { return __val; }
        -: 3734:
        -: 3735:inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_ALWAYS_INLINE
        -: 3736:unsigned long long __convert_to_integral(unsigned long long __val) {return __val; }
        -: 3737:
        -: 3738:#ifndef _LIBCPP_HAS_NO_INT128
        -: 3739:inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_ALWAYS_INLINE
        -: 3740:__int128_t __convert_to_integral(__int128_t __val) { return __val; }
        -: 3741:
        -: 3742:inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_ALWAYS_INLINE
        -: 3743:__uint128_t __convert_to_integral(__uint128_t __val) { return __val; }
        -: 3744:#endif
        -: 3745:
        -: 3746:template <class _Tp>
        -: 3747:inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_ALWAYS_INLINE
        -: 3748:typename __sfinae_underlying_type<_Tp>::__promoted_type
        -: 3749:__convert_to_integral(_Tp __val) { return __val; }
        -: 3750:
        -: 3751:#ifndef _LIBCPP_HAS_NO_ADVANCED_SFINAE
        -: 3752:
        -: 3753:template <class _Tp>
        -: 3754:struct __has_operator_addressof_member_imp
        -: 3755:{
        -: 3756:    template <class _Up>
        -: 3757:        static auto __test(int)
        -: 3758:            -> typename __select_2nd<decltype(_VSTD::declval<_Up>().operator&()), true_type>::type;
        -: 3759:    template <class>
        -: 3760:        static auto __test(long) -> false_type;
        -: 3761:
        -: 3762:    static const bool value = decltype(__test<_Tp>(0))::value;
        -: 3763:};
        -: 3764:
        -: 3765:template <class _Tp>
        -: 3766:struct __has_operator_addressof_free_imp
        -: 3767:{
        -: 3768:    template <class _Up>
        -: 3769:        static auto __test(int)
        -: 3770:            -> typename __select_2nd<decltype(operator&(_VSTD::declval<_Up>())), true_type>::type;
        -: 3771:    template <class>
        -: 3772:        static auto __test(long) -> false_type;
        -: 3773:
        -: 3774:    static const bool value = decltype(__test<_Tp>(0))::value;
        -: 3775:};
        -: 3776:
        -: 3777:template <class _Tp>
        -: 3778:struct __has_operator_addressof
        -: 3779:    : public integral_constant<bool, __has_operator_addressof_member_imp<_Tp>::value
        -: 3780:                                  || __has_operator_addressof_free_imp<_Tp>::value>
        -: 3781:{};
        -: 3782:
        -: 3783:#endif  // _LIBCPP_HAS_NO_ADVANCED_SFINAE
        -: 3784:
        -: 3785:#if _LIBCPP_STD_VER > 14
        -: 3786:template <class...> using void_t = void;
        -: 3787:#endif
        -: 3788:
        -: 3789:_LIBCPP_END_NAMESPACE_STD
        -: 3790:
        -: 3791:#endif  // _LIBCPP_TYPE_TRAITS
