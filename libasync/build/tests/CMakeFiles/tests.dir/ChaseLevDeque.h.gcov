        -:    0:Source:/Users/wjp/Desktop/workspace/libasync/libasync/./src/ChaseLevDeque.h
        -:    0:Graph:/Users/wjp/Desktop/workspace/libasync/libasync/build/tests/CMakeFiles/tests.dir/ChaseLevDequeTOT.cc.gcno
        -:    0:Data:/Users/wjp/Desktop/workspace/libasync/libasync/build/tests/CMakeFiles/tests.dir/ChaseLevDequeTOT.cc.gcda
        -:    0:Runs:2
        -:    0:Programs:1
        -:    1:/*
        -:    2:* MIT License
        -:    3:*
        -:    4:* Copyright (c) 2018 jipeng wu
        -:    5:* <recvfromsockaddr at gmail dot com>
        -:    6:*
        -:    7:* Permission is hereby granted, free of charge, to any person obtaining a copy
        -:    8:* of this software and associated documentation files (the "Software"), to deal
        -:    9:* in the Software without restriction, including without limitation the rights
        -:   10:* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
        -:   11:* copies of the Software, and to permit persons to whom the Software is
        -:   12:* furnished to do so, subject to the following conditions:
        -:   13:*
        -:   14:* The above copyright notice and this permission notice shall be included in all
        -:   15:* copies or substantial portions of the Software.
        -:   16:*
        -:   17:* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
        -:   18:* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
        -:   19:* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
        -:   20:* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
        -:   21:* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
        -:   22:* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
        -:   23:* SOFTWARE.
        -:   24:*/
        -:   25:
        -:   26:#pragma once
        -:   27:
        -:   28:#include "Common.h"
        -:   29:#include "AutoRelease.h"
        -:   30:
        -:   31://#include <optional>
        -:   32:
        -:   33:// An C++ implementation of optimized version of Chase-Lev Work Stealing Deque.
        -:   34:
        -:   35:// see https://www.dre.vanderbilt.edu/~schmidt/PDF/work-stealing-dequeue.pdf
        -:   36:// and https://www.di.ens.fr/~zappa/readings/ppopp13.pdf
        -:   37:
        -:   38:namespace wjp{
        -:   39:
        -:   40:// T is the type of a task
        -:   41:// Tasks are stored in std::shared_ptr<T>  
        -:   42:template<typename T>
        -:   43:class ChaseLevDeque
        -:   44:{
        -:   45:public:
        -:   46:    // ChaseLevDeque takes log2(capacity) as argument to guarantee that its capacity is power of 2. 
        8:   47:    ChaseLevDeque(int log2capacity=13)  : top(1<<(log2capacity-1)), bottom(1<<(log2capacity-1)),
       16:   48:                                        array(new SharedPointerArray(1<<log2capacity))
       16:   49:    {}
        -:   50:    struct SharedPointerArray{
        -:   51:        //Uses placement new to create shared_ptr in given buffer.
        -:   52:        SharedPointerArray(uint64_t cap) :
       18:   53:            buffer(reinterpret_cast<std::shared_ptr<T>*>(new char[sizeof(std::shared_ptr<T>)*cap])), 
       36:   54:            capacity(cap) {
     1172:   55:            for(int i=0;i<capacity;i++){ 
      568:   56:                new(reinterpret_cast<char*>(&buffer[i])) std::shared_ptr<T>{nullptr}; 
      568:   57:            }
       36:   58:        }
       10:   59:        ~SharedPointerArray(){
      532:   60:            for(int i=0;i<capacity;i++){
      256:   61:                buffer[i].~shared_ptr(); // destruct placement newed objects explicitly
      256:   62:            }
       20:   63:            delete [] reinterpret_cast<char*>(buffer);
       20:   64:        }
        -:   65:        std::shared_ptr<T>*     buffer;     // should be replaced by std::atomic<std::shared_ptr> in C++20
        -:   66:        std::atomic<uint64_t>   capacity;     // power of 2, grow at rate of *2 each time, init: 2^13(8K), max: 2^26(64M)
        -:   67:        std::shared_ptr<T>&     at(uint64_t index){
      996:   68:            return buffer[index%capacity];
        -:   69:        }
        -:   70:    };
        -:   71:    // Shows some internal stats for debugging.
        -:   72:    void                                print(){
        -:   73:        auto arr = array.load(std::memory_order_relaxed);
        -:   74:        std::cout<<"size="<<arr->capacity.load()<<", top="<<top.load()<<", bottom="<<bottom.load()<<std::endl;
        -:   75:        std::cout<<"[top ... bottom]: ";
        -:   76:        for(uint64_t i=top.load(std::memory_order_relaxed);i<bottom.load(std::memory_order_relaxed);i++){
        -:   77:            std::cout<<arr->at(i)<<" ";
        -:   78:        }  
        -:   79:        std::cout<<"| buffer="<< arr->buffer<<std::endl;
        -:   80:        std::cout<<std::endl;
        -:   81:    }
        -:   82:    // Tries to take a recently pushed task. It should only be called from the owning thread.
        -:   83:    std::shared_ptr<T>                  take() {
       14:   84:        auto b=bottom.load(std::memory_order_relaxed)-1;
       14:   85:        auto a=array.load(std::memory_order_relaxed);
       14:   86:        bottom.store(b,std::memory_order_relaxed);
       14:   87:        std::atomic_thread_fence(std::memory_order_seq_cst);
       14:   88:        auto t=top.load(std::memory_order_relaxed);
       14:   89:        std::shared_ptr<T> x;
       14:   90:        if (t <= b) { 
       36:   91:            x = std::atomic_load_explicit(&a->at(b), std::memory_order_relaxed);
       12:   92:            if (t == b) { // race against stealers for the last element
        2:   93:                if(!top.compare_exchange_strong(t,t+1,std::memory_order_seq_cst, std::memory_order_relaxed)){
    #####:   94:                    x=nullptr;
    #####:   95:                }
        2:   96:                bottom.store(b+1, std::memory_order_relaxed);
        2:   97:            }
       12:   98:        } else { // empty
        2:   99:            x=nullptr;
        2:  100:            bottom.store(b+1, std::memory_order_relaxed);
        -:  101:        }
       14:  102:        return x;
       28:  103:    }
        -:  104:    // Pushes a task to bottom. It should only be called from the owning thread.
        -:  105:    void                                push(std::shared_ptr<T> x) {
      234:  106:        auto b = bottom.load(std::memory_order_relaxed);
      234:  107:        auto t = top.load(std::memory_order_relaxed);
      234:  108:        auto a = array.load(std::memory_order_relaxed);
      234:  109:        if (b - t > a->capacity - 1) { // full
       10:  110:            grow();
       10:  111:            a = array.load(std::memory_order_relaxed);
       10:  112:        }
      468:  113:        std::atomic_store_explicit(&a->at(b), x, std::memory_order_relaxed);
      234:  114:        std::atomic_thread_fence(std::memory_order_release);
      234:  115:        bottom.store(b+1, std::memory_order_relaxed);
      234:  116:    }
        -:  117:    // Tries to steal the oldest task at top from the deque. It can be called from any thread, usually a stealer.
        -:  118:    std::shared_ptr<T>                  steal() {
     1763:  119:        auto t = top.load(std::memory_order_acquire);
     1763:  120:        std::atomic_thread_fence(std::memory_order_seq_cst);
     1763:  121:        auto b = bottom.load(std::memory_order_acquire);
     1763:  122:        std::shared_ptr<T> x = nullptr;
     1763:  123:        if (t < b) { 
      235:  124:            auto a = array.load(std::memory_order_consume);  
      731:  125:            x = std::atomic_load_explicit(&a->at(t), std::memory_order_relaxed);
      249:  126:            if (!top.compare_exchange_strong(t, t + 1, std::memory_order_seq_cst, std::memory_order_relaxed)){
       27:  127:                return nullptr; 
        -:  128:            }
      222:  129:        }
     1665:  130:        return x;
     1789:  131:    }
        -:  132:protected:
        -:  133:    // Doubles the underlying array's size. It is called when the deque becomes full.
        -:  134:    void                                grow(){
       10:  135:        auto old_arr = array.load(std::memory_order_relaxed);
       10:  136:        uint64_t new_capacity=old_arr->capacity<<1;
       10:  137:        AutoDelete<SharedPointerArray> delguard{old_arr}; //must declare variable name here, otherwise old_arr would be destroyed early
       30:  138:        auto new_arr=new SharedPointerArray(new_capacity);
      532:  139:        for(uint64_t i=top.load(std::memory_order_relaxed);i<bottom.load(std::memory_order_relaxed);i++)  
        -:  140:        {
      512:  141:            auto x = std::atomic_load_explicit(&old_arr->at(i), std::memory_order_relaxed);
      768:  142:            std::atomic_store_explicit(&new_arr->at(i), x, std::memory_order_relaxed);
      256:  143:        }
       10:  144:        array.store(new_arr, std::memory_order_relaxed);
       10:  145:    }
        -:  146:private:
        -:  147:    std::atomic<uint64_t>               top;
        -:  148:    std::atomic<uint64_t>               bottom;
        -:  149:    std::atomic<SharedPointerArray*>    array;
        -:  150:};
        -:  151:
        -:  152:}
