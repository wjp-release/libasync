        -:    0:Source:/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/exception
        -:    0:Graph:/Users/wjp/Desktop/workspace/libasync/libasync/build/tests/CMakeFiles/tests.dir/ChaseLevDequeTOT.cc.gcno
        -:    0:Data:/Users/wjp/Desktop/workspace/libasync/libasync/build/tests/CMakeFiles/tests.dir/ChaseLevDequeTOT.cc.gcda
        -:    0:Runs:2
        -:    0:Programs:1
        -:    1:// -*- C++ -*-
        -:    2://===-------------------------- exception ---------------------------------===//
        -:    3://
        -:    4://                     The LLVM Compiler Infrastructure
        -:    5://
        -:    6:// This file is dual licensed under the MIT and the University of Illinois Open
        -:    7:// Source Licenses. See LICENSE.TXT for details.
        -:    8://
        -:    9://===----------------------------------------------------------------------===//
        -:   10:
        -:   11:#ifndef _LIBCPP_EXCEPTION
        -:   12:#define _LIBCPP_EXCEPTION
        -:   13:
        -:   14:/*
        -:   15:    exception synopsis
        -:   16:
        -:   17:namespace std
        -:   18:{
        -:   19:
        -:   20:class exception
        -:   21:{
        -:   22:public:
        -:   23:    exception() noexcept;
        -:   24:    exception(const exception&) noexcept;
        -:   25:    exception& operator=(const exception&) noexcept;
        -:   26:    virtual ~exception() noexcept;
        -:   27:    virtual const char* what() const noexcept;
        -:   28:};
        -:   29:
        -:   30:class bad_exception
        -:   31:    : public exception
        -:   32:{
        -:   33:public:
        -:   34:    bad_exception() noexcept;
        -:   35:    bad_exception(const bad_exception&) noexcept;
        -:   36:    bad_exception& operator=(const bad_exception&) noexcept;
        -:   37:    virtual ~bad_exception() noexcept;
        -:   38:    virtual const char* what() const noexcept;
        -:   39:};
        -:   40:
        -:   41:typedef void (*unexpected_handler)();
        -:   42:unexpected_handler set_unexpected(unexpected_handler  f ) noexcept;
        -:   43:unexpected_handler get_unexpected() noexcept;
        -:   44:[[noreturn]] void unexpected();
        -:   45:
        -:   46:typedef void (*terminate_handler)();
        -:   47:terminate_handler set_terminate(terminate_handler  f ) noexcept;
        -:   48:terminate_handler get_terminate() noexcept;
        -:   49:[[noreturn]] void terminate() noexcept;
        -:   50:
        -:   51:bool uncaught_exception()  noexcept;
        -:   52:int  uncaught_exceptions() noexcept;  // C++17
        -:   53:
        -:   54:typedef unspecified exception_ptr;
        -:   55:
        -:   56:exception_ptr current_exception() noexcept;
        -:   57:void rethrow_exception [[noreturn]] (exception_ptr p);
        -:   58:template<class E> exception_ptr make_exception_ptr(E e) noexcept;
        -:   59:
        -:   60:class nested_exception
        -:   61:{
        -:   62:public:
        -:   63:    nested_exception() noexcept;
        -:   64:    nested_exception(const nested_exception&) noexcept = default;
        -:   65:    nested_exception& operator=(const nested_exception&) noexcept = default;
        -:   66:    virtual ~nested_exception() = default;
        -:   67:
        -:   68:    // access functions
        -:   69:    [[noreturn]] void rethrow_nested() const;
        -:   70:    exception_ptr nested_ptr() const noexcept;
        -:   71:};
        -:   72:
        -:   73:template <class T> [[noreturn]] void throw_with_nested(T&& t);
        -:   74:template <class E> void rethrow_if_nested(const E& e);
        -:   75:
        -:   76:}  // std
        -:   77:
        -:   78:*/
        -:   79:
        -:   80:#include <__config>
        -:   81:#include <cstddef>
        -:   82:#include <type_traits>
        -:   83:
        -:   84:#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
        -:   85:#pragma GCC system_header
        -:   86:#endif
        -:   87:
        -:   88:namespace std  // purposefully not using versioning namespace
        -:   89:{
        -:   90:
        -:   91:class _LIBCPP_EXCEPTION_ABI exception
        -:   92:{
        -:   93:public:
        -:   94:    _LIBCPP_INLINE_VISIBILITY exception() _NOEXCEPT {}
        -:   95:    virtual ~exception() _NOEXCEPT;
        -:   96:    virtual const char* what() const _NOEXCEPT;
        -:   97:};
        -:   98:
        -:   99:class _LIBCPP_EXCEPTION_ABI bad_exception
        -:  100:    : public exception
        -:  101:{
        -:  102:public:
        -:  103:    _LIBCPP_INLINE_VISIBILITY bad_exception() _NOEXCEPT {}
        -:  104:    virtual ~bad_exception() _NOEXCEPT;
        -:  105:    virtual const char* what() const _NOEXCEPT;
        -:  106:};
        -:  107:
        -:  108:typedef void (*unexpected_handler)();
        -:  109:_LIBCPP_FUNC_VIS unexpected_handler set_unexpected(unexpected_handler) _NOEXCEPT;
        -:  110:_LIBCPP_FUNC_VIS unexpected_handler get_unexpected() _NOEXCEPT;
        -:  111:_LIBCPP_NORETURN _LIBCPP_FUNC_VIS void unexpected();
        -:  112:
        -:  113:typedef void (*terminate_handler)();
        -:  114:_LIBCPP_FUNC_VIS terminate_handler set_terminate(terminate_handler) _NOEXCEPT;
        -:  115:_LIBCPP_FUNC_VIS terminate_handler get_terminate() _NOEXCEPT;
        -:  116:_LIBCPP_NORETURN _LIBCPP_FUNC_VIS void terminate() _NOEXCEPT;
        -:  117:
        -:  118:_LIBCPP_FUNC_VIS bool uncaught_exception() _NOEXCEPT;
        -:  119:_LIBCPP_FUNC_VIS _LIBCPP_AVAILABILITY_UNCAUGHT_EXCEPTIONS int uncaught_exceptions() _NOEXCEPT;
        -:  120:
        -:  121:class _LIBCPP_TYPE_VIS exception_ptr;
        -:  122:
        -:  123:_LIBCPP_FUNC_VIS exception_ptr current_exception() _NOEXCEPT;
        -:  124:_LIBCPP_NORETURN _LIBCPP_FUNC_VIS void rethrow_exception(exception_ptr);
        -:  125:
        -:  126:class _LIBCPP_TYPE_VIS exception_ptr
        -:  127:{
        -:  128:    void* __ptr_;
        -:  129:public:
       40:  130:    _LIBCPP_INLINE_VISIBILITY exception_ptr() _NOEXCEPT : __ptr_() {}
       79:  131:    _LIBCPP_INLINE_VISIBILITY exception_ptr(nullptr_t) _NOEXCEPT : __ptr_() {}
        -:  132:    exception_ptr(const exception_ptr&) _NOEXCEPT;
        -:  133:    exception_ptr& operator=(const exception_ptr&) _NOEXCEPT;
        -:  134:    ~exception_ptr() _NOEXCEPT;
        -:  135:
        -:  136:    _LIBCPP_INLINE_VISIBILITY
        -:  137:    _LIBCPP_EXPLICIT
        -:  138:        operator bool() const _NOEXCEPT {return __ptr_ != nullptr;}
        -:  139:
        -:  140:    friend _LIBCPP_INLINE_VISIBILITY
        -:  141:    bool operator==(const exception_ptr& __x, const exception_ptr& __y) _NOEXCEPT
       40:  142:        {return __x.__ptr_ == __y.__ptr_;}
        -:  143:    friend _LIBCPP_INLINE_VISIBILITY
        -:  144:    bool operator!=(const exception_ptr& __x, const exception_ptr& __y) _NOEXCEPT
       39:  145:        {return !(__x == __y);}
        -:  146:
        -:  147:    friend _LIBCPP_FUNC_VIS exception_ptr current_exception() _NOEXCEPT;
        -:  148:    friend _LIBCPP_FUNC_VIS void rethrow_exception(exception_ptr);
        -:  149:};
        -:  150:
        -:  151:template<class _Ep>
        -:  152:exception_ptr
        -:  153:make_exception_ptr(_Ep __e) _NOEXCEPT
        -:  154:{
        -:  155:#ifndef _LIBCPP_NO_EXCEPTIONS
        -:  156:    try
        -:  157:    {
        -:  158:        throw __e;
        -:  159:    }
        -:  160:    catch (...)
        -:  161:    {
        -:  162:        return current_exception();
        -:  163:    }
        -:  164:#endif  // _LIBCPP_NO_EXCEPTIONS
        -:  165:}
        -:  166:
        -:  167:// nested_exception
        -:  168:
        -:  169:class _LIBCPP_EXCEPTION_ABI nested_exception
        -:  170:{
        -:  171:    exception_ptr __ptr_;
        -:  172:public:
        -:  173:    nested_exception() _NOEXCEPT;
        -:  174://     nested_exception(const nested_exception&) noexcept = default;
        -:  175://     nested_exception& operator=(const nested_exception&) noexcept = default;
        -:  176:    virtual ~nested_exception() _NOEXCEPT;
        -:  177:
        -:  178:    // access functions
        -:  179:    _LIBCPP_NORETURN void rethrow_nested() const;
        -:  180:    _LIBCPP_INLINE_VISIBILITY exception_ptr nested_ptr() const _NOEXCEPT {return __ptr_;}
        -:  181:};
        -:  182:
        -:  183:template <class _Tp>
        -:  184:struct __nested
        -:  185:    : public _Tp,
        -:  186:      public nested_exception
        -:  187:{
        -:  188:    _LIBCPP_INLINE_VISIBILITY explicit __nested(const _Tp& __t) : _Tp(__t) {}
        -:  189:};
        -:  190:
        -:  191:template <class _Tp>
        -:  192:_LIBCPP_NORETURN
        -:  193:void
        -:  194:#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -:  195:throw_with_nested(_Tp&& __t, typename enable_if<
        -:  196:                  is_class<typename remove_reference<_Tp>::type>::value &&
        -:  197:                  !is_base_of<nested_exception, typename remove_reference<_Tp>::type>::value
        -:  198:                  && !__libcpp_is_final<typename remove_reference<_Tp>::type>::value
        -:  199:                                    >::type* = 0)
        -:  200:#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -:  201:throw_with_nested (_Tp& __t, typename enable_if<
        -:  202:                  is_class<_Tp>::value && !is_base_of<nested_exception, _Tp>::value
        -:  203:                                    >::type* = 0)
        -:  204:#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -:  205:{
        -:  206:#ifndef _LIBCPP_NO_EXCEPTIONS
        -:  207:    throw __nested<typename remove_reference<_Tp>::type>(_VSTD::forward<_Tp>(__t));
        -:  208:#endif
        -:  209:}
        -:  210:
        -:  211:template <class _Tp>
        -:  212:_LIBCPP_NORETURN
        -:  213:void
        -:  214:#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -:  215:throw_with_nested(_Tp&& __t, typename enable_if<
        -:  216:                  !is_class<typename remove_reference<_Tp>::type>::value ||
        -:  217:                  is_base_of<nested_exception, typename remove_reference<_Tp>::type>::value
        -:  218:                  || __libcpp_is_final<typename remove_reference<_Tp>::type>::value
        -:  219:                                    >::type* = 0)
        -:  220:#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -:  221:throw_with_nested (_Tp& __t, typename enable_if<
        -:  222:                  !is_class<_Tp>::value || is_base_of<nested_exception, _Tp>::value
        -:  223:                                    >::type* = 0)
        -:  224:#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -:  225:{
        -:  226:#ifndef _LIBCPP_NO_EXCEPTIONS
        -:  227:    throw _VSTD::forward<_Tp>(__t);
        -:  228:#endif
        -:  229:}
        -:  230:
        -:  231:template <class _Ep>
        -:  232:inline _LIBCPP_INLINE_VISIBILITY
        -:  233:void
        -:  234:rethrow_if_nested(const _Ep& __e, typename enable_if<
        -:  235:                                   is_polymorphic<_Ep>::value
        -:  236:                                                   >::type* = 0)
        -:  237:{
        -:  238:    const nested_exception* __nep = dynamic_cast<const nested_exception*>(&__e);
        -:  239:    if (__nep)
        -:  240:        __nep->rethrow_nested();
        -:  241:}
        -:  242:
        -:  243:template <class _Ep>
        -:  244:inline _LIBCPP_INLINE_VISIBILITY
        -:  245:void
        -:  246:rethrow_if_nested(const _Ep&, typename enable_if<
        -:  247:                                   !is_polymorphic<_Ep>::value
        -:  248:                                                   >::type* = 0)
        -:  249:{
        -:  250:}
        -:  251:
        -:  252:}  // std
        -:  253:
        -:  254:#endif  // _LIBCPP_EXCEPTION
