        -:    0:Source:/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/future
        -:    0:Graph:/Users/wjp/Desktop/workspace/libasync/libasync/build/tests/CMakeFiles/tests.dir/ChaseLevDequeTOT.cc.gcno
        -:    0:Data:/Users/wjp/Desktop/workspace/libasync/libasync/build/tests/CMakeFiles/tests.dir/ChaseLevDequeTOT.cc.gcda
        -:    0:Runs:2
        -:    0:Programs:1
        -:    1:// -*- C++ -*-
        -:    2://===--------------------------- future -----------------------------------===//
        -:    3://
        -:    4://                     The LLVM Compiler Infrastructure
        -:    5://
        -:    6:// This file is dual licensed under the MIT and the University of Illinois Open
        -:    7:// Source Licenses. See LICENSE.TXT for details.
        -:    8://
        -:    9://===----------------------------------------------------------------------===//
        -:   10:
        -:   11:#ifndef _LIBCPP_FUTURE
        -:   12:#define _LIBCPP_FUTURE
        -:   13:
        -:   14:/*
        -:   15:    future synopsis
        -:   16:
        -:   17:namespace std
        -:   18:{
        -:   19:
        -:   20:enum class future_errc
        -:   21:{
        -:   22:    future_already_retrieved = 1,
        -:   23:    promise_already_satisfied,
        -:   24:    no_state,
        -:   25:    broken_promise
        -:   26:};
        -:   27:
        -:   28:enum class launch
        -:   29:{
        -:   30:    async = 1,
        -:   31:    deferred = 2,
        -:   32:    any = async | deferred
        -:   33:};
        -:   34:
        -:   35:enum class future_status
        -:   36:{
        -:   37:    ready,
        -:   38:    timeout,
        -:   39:    deferred
        -:   40:};
        -:   41:
        -:   42:template <> struct is_error_code_enum<future_errc> : public true_type { };
        -:   43:error_code make_error_code(future_errc e) noexcept;
        -:   44:error_condition make_error_condition(future_errc e) noexcept;
        -:   45:
        -:   46:const error_category& future_category() noexcept;
        -:   47:
        -:   48:class future_error
        -:   49:    : public logic_error
        -:   50:{
        -:   51:public:
        -:   52:    future_error(error_code ec);  // exposition only
        -:   53:
        -:   54:    const error_code& code() const noexcept;
        -:   55:    const char*       what() const noexcept;
        -:   56:};
        -:   57:
        -:   58:template <class R>
        -:   59:class promise
        -:   60:{
        -:   61:public:
        -:   62:    promise();
        -:   63:    template <class Allocator>
        -:   64:        promise(allocator_arg_t, const Allocator& a);
        -:   65:    promise(promise&& rhs) noexcept;
        -:   66:    promise(const promise& rhs) = delete;
        -:   67:    ~promise();
        -:   68:
        -:   69:    // assignment
        -:   70:    promise& operator=(promise&& rhs) noexcept;
        -:   71:    promise& operator=(const promise& rhs) = delete;
        -:   72:    void swap(promise& other) noexcept;
        -:   73:
        -:   74:    // retrieving the result
        -:   75:    future<R> get_future();
        -:   76:
        -:   77:    // setting the result
        -:   78:    void set_value(const R& r);
        -:   79:    void set_value(R&& r);
        -:   80:    void set_exception(exception_ptr p);
        -:   81:
        -:   82:    // setting the result with deferred notification
        -:   83:    void set_value_at_thread_exit(const R& r);
        -:   84:    void set_value_at_thread_exit(R&& r);
        -:   85:    void set_exception_at_thread_exit(exception_ptr p);
        -:   86:};
        -:   87:
        -:   88:template <class R>
        -:   89:class promise<R&>
        -:   90:{
        -:   91:public:
        -:   92:    promise();
        -:   93:    template <class Allocator>
        -:   94:        promise(allocator_arg_t, const Allocator& a);
        -:   95:    promise(promise&& rhs) noexcept;
        -:   96:    promise(const promise& rhs) = delete;
        -:   97:    ~promise();
        -:   98:
        -:   99:    // assignment
        -:  100:    promise& operator=(promise&& rhs) noexcept;
        -:  101:    promise& operator=(const promise& rhs) = delete;
        -:  102:    void swap(promise& other) noexcept;
        -:  103:
        -:  104:    // retrieving the result
        -:  105:    future<R&> get_future();
        -:  106:
        -:  107:    // setting the result
        -:  108:    void set_value(R& r);
        -:  109:    void set_exception(exception_ptr p);
        -:  110:
        -:  111:    // setting the result with deferred notification
        -:  112:    void set_value_at_thread_exit(R&);
        -:  113:    void set_exception_at_thread_exit(exception_ptr p);
        -:  114:};
        -:  115:
        -:  116:template <>
        -:  117:class promise<void>
        -:  118:{
        -:  119:public:
        -:  120:    promise();
        -:  121:    template <class Allocator>
        -:  122:        promise(allocator_arg_t, const Allocator& a);
        -:  123:    promise(promise&& rhs) noexcept;
        -:  124:    promise(const promise& rhs) = delete;
        -:  125:    ~promise();
        -:  126:
        -:  127:    // assignment
        -:  128:    promise& operator=(promise&& rhs) noexcept;
        -:  129:    promise& operator=(const promise& rhs) = delete;
        -:  130:    void swap(promise& other) noexcept;
        -:  131:
        -:  132:    // retrieving the result
        -:  133:    future<void> get_future();
        -:  134:
        -:  135:    // setting the result
        -:  136:    void set_value();
        -:  137:    void set_exception(exception_ptr p);
        -:  138:
        -:  139:    // setting the result with deferred notification
        -:  140:    void set_value_at_thread_exit();
        -:  141:    void set_exception_at_thread_exit(exception_ptr p);
        -:  142:};
        -:  143:
        -:  144:template <class R> void swap(promise<R>& x, promise<R>& y) noexcept;
        -:  145:
        -:  146:template <class R, class Alloc>
        -:  147:    struct uses_allocator<promise<R>, Alloc> : public true_type {};
        -:  148:
        -:  149:template <class R>
        -:  150:class future
        -:  151:{
        -:  152:public:
        -:  153:    future() noexcept;
        -:  154:    future(future&&) noexcept;
        -:  155:    future(const future& rhs) = delete;
        -:  156:    ~future();
        -:  157:    future& operator=(const future& rhs) = delete;
        -:  158:    future& operator=(future&&) noexcept;
        -:  159:    shared_future<R> share();
        -:  160:
        -:  161:    // retrieving the value
        -:  162:    R get();
        -:  163:
        -:  164:    // functions to check state
        -:  165:    bool valid() const noexcept;
        -:  166:
        -:  167:    void wait() const;
        -:  168:    template <class Rep, class Period>
        -:  169:        future_status
        -:  170:        wait_for(const chrono::duration<Rep, Period>& rel_time) const;
        -:  171:    template <class Clock, class Duration>
        -:  172:        future_status
        -:  173:        wait_until(const chrono::time_point<Clock, Duration>& abs_time) const;
        -:  174:};
        -:  175:
        -:  176:template <class R>
        -:  177:class future<R&>
        -:  178:{
        -:  179:public:
        -:  180:    future() noexcept;
        -:  181:    future(future&&) noexcept;
        -:  182:    future(const future& rhs) = delete;
        -:  183:    ~future();
        -:  184:    future& operator=(const future& rhs) = delete;
        -:  185:    future& operator=(future&&) noexcept;
        -:  186:    shared_future<R&> share();
        -:  187:
        -:  188:    // retrieving the value
        -:  189:    R& get();
        -:  190:
        -:  191:    // functions to check state
        -:  192:    bool valid() const noexcept;
        -:  193:
        -:  194:    void wait() const;
        -:  195:    template <class Rep, class Period>
        -:  196:        future_status
        -:  197:        wait_for(const chrono::duration<Rep, Period>& rel_time) const;
        -:  198:    template <class Clock, class Duration>
        -:  199:        future_status
        -:  200:        wait_until(const chrono::time_point<Clock, Duration>& abs_time) const;
        -:  201:};
        -:  202:
        -:  203:template <>
        -:  204:class future<void>
        -:  205:{
        -:  206:public:
        -:  207:    future() noexcept;
        -:  208:    future(future&&) noexcept;
        -:  209:    future(const future& rhs) = delete;
        -:  210:    ~future();
        -:  211:    future& operator=(const future& rhs) = delete;
        -:  212:    future& operator=(future&&) noexcept;
        -:  213:    shared_future<void> share();
        -:  214:
        -:  215:    // retrieving the value
        -:  216:    void get();
        -:  217:
        -:  218:    // functions to check state
        -:  219:    bool valid() const noexcept;
        -:  220:
        -:  221:    void wait() const;
        -:  222:    template <class Rep, class Period>
        -:  223:        future_status
        -:  224:        wait_for(const chrono::duration<Rep, Period>& rel_time) const;
        -:  225:    template <class Clock, class Duration>
        -:  226:        future_status
        -:  227:        wait_until(const chrono::time_point<Clock, Duration>& abs_time) const;
        -:  228:};
        -:  229:
        -:  230:template <class R>
        -:  231:class shared_future
        -:  232:{
        -:  233:public:
        -:  234:    shared_future() noexcept;
        -:  235:    shared_future(const shared_future& rhs);
        -:  236:    shared_future(future<R>&&) noexcept;
        -:  237:    shared_future(shared_future&& rhs) noexcept;
        -:  238:    ~shared_future();
        -:  239:    shared_future& operator=(const shared_future& rhs);
        -:  240:    shared_future& operator=(shared_future&& rhs) noexcept;
        -:  241:
        -:  242:    // retrieving the value
        -:  243:    const R& get() const;
        -:  244:
        -:  245:    // functions to check state
        -:  246:    bool valid() const noexcept;
        -:  247:
        -:  248:    void wait() const;
        -:  249:    template <class Rep, class Period>
        -:  250:        future_status
        -:  251:        wait_for(const chrono::duration<Rep, Period>& rel_time) const;
        -:  252:    template <class Clock, class Duration>
        -:  253:        future_status
        -:  254:        wait_until(const chrono::time_point<Clock, Duration>& abs_time) const;
        -:  255:};
        -:  256:
        -:  257:template <class R>
        -:  258:class shared_future<R&>
        -:  259:{
        -:  260:public:
        -:  261:    shared_future() noexcept;
        -:  262:    shared_future(const shared_future& rhs);
        -:  263:    shared_future(future<R&>&&) noexcept;
        -:  264:    shared_future(shared_future&& rhs) noexcept;
        -:  265:    ~shared_future();
        -:  266:    shared_future& operator=(const shared_future& rhs);
        -:  267:    shared_future& operator=(shared_future&& rhs) noexcept;
        -:  268:
        -:  269:    // retrieving the value
        -:  270:    R& get() const;
        -:  271:
        -:  272:    // functions to check state
        -:  273:    bool valid() const noexcept;
        -:  274:
        -:  275:    void wait() const;
        -:  276:    template <class Rep, class Period>
        -:  277:        future_status
        -:  278:        wait_for(const chrono::duration<Rep, Period>& rel_time) const;
        -:  279:    template <class Clock, class Duration>
        -:  280:        future_status
        -:  281:        wait_until(const chrono::time_point<Clock, Duration>& abs_time) const;
        -:  282:};
        -:  283:
        -:  284:template <>
        -:  285:class shared_future<void>
        -:  286:{
        -:  287:public:
        -:  288:    shared_future() noexcept;
        -:  289:    shared_future(const shared_future& rhs);
        -:  290:    shared_future(future<void>&&) noexcept;
        -:  291:    shared_future(shared_future&& rhs) noexcept;
        -:  292:    ~shared_future();
        -:  293:    shared_future& operator=(const shared_future& rhs);
        -:  294:    shared_future& operator=(shared_future&& rhs) noexcept;
        -:  295:
        -:  296:    // retrieving the value
        -:  297:    void get() const;
        -:  298:
        -:  299:    // functions to check state
        -:  300:    bool valid() const noexcept;
        -:  301:
        -:  302:    void wait() const;
        -:  303:    template <class Rep, class Period>
        -:  304:        future_status
        -:  305:        wait_for(const chrono::duration<Rep, Period>& rel_time) const;
        -:  306:    template <class Clock, class Duration>
        -:  307:        future_status
        -:  308:        wait_until(const chrono::time_point<Clock, Duration>& abs_time) const;
        -:  309:};
        -:  310:
        -:  311:template <class F, class... Args>
        -:  312:  future<typename result_of<typename decay<F>::type(typename decay<Args>::type...)>::type>
        -:  313:  async(F&& f, Args&&... args);
        -:  314:
        -:  315:template <class F, class... Args>
        -:  316:  future<typename result_of<typename decay<F>::type(typename decay<Args>::type...)>::type>
        -:  317:  async(launch policy, F&& f, Args&&... args);
        -:  318:
        -:  319:template <class> class packaged_task; // undefined
        -:  320:
        -:  321:template <class R, class... ArgTypes>
        -:  322:class packaged_task<R(ArgTypes...)>
        -:  323:{
        -:  324:public:
        -:  325:    typedef R result_type;
        -:  326:
        -:  327:    // construction and destruction
        -:  328:    packaged_task() noexcept;
        -:  329:    template <class F>
        -:  330:        explicit packaged_task(F&& f);
        -:  331:    template <class F, class Allocator>
        -:  332:        packaged_task(allocator_arg_t, const Allocator& a, F&& f);
        -:  333:    ~packaged_task();
        -:  334:
        -:  335:    // no copy
        -:  336:    packaged_task(const packaged_task&) = delete;
        -:  337:    packaged_task& operator=(const packaged_task&) = delete;
        -:  338:
        -:  339:    // move support
        -:  340:    packaged_task(packaged_task&& other) noexcept;
        -:  341:    packaged_task& operator=(packaged_task&& other) noexcept;
        -:  342:    void swap(packaged_task& other) noexcept;
        -:  343:
        -:  344:    bool valid() const noexcept;
        -:  345:
        -:  346:    // result retrieval
        -:  347:    future<R> get_future();
        -:  348:
        -:  349:    // execution
        -:  350:    void operator()(ArgTypes... );
        -:  351:    void make_ready_at_thread_exit(ArgTypes...);
        -:  352:
        -:  353:    void reset();
        -:  354:};
        -:  355:
        -:  356:template <class R>
        -:  357:  void swap(packaged_task<R(ArgTypes...)&, packaged_task<R(ArgTypes...)>&) noexcept;
        -:  358:
        -:  359:template <class R, class Alloc> struct uses_allocator<packaged_task<R>, Alloc>;
        -:  360:
        -:  361:}  // std
        -:  362:
        -:  363:*/
        -:  364:
        -:  365:#include <__config>
        -:  366:#include <system_error>
        -:  367:#include <memory>
        -:  368:#include <chrono>
        -:  369:#include <exception>
        -:  370:#include <mutex>
        -:  371:#include <thread>
        -:  372:
        -:  373:#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
        -:  374:#pragma GCC system_header
        -:  375:#endif
        -:  376:
        -:  377:#ifdef _LIBCPP_HAS_NO_THREADS
        -:  378:#error <future> is not supported on this single threaded system
        -:  379:#else // !_LIBCPP_HAS_NO_THREADS
        -:  380:
        -:  381:_LIBCPP_BEGIN_NAMESPACE_STD
        -:  382:
        -:  383://enum class future_errc
        -:  384:_LIBCPP_DECLARE_STRONG_ENUM(future_errc)
        -:  385:{
        -:  386:    future_already_retrieved = 1,
        -:  387:    promise_already_satisfied,
        -:  388:    no_state,
        -:  389:    broken_promise
        -:  390:};
        -:  391:_LIBCPP_DECLARE_STRONG_ENUM_EPILOG(future_errc)
        -:  392:
        -:  393:template <>
        -:  394:struct _LIBCPP_TYPE_VIS_ONLY is_error_code_enum<future_errc> : public true_type {};
        -:  395:
        -:  396:#ifdef _LIBCPP_HAS_NO_STRONG_ENUMS
        -:  397:template <>
        -:  398:struct _LIBCPP_TYPE_VIS_ONLY is_error_code_enum<future_errc::__lx> : public true_type { };
        -:  399:#endif
        -:  400:
        -:  401://enum class launch
        -:  402:_LIBCPP_DECLARE_STRONG_ENUM(launch)
        -:  403:{
        -:  404:    async = 1,
        -:  405:    deferred = 2,
        -:  406:    any = async | deferred
        -:  407:};
        -:  408:_LIBCPP_DECLARE_STRONG_ENUM_EPILOG(launch)
        -:  409:
        -:  410:#ifndef _LIBCPP_HAS_NO_STRONG_ENUMS
        -:  411:
        -:  412:#ifdef _LIBCXX_UNDERLYING_TYPE
        -:  413:typedef underlying_type<launch>::type __launch_underlying_type;
        -:  414:#else
        -:  415:typedef int __launch_underlying_type;
        -:  416:#endif
        -:  417:
        -:  418:inline _LIBCPP_INLINE_VISIBILITY
        -:  419:_LIBCPP_CONSTEXPR
        -:  420:launch
        -:  421:operator&(launch __x, launch __y)
        -:  422:{
        -:  423:    return static_cast<launch>(static_cast<__launch_underlying_type>(__x) &
        -:  424:                               static_cast<__launch_underlying_type>(__y));
        -:  425:}
        -:  426:
        -:  427:inline _LIBCPP_INLINE_VISIBILITY
        -:  428:_LIBCPP_CONSTEXPR
        -:  429:launch
        -:  430:operator|(launch __x, launch __y)
        -:  431:{
        -:  432:    return static_cast<launch>(static_cast<__launch_underlying_type>(__x) |
        -:  433:                               static_cast<__launch_underlying_type>(__y));
        -:  434:}
        -:  435:
        -:  436:inline _LIBCPP_INLINE_VISIBILITY
        -:  437:_LIBCPP_CONSTEXPR
        -:  438:launch
        -:  439:operator^(launch __x, launch __y)
        -:  440:{
        -:  441:    return static_cast<launch>(static_cast<__launch_underlying_type>(__x) ^
        -:  442:                               static_cast<__launch_underlying_type>(__y));
        -:  443:}
        -:  444:
        -:  445:inline _LIBCPP_INLINE_VISIBILITY
        -:  446:_LIBCPP_CONSTEXPR
        -:  447:launch
        -:  448:operator~(launch __x)
        -:  449:{
        -:  450:    return static_cast<launch>(~static_cast<__launch_underlying_type>(__x) & 3);
        -:  451:}
        -:  452:
        -:  453:inline _LIBCPP_INLINE_VISIBILITY
        -:  454:launch&
        -:  455:operator&=(launch& __x, launch __y)
        -:  456:{
        -:  457:    __x = __x & __y; return __x;
        -:  458:}
        -:  459:
        -:  460:inline _LIBCPP_INLINE_VISIBILITY
        -:  461:launch&
        -:  462:operator|=(launch& __x, launch __y)
        -:  463:{
        -:  464:    __x = __x | __y; return __x;
        -:  465:}
        -:  466:
        -:  467:inline _LIBCPP_INLINE_VISIBILITY
        -:  468:launch&
        -:  469:operator^=(launch& __x, launch __y)
        -:  470:{
        -:  471:    __x = __x ^ __y; return __x;
        -:  472:}
        -:  473:
        -:  474:#endif  // !_LIBCPP_HAS_NO_STRONG_ENUMS
        -:  475:
        -:  476://enum class future_status
        -:  477:_LIBCPP_DECLARE_STRONG_ENUM(future_status)
        -:  478:{
        -:  479:    ready,
        -:  480:    timeout,
        -:  481:    deferred
        -:  482:};
        -:  483:_LIBCPP_DECLARE_STRONG_ENUM_EPILOG(future_status)
        -:  484:
        -:  485:_LIBCPP_FUNC_VIS
        -:  486:const error_category& future_category() _NOEXCEPT;
        -:  487:
        -:  488:inline _LIBCPP_INLINE_VISIBILITY
        -:  489:error_code
        -:  490:make_error_code(future_errc __e) _NOEXCEPT
        -:  491:{
    #####:  492:    return error_code(static_cast<int>(__e), future_category());
        -:  493:}
        -:  494:
        -:  495:inline _LIBCPP_INLINE_VISIBILITY
        -:  496:error_condition
        -:  497:make_error_condition(future_errc __e) _NOEXCEPT
        -:  498:{
        -:  499:    return error_condition(static_cast<int>(__e), future_category());
        -:  500:}
        -:  501:
        -:  502:class _LIBCPP_EXCEPTION_ABI _LIBCPP_AVAILABILITY_FUTURE_ERROR future_error
        -:  503:    : public logic_error
        -:  504:{
        -:  505:    error_code __ec_;
        -:  506:public:
        -:  507:    future_error(error_code __ec);
        -:  508:
        -:  509:    _LIBCPP_INLINE_VISIBILITY
        -:  510:    const error_code& code() const _NOEXCEPT {return __ec_;}
        -:  511:
        -:  512:    virtual ~future_error() _NOEXCEPT;
        -:  513:};
        -:  514:
       20:  515:class _LIBCPP_TYPE_VIS _LIBCPP_AVAILABILITY_FUTURE __assoc_sub_state
        -:  516:    : public __shared_count
        -:  517:{
        -:  518:protected:
        -:  519:    exception_ptr __exception_;
        -:  520:    mutable mutex __mut_;
        -:  521:    mutable condition_variable __cv_;
        -:  522:    unsigned __state_;
        -:  523:
        -:  524:    virtual void __on_zero_shared() _NOEXCEPT;
        -:  525:    void __sub_wait(unique_lock<mutex>& __lk);
        -:  526:public:
        -:  527:    enum
        -:  528:    {
        -:  529:        __constructed = 1,
        -:  530:        __future_attached = 2,
        -:  531:        ready = 4,
        -:  532:        deferred = 8
        -:  533:    };
        -:  534:
        -:  535:    _LIBCPP_INLINE_VISIBILITY
       40:  536:    __assoc_sub_state() : __state_(0) {}
        -:  537:
        -:  538:    _LIBCPP_INLINE_VISIBILITY
        -:  539:    bool __has_value() const
       97:  540:        {return (__state_ & __constructed) || (__exception_ != nullptr);}
        -:  541:
        -:  542:    _LIBCPP_INLINE_VISIBILITY
        -:  543:    void __set_future_attached()
        -:  544:    {
       20:  545:        lock_guard<mutex> __lk(__mut_);
       20:  546:        __state_ |= __future_attached;
       20:  547:    }
        -:  548:    _LIBCPP_INLINE_VISIBILITY
       20:  549:    bool __has_future_attached() const {return (__state_ & __future_attached) != 0;}
        -:  550:
        -:  551:    _LIBCPP_INLINE_VISIBILITY
    #####:  552:    void __set_deferred() {__state_ |= deferred;}
        -:  553:
        -:  554:    void __make_ready();
        -:  555:    _LIBCPP_INLINE_VISIBILITY
        -:  556:    bool __is_ready() const {return (__state_ & ready) != 0;}
        -:  557:
        -:  558:    void set_value();
        -:  559:    void set_value_at_thread_exit();
        -:  560:
        -:  561:    void set_exception(exception_ptr __p);
        -:  562:    void set_exception_at_thread_exit(exception_ptr __p);
        -:  563:
        -:  564:    void copy();
        -:  565:
        -:  566:    void wait();
        -:  567:    template <class _Rep, class _Period>
        -:  568:        future_status
        -:  569:        _LIBCPP_INLINE_VISIBILITY
        -:  570:        wait_for(const chrono::duration<_Rep, _Period>& __rel_time) const;
        -:  571:    template <class _Clock, class _Duration>
        -:  572:        future_status
        -:  573:        wait_until(const chrono::time_point<_Clock, _Duration>& __abs_time) const;
        -:  574:
        -:  575:    virtual void __execute();
        -:  576:};
        -:  577:
        -:  578:template <class _Clock, class _Duration>
        -:  579:future_status
        -:  580:__assoc_sub_state::wait_until(const chrono::time_point<_Clock, _Duration>& __abs_time) const
        -:  581:{
        -:  582:    unique_lock<mutex> __lk(__mut_);
        -:  583:    if (__state_ & deferred)
        -:  584:        return future_status::deferred;
        -:  585:    while (!(__state_ & ready) && _Clock::now() < __abs_time)
        -:  586:        __cv_.wait_until(__lk, __abs_time);
        -:  587:    if (__state_ & ready)
        -:  588:        return future_status::ready;
        -:  589:    return future_status::timeout;
        -:  590:}
        -:  591:
        -:  592:template <class _Rep, class _Period>
        -:  593:inline
        -:  594:future_status
        -:  595:__assoc_sub_state::wait_for(const chrono::duration<_Rep, _Period>& __rel_time) const
        -:  596:{
        -:  597:    return wait_until(chrono::steady_clock::now() + __rel_time);
        -:  598:}
        -:  599:
        -:  600:template <class _Rp>
       40:  601:class _LIBCPP_AVAILABILITY_FUTURE __assoc_state
        -:  602:    : public __assoc_sub_state
        -:  603:{
        -:  604:    typedef __assoc_sub_state base;
        -:  605:    typedef typename aligned_storage<sizeof(_Rp), alignment_of<_Rp>::value>::type _Up;
        -:  606:protected:
        -:  607:    _Up __value_;
        -:  608:
        -:  609:    virtual void __on_zero_shared() _NOEXCEPT;
        -:  610:public:
        -:  611:
        -:  612:    template <class _Arg>
        -:  613:#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -:  614:        void set_value(_Arg&& __arg);
        -:  615:#else
        -:  616:        void set_value(_Arg& __arg);
        -:  617:#endif
        -:  618:
        -:  619:    template <class _Arg>
        -:  620:#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -:  621:        void set_value_at_thread_exit(_Arg&& __arg);
        -:  622:#else
        -:  623:        void set_value_at_thread_exit(_Arg& __arg);
        -:  624:#endif
        -:  625:
        -:  626:    _Rp move();
        -:  627:    typename add_lvalue_reference<_Rp>::type copy();
        -:  628:};
        -:  629:
        -:  630:template <class _Rp>
        -:  631:void
        -:  632:__assoc_state<_Rp>::__on_zero_shared() _NOEXCEPT
        -:  633:{
       20:  634:    if (this->__state_ & base::__constructed)
       20:  635:        reinterpret_cast<_Rp*>(&__value_)->~_Rp();
       40:  636:    delete this;
       20:  637:}
        -:  638:
        -:  639:template <class _Rp>
        -:  640:template <class _Arg>
        -:  641:_LIBCPP_AVAILABILITY_FUTURE
        -:  642:void
        -:  643:#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -:  644:__assoc_state<_Rp>::set_value(_Arg&& __arg)
        -:  645:#else
        -:  646:__assoc_state<_Rp>::set_value(_Arg& __arg)
        -:  647:#endif
        -:  648:{
       19:  649:    unique_lock<mutex> __lk(this->__mut_);
        -:  650:#ifndef _LIBCPP_NO_EXCEPTIONS
       38:  651:    if (this->__has_value())
    #####:  652:        throw future_error(make_error_code(future_errc::promise_already_satisfied));
        -:  653:#endif
       19:  654:    ::new(&__value_) _Rp(_VSTD::forward<_Arg>(__arg));
       19:  655:    this->__state_ |= base::__constructed | base::ready;
       19:  656:    __cv_.notify_all();
       19:  657:}
        -:  658:
        -:  659:template <class _Rp>
        -:  660:template <class _Arg>
        -:  661:void
        -:  662:#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -:  663:__assoc_state<_Rp>::set_value_at_thread_exit(_Arg&& __arg)
        -:  664:#else
        -:  665:__assoc_state<_Rp>::set_value_at_thread_exit(_Arg& __arg)
        -:  666:#endif
        -:  667:{
        -:  668:    unique_lock<mutex> __lk(this->__mut_);
        -:  669:#ifndef _LIBCPP_NO_EXCEPTIONS
        -:  670:    if (this->__has_value())
        -:  671:        throw future_error(make_error_code(future_errc::promise_already_satisfied));
        -:  672:#endif
        -:  673:    ::new(&__value_) _Rp(_VSTD::forward<_Arg>(__arg));
        -:  674:    this->__state_ |= base::__constructed;
        -:  675:    __thread_local_data()->__make_ready_at_thread_exit(this);
        -:  676:}
        -:  677:
        -:  678:template <class _Rp>
        -:  679:_Rp
        -:  680:__assoc_state<_Rp>::move()
        -:  681:{
       20:  682:    unique_lock<mutex> __lk(this->__mut_);
       20:  683:    this->__sub_wait(__lk);
       20:  684:    if (this->__exception_ != nullptr)
    #####:  685:        rethrow_exception(this->__exception_);
       20:  686:    return _VSTD::move(*reinterpret_cast<_Rp*>(&__value_));
       20:  687:}
        -:  688:
        -:  689:template <class _Rp>
        -:  690:typename add_lvalue_reference<_Rp>::type
        -:  691:__assoc_state<_Rp>::copy()
        -:  692:{
        -:  693:    unique_lock<mutex> __lk(this->__mut_);
        -:  694:    this->__sub_wait(__lk);
        -:  695:    if (this->__exception_ != nullptr)
        -:  696:        rethrow_exception(this->__exception_);
        -:  697:    return *reinterpret_cast<_Rp*>(&__value_);
        -:  698:}
        -:  699:
        -:  700:template <class _Rp>
        -:  701:class _LIBCPP_AVAILABILITY_FUTURE __assoc_state<_Rp&>
        -:  702:    : public __assoc_sub_state
        -:  703:{
        -:  704:    typedef __assoc_sub_state base;
        -:  705:    typedef _Rp* _Up;
        -:  706:protected:
        -:  707:    _Up __value_;
        -:  708:
        -:  709:    virtual void __on_zero_shared() _NOEXCEPT;
        -:  710:public:
        -:  711:
        -:  712:    void set_value(_Rp& __arg);
        -:  713:    void set_value_at_thread_exit(_Rp& __arg);
        -:  714:
        -:  715:    _Rp& copy();
        -:  716:};
        -:  717:
        -:  718:template <class _Rp>
        -:  719:void
        -:  720:__assoc_state<_Rp&>::__on_zero_shared() _NOEXCEPT
        -:  721:{
        -:  722:    delete this;
        -:  723:}
        -:  724:
        -:  725:template <class _Rp>
        -:  726:void
        -:  727:__assoc_state<_Rp&>::set_value(_Rp& __arg)
        -:  728:{
        -:  729:    unique_lock<mutex> __lk(this->__mut_);
        -:  730:#ifndef _LIBCPP_NO_EXCEPTIONS
        -:  731:    if (this->__has_value())
        -:  732:        throw future_error(make_error_code(future_errc::promise_already_satisfied));
        -:  733:#endif
        -:  734:    __value_ = _VSTD::addressof(__arg);
        -:  735:    this->__state_ |= base::__constructed | base::ready;
        -:  736:    __cv_.notify_all();
        -:  737:}
        -:  738:
        -:  739:template <class _Rp>
        -:  740:void
        -:  741:__assoc_state<_Rp&>::set_value_at_thread_exit(_Rp& __arg)
        -:  742:{
        -:  743:    unique_lock<mutex> __lk(this->__mut_);
        -:  744:#ifndef _LIBCPP_NO_EXCEPTIONS
        -:  745:    if (this->__has_value())
        -:  746:        throw future_error(make_error_code(future_errc::promise_already_satisfied));
        -:  747:#endif
        -:  748:    __value_ = _VSTD::addressof(__arg);
        -:  749:    this->__state_ |= base::__constructed;
        -:  750:    __thread_local_data()->__make_ready_at_thread_exit(this);
        -:  751:}
        -:  752:
        -:  753:template <class _Rp>
        -:  754:_Rp&
        -:  755:__assoc_state<_Rp&>::copy()
        -:  756:{
        -:  757:    unique_lock<mutex> __lk(this->__mut_);
        -:  758:    this->__sub_wait(__lk);
        -:  759:    if (this->__exception_ != nullptr)
        -:  760:        rethrow_exception(this->__exception_);
        -:  761:    return *__value_;
        -:  762:}
        -:  763:
        -:  764:template <class _Rp, class _Alloc>
        -:  765:class _LIBCPP_AVAILABILITY_FUTURE __assoc_state_alloc
        -:  766:    : public __assoc_state<_Rp>
        -:  767:{
        -:  768:    typedef __assoc_state<_Rp> base;
        -:  769:    _Alloc __alloc_;
        -:  770:
        -:  771:    virtual void __on_zero_shared() _NOEXCEPT;
        -:  772:public:
        -:  773:    _LIBCPP_INLINE_VISIBILITY
        -:  774:    explicit __assoc_state_alloc(const _Alloc& __a)
        -:  775:        : __alloc_(__a) {}
        -:  776:};
        -:  777:
        -:  778:template <class _Rp, class _Alloc>
        -:  779:void
        -:  780:__assoc_state_alloc<_Rp, _Alloc>::__on_zero_shared() _NOEXCEPT
        -:  781:{
        -:  782:    if (this->__state_ & base::__constructed)
        -:  783:        reinterpret_cast<_Rp*>(_VSTD::addressof(this->__value_))->~_Rp();
        -:  784:    typedef typename __allocator_traits_rebind<_Alloc, __assoc_state_alloc>::type _Al;
        -:  785:    typedef allocator_traits<_Al> _ATraits;
        -:  786:    typedef pointer_traits<typename _ATraits::pointer> _PTraits;
        -:  787:    _Al __a(__alloc_);
        -:  788:    this->~__assoc_state_alloc();
        -:  789:    __a.deallocate(_PTraits::pointer_to(*this), 1);
        -:  790:}
        -:  791:
        -:  792:template <class _Rp, class _Alloc>
        -:  793:class _LIBCPP_AVAILABILITY_FUTURE __assoc_state_alloc<_Rp&, _Alloc>
        -:  794:    : public __assoc_state<_Rp&>
        -:  795:{
        -:  796:    typedef __assoc_state<_Rp&> base;
        -:  797:    _Alloc __alloc_;
        -:  798:
        -:  799:    virtual void __on_zero_shared() _NOEXCEPT;
        -:  800:public:
        -:  801:    _LIBCPP_INLINE_VISIBILITY
        -:  802:    explicit __assoc_state_alloc(const _Alloc& __a)
        -:  803:        : __alloc_(__a) {}
        -:  804:};
        -:  805:
        -:  806:template <class _Rp, class _Alloc>
        -:  807:void
        -:  808:__assoc_state_alloc<_Rp&, _Alloc>::__on_zero_shared() _NOEXCEPT
        -:  809:{
        -:  810:    typedef typename __allocator_traits_rebind<_Alloc, __assoc_state_alloc>::type _Al;
        -:  811:    typedef allocator_traits<_Al> _ATraits;
        -:  812:    typedef pointer_traits<typename _ATraits::pointer> _PTraits;
        -:  813:    _Al __a(__alloc_);
        -:  814:    this->~__assoc_state_alloc();
        -:  815:    __a.deallocate(_PTraits::pointer_to(*this), 1);
        -:  816:}
        -:  817:
        -:  818:template <class _Alloc>
        -:  819:class _LIBCPP_AVAILABILITY_FUTURE __assoc_sub_state_alloc
        -:  820:    : public __assoc_sub_state
        -:  821:{
        -:  822:    typedef __assoc_sub_state base;
        -:  823:    _Alloc __alloc_;
        -:  824:
        -:  825:    virtual void __on_zero_shared() _NOEXCEPT;
        -:  826:public:
        -:  827:    _LIBCPP_INLINE_VISIBILITY
        -:  828:    explicit __assoc_sub_state_alloc(const _Alloc& __a)
        -:  829:        : __alloc_(__a) {}
        -:  830:};
        -:  831:
        -:  832:template <class _Alloc>
        -:  833:void
        -:  834:__assoc_sub_state_alloc<_Alloc>::__on_zero_shared() _NOEXCEPT
        -:  835:{
        -:  836:    typedef typename __allocator_traits_rebind<_Alloc, __assoc_sub_state_alloc>::type _Al;
        -:  837:    typedef allocator_traits<_Al> _ATraits;
        -:  838:    typedef pointer_traits<typename _ATraits::pointer> _PTraits;
        -:  839:    _Al __a(__alloc_);
        -:  840:    this->~__assoc_sub_state_alloc();
        -:  841:    __a.deallocate(_PTraits::pointer_to(*this), 1);
        -:  842:}
        -:  843:
        -:  844:template <class _Rp, class _Fp>
    #####:  845:class _LIBCPP_AVAILABILITY_FUTURE __deferred_assoc_state
        -:  846:    : public __assoc_state<_Rp>
        -:  847:{
        -:  848:    typedef __assoc_state<_Rp> base;
        -:  849:
        -:  850:    _Fp __func_;
        -:  851:
        -:  852:public:
        -:  853:#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -:  854:    _LIBCPP_INLINE_VISIBILITY
    #####:  855:    explicit __deferred_assoc_state(_Fp&& __f);
        -:  856:#endif
        -:  857:
        -:  858:    virtual void __execute();
        -:  859:};
        -:  860:
        -:  861:#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -:  862:
        -:  863:template <class _Rp, class _Fp>
        -:  864:inline
        -:  865:__deferred_assoc_state<_Rp, _Fp>::__deferred_assoc_state(_Fp&& __f)
    #####:  866:    : __func_(_VSTD::forward<_Fp>(__f))
    #####:  867:{
    #####:  868:    this->__set_deferred();
    #####:  869:}
        -:  870:
        -:  871:#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -:  872:
        -:  873:template <class _Rp, class _Fp>
        -:  874:void
        -:  875:__deferred_assoc_state<_Rp, _Fp>::__execute()
        -:  876:{
        -:  877:#ifndef _LIBCPP_NO_EXCEPTIONS
        -:  878:    try
        -:  879:    {
        -:  880:#endif  // _LIBCPP_NO_EXCEPTIONS
    #####:  881:        this->set_value(__func_());
        -:  882:#ifndef _LIBCPP_NO_EXCEPTIONS
    #####:  883:    }
        -:  884:    catch (...)
        -:  885:    {
    #####:  886:        this->set_exception(current_exception());
    #####:  887:    }
        -:  888:#endif  // _LIBCPP_NO_EXCEPTIONS
    #####:  889:}
        -:  890:
        -:  891:template <class _Fp>
        -:  892:class _LIBCPP_AVAILABILITY_FUTURE __deferred_assoc_state<void, _Fp>
        -:  893:    : public __assoc_sub_state
        -:  894:{
        -:  895:    typedef __assoc_sub_state base;
        -:  896:
        -:  897:    _Fp __func_;
        -:  898:
        -:  899:public:
        -:  900:#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -:  901:    _LIBCPP_INLINE_VISIBILITY
        -:  902:    explicit __deferred_assoc_state(_Fp&& __f);
        -:  903:#endif
        -:  904:
        -:  905:    virtual void __execute();
        -:  906:};
        -:  907:
        -:  908:#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -:  909:
        -:  910:template <class _Fp>
        -:  911:inline
        -:  912:__deferred_assoc_state<void, _Fp>::__deferred_assoc_state(_Fp&& __f)
        -:  913:    : __func_(_VSTD::forward<_Fp>(__f))
        -:  914:{
        -:  915:    this->__set_deferred();
        -:  916:}
        -:  917:
        -:  918:#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -:  919:
        -:  920:template <class _Fp>
        -:  921:void
        -:  922:__deferred_assoc_state<void, _Fp>::__execute()
        -:  923:{
        -:  924:#ifndef _LIBCPP_NO_EXCEPTIONS
        -:  925:    try
        -:  926:    {
        -:  927:#endif  // _LIBCPP_NO_EXCEPTIONS
        -:  928:        __func_();
        -:  929:        this->set_value();
        -:  930:#ifndef _LIBCPP_NO_EXCEPTIONS
        -:  931:    }
        -:  932:    catch (...)
        -:  933:    {
        -:  934:        this->set_exception(current_exception());
        -:  935:    }
        -:  936:#endif  // _LIBCPP_NO_EXCEPTIONS
        -:  937:}
        -:  938:
        -:  939:template <class _Rp, class _Fp>
       60:  940:class _LIBCPP_AVAILABILITY_FUTURE __async_assoc_state
        -:  941:    : public __assoc_state<_Rp>
        -:  942:{
        -:  943:    typedef __assoc_state<_Rp> base;
        -:  944:
        -:  945:    _Fp __func_;
        -:  946:
        -:  947:    virtual void __on_zero_shared() _NOEXCEPT;
        -:  948:public:
        -:  949:#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -:  950:    _LIBCPP_INLINE_VISIBILITY
       20:  951:    explicit __async_assoc_state(_Fp&& __f);
        -:  952:#endif
        -:  953:
        -:  954:    virtual void __execute();
        -:  955:};
        -:  956:
        -:  957:#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -:  958:
        -:  959:template <class _Rp, class _Fp>
        -:  960:inline
        -:  961:__async_assoc_state<_Rp, _Fp>::__async_assoc_state(_Fp&& __f)
       20:  962:    : __func_(_VSTD::forward<_Fp>(__f))
       60:  963:{
       40:  964:}
        -:  965:
        -:  966:#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -:  967:
        -:  968:template <class _Rp, class _Fp>
        -:  969:void
        -:  970:__async_assoc_state<_Rp, _Fp>::__execute()
        -:  971:{
        -:  972:#ifndef _LIBCPP_NO_EXCEPTIONS
        -:  973:    try
        -:  974:    {
        -:  975:#endif  // _LIBCPP_NO_EXCEPTIONS
       41:  976:        this->set_value(__func_());
        -:  977:#ifndef _LIBCPP_NO_EXCEPTIONS
       20:  978:    }
        -:  979:    catch (...)
        -:  980:    {
    #####:  981:        this->set_exception(current_exception());
    #####:  982:    }
        -:  983:#endif  // _LIBCPP_NO_EXCEPTIONS
       19:  984:}
        -:  985:
        -:  986:template <class _Rp, class _Fp>
        -:  987:void
        -:  988:__async_assoc_state<_Rp, _Fp>::__on_zero_shared() _NOEXCEPT
        -:  989:{
       20:  990:    this->wait();
       20:  991:    base::__on_zero_shared();
       20:  992:}
        -:  993:
        -:  994:template <class _Fp>
        -:  995:class _LIBCPP_AVAILABILITY_FUTURE __async_assoc_state<void, _Fp>
        -:  996:    : public __assoc_sub_state
        -:  997:{
        -:  998:    typedef __assoc_sub_state base;
        -:  999:
        -: 1000:    _Fp __func_;
        -: 1001:
        -: 1002:    virtual void __on_zero_shared() _NOEXCEPT;
        -: 1003:public:
        -: 1004:#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -: 1005:    _LIBCPP_INLINE_VISIBILITY
        -: 1006:    explicit __async_assoc_state(_Fp&& __f);
        -: 1007:#endif
        -: 1008:
        -: 1009:    virtual void __execute();
        -: 1010:};
        -: 1011:
        -: 1012:#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -: 1013:
        -: 1014:template <class _Fp>
        -: 1015:inline
        -: 1016:__async_assoc_state<void, _Fp>::__async_assoc_state(_Fp&& __f)
        -: 1017:    : __func_(_VSTD::forward<_Fp>(__f))
        -: 1018:{
        -: 1019:}
        -: 1020:
        -: 1021:#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -: 1022:
        -: 1023:template <class _Fp>
        -: 1024:void
        -: 1025:__async_assoc_state<void, _Fp>::__execute()
        -: 1026:{
        -: 1027:#ifndef _LIBCPP_NO_EXCEPTIONS
        -: 1028:    try
        -: 1029:    {
        -: 1030:#endif  // _LIBCPP_NO_EXCEPTIONS
        -: 1031:        __func_();
        -: 1032:        this->set_value();
        -: 1033:#ifndef _LIBCPP_NO_EXCEPTIONS
        -: 1034:    }
        -: 1035:    catch (...)
        -: 1036:    {
        -: 1037:        this->set_exception(current_exception());
        -: 1038:    }
        -: 1039:#endif  // _LIBCPP_NO_EXCEPTIONS
        -: 1040:}
        -: 1041:
        -: 1042:template <class _Fp>
        -: 1043:void
        -: 1044:__async_assoc_state<void, _Fp>::__on_zero_shared() _NOEXCEPT
        -: 1045:{
        -: 1046:    this->wait();
        -: 1047:    base::__on_zero_shared();
        -: 1048:}
        -: 1049:
        -: 1050:template <class _Rp> class _LIBCPP_TYPE_VIS_ONLY promise;
        -: 1051:template <class _Rp> class _LIBCPP_TYPE_VIS_ONLY shared_future;
        -: 1052:
        -: 1053:// future
        -: 1054:
        -: 1055:template <class _Rp> class _LIBCPP_TYPE_VIS_ONLY future;
        -: 1056:
        -: 1057:template <class _Rp, class _Fp>
        -: 1058:future<_Rp>
        -: 1059:#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -: 1060:__make_deferred_assoc_state(_Fp&& __f);
        -: 1061:#else
        -: 1062:__make_deferred_assoc_state(_Fp __f);
        -: 1063:#endif
        -: 1064:
        -: 1065:template <class _Rp, class _Fp>
        -: 1066:future<_Rp>
        -: 1067:#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -: 1068:__make_async_assoc_state(_Fp&& __f);
        -: 1069:#else
        -: 1070:__make_async_assoc_state(_Fp __f);
        -: 1071:#endif
        -: 1072:
        -: 1073:template <class _Rp>
        -: 1074:class _LIBCPP_TYPE_VIS_ONLY _LIBCPP_AVAILABILITY_FUTURE future
        -: 1075:{
        -: 1076:    __assoc_state<_Rp>* __state_;
        -: 1077:
        -: 1078:    explicit future(__assoc_state<_Rp>* __state);
        -: 1079:
        -: 1080:    template <class> friend class promise;
        -: 1081:    template <class> friend class shared_future;
        -: 1082:
        -: 1083:#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -: 1084:    template <class _R1, class _Fp>
        -: 1085:        friend future<_R1> __make_deferred_assoc_state(_Fp&& __f);
        -: 1086:    template <class _R1, class _Fp>
        -: 1087:        friend future<_R1> __make_async_assoc_state(_Fp&& __f);
        -: 1088:#else
        -: 1089:    template <class _R1, class _Fp>
        -: 1090:        friend future<_R1> __make_deferred_assoc_state(_Fp __f);
        -: 1091:    template <class _R1, class _Fp>
        -: 1092:        friend future<_R1> __make_async_assoc_state(_Fp __f);
        -: 1093:#endif
        -: 1094:
        -: 1095:public:
        -: 1096:    _LIBCPP_INLINE_VISIBILITY
    #####: 1097:    future() _NOEXCEPT : __state_(nullptr) {}
        -: 1098:#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -: 1099:    _LIBCPP_INLINE_VISIBILITY
        -: 1100:    future(future&& __rhs) _NOEXCEPT
      100: 1101:        : __state_(__rhs.__state_) {__rhs.__state_ = nullptr;}
        -: 1102:    future(const future&) = delete;
        -: 1103:    future& operator=(const future&) = delete;
        -: 1104:    _LIBCPP_INLINE_VISIBILITY
        -: 1105:    future& operator=(future&& __rhs) _NOEXCEPT
        -: 1106:        {
        -: 1107:            future(std::move(__rhs)).swap(*this);
        -: 1108:            return *this;
        -: 1109:        }
        -: 1110:#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -: 1111:private:
        -: 1112:    future(const future&);
        -: 1113:    future& operator=(const future&);
        -: 1114:public:
        -: 1115:#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -: 1116:    ~future();
        -: 1117:    _LIBCPP_INLINE_VISIBILITY
        -: 1118:    shared_future<_Rp> share();
        -: 1119:
        -: 1120:    // retrieving the value
        -: 1121:    _Rp get();
        -: 1122:
        -: 1123:    _LIBCPP_INLINE_VISIBILITY
        -: 1124:    void swap(future& __rhs) _NOEXCEPT {_VSTD::swap(__state_, __rhs.__state_);}
        -: 1125:
        -: 1126:    // functions to check state
        -: 1127:    _LIBCPP_INLINE_VISIBILITY
        -: 1128:    bool valid() const _NOEXCEPT {return __state_ != nullptr;}
        -: 1129:
        -: 1130:    _LIBCPP_INLINE_VISIBILITY
        -: 1131:    void wait() const {__state_->wait();}
        -: 1132:    template <class _Rep, class _Period>
        -: 1133:        _LIBCPP_INLINE_VISIBILITY
        -: 1134:        future_status
        -: 1135:        wait_for(const chrono::duration<_Rep, _Period>& __rel_time) const
        -: 1136:            {return __state_->wait_for(__rel_time);}
        -: 1137:    template <class _Clock, class _Duration>
        -: 1138:        _LIBCPP_INLINE_VISIBILITY
        -: 1139:        future_status
        -: 1140:        wait_until(const chrono::time_point<_Clock, _Duration>& __abs_time) const
        -: 1141:            {return __state_->wait_until(__abs_time);}
        -: 1142:};
        -: 1143:
        -: 1144:template <class _Rp>
        -: 1145:future<_Rp>::future(__assoc_state<_Rp>* __state)
       20: 1146:    : __state_(__state)
       20: 1147:{
        -: 1148:#ifndef _LIBCPP_NO_EXCEPTIONS
       20: 1149:    if (__state_->__has_future_attached())
    #####: 1150:        throw future_error(make_error_code(future_errc::future_already_retrieved));
        -: 1151:#endif
       20: 1152:    __state_->__add_shared();
       20: 1153:    __state_->__set_future_attached();
       40: 1154:}
        -: 1155:
        -: 1156:struct __release_shared_count
        -: 1157:{
       40: 1158:    void operator()(__shared_count* p) {p->__release_shared();}
        -: 1159:};
        -: 1160:
        -: 1161:template <class _Rp>
        -: 1162:future<_Rp>::~future()
       70: 1163:{
       70: 1164:    if (__state_)
    #####: 1165:        __state_->__release_shared();
      140: 1166:}
        -: 1167:
        -: 1168:template <class _Rp>
        -: 1169:_Rp
        -: 1170:future<_Rp>::get()
        -: 1171:{
       20: 1172:    unique_ptr<__shared_count, __release_shared_count> __(__state_);
       20: 1173:    __assoc_state<_Rp>* __s = __state_;
       20: 1174:    __state_ = nullptr;
       20: 1175:    return __s->move();
       20: 1176:}
        -: 1177:
        -: 1178:template <class _Rp>
        -: 1179:class _LIBCPP_TYPE_VIS_ONLY _LIBCPP_AVAILABILITY_FUTURE future<_Rp&>
        -: 1180:{
        -: 1181:    __assoc_state<_Rp&>* __state_;
        -: 1182:
        -: 1183:    explicit future(__assoc_state<_Rp&>* __state);
        -: 1184:
        -: 1185:    template <class> friend class promise;
        -: 1186:    template <class> friend class shared_future;
        -: 1187:
        -: 1188:#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -: 1189:    template <class _R1, class _Fp>
        -: 1190:        friend future<_R1> __make_deferred_assoc_state(_Fp&& __f);
        -: 1191:    template <class _R1, class _Fp>
        -: 1192:        friend future<_R1> __make_async_assoc_state(_Fp&& __f);
        -: 1193:#else
        -: 1194:    template <class _R1, class _Fp>
        -: 1195:        friend future<_R1> __make_deferred_assoc_state(_Fp __f);
        -: 1196:    template <class _R1, class _Fp>
        -: 1197:        friend future<_R1> __make_async_assoc_state(_Fp __f);
        -: 1198:#endif
        -: 1199:
        -: 1200:public:
        -: 1201:    _LIBCPP_INLINE_VISIBILITY
        -: 1202:    future() _NOEXCEPT : __state_(nullptr) {}
        -: 1203:#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -: 1204:    _LIBCPP_INLINE_VISIBILITY
        -: 1205:    future(future&& __rhs) _NOEXCEPT
        -: 1206:        : __state_(__rhs.__state_) {__rhs.__state_ = nullptr;}
        -: 1207:    future(const future&) = delete;
        -: 1208:    future& operator=(const future&) = delete;
        -: 1209:    _LIBCPP_INLINE_VISIBILITY
        -: 1210:    future& operator=(future&& __rhs) _NOEXCEPT
        -: 1211:        {
        -: 1212:            future(std::move(__rhs)).swap(*this);
        -: 1213:            return *this;
        -: 1214:        }
        -: 1215:#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -: 1216:private:
        -: 1217:    future(const future&);
        -: 1218:    future& operator=(const future&);
        -: 1219:public:
        -: 1220:#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -: 1221:    ~future();
        -: 1222:    _LIBCPP_INLINE_VISIBILITY
        -: 1223:    shared_future<_Rp&> share();
        -: 1224:
        -: 1225:    // retrieving the value
        -: 1226:    _Rp& get();
        -: 1227:
        -: 1228:    _LIBCPP_INLINE_VISIBILITY
        -: 1229:    void swap(future& __rhs) _NOEXCEPT {_VSTD::swap(__state_, __rhs.__state_);}
        -: 1230:
        -: 1231:    // functions to check state
        -: 1232:    _LIBCPP_INLINE_VISIBILITY
        -: 1233:    bool valid() const _NOEXCEPT {return __state_ != nullptr;}
        -: 1234:
        -: 1235:    _LIBCPP_INLINE_VISIBILITY
        -: 1236:    void wait() const {__state_->wait();}
        -: 1237:    template <class _Rep, class _Period>
        -: 1238:        _LIBCPP_INLINE_VISIBILITY
        -: 1239:        future_status
        -: 1240:        wait_for(const chrono::duration<_Rep, _Period>& __rel_time) const
        -: 1241:            {return __state_->wait_for(__rel_time);}
        -: 1242:    template <class _Clock, class _Duration>
        -: 1243:        _LIBCPP_INLINE_VISIBILITY
        -: 1244:        future_status
        -: 1245:        wait_until(const chrono::time_point<_Clock, _Duration>& __abs_time) const
        -: 1246:            {return __state_->wait_until(__abs_time);}
        -: 1247:};
        -: 1248:
        -: 1249:template <class _Rp>
        -: 1250:future<_Rp&>::future(__assoc_state<_Rp&>* __state)
        -: 1251:    : __state_(__state)
        -: 1252:{
        -: 1253:#ifndef _LIBCPP_NO_EXCEPTIONS
        -: 1254:    if (__state_->__has_future_attached())
        -: 1255:        throw future_error(make_error_code(future_errc::future_already_retrieved));
        -: 1256:#endif
        -: 1257:    __state_->__add_shared();
        -: 1258:    __state_->__set_future_attached();
        -: 1259:}
        -: 1260:
        -: 1261:template <class _Rp>
        -: 1262:future<_Rp&>::~future()
        -: 1263:{
        -: 1264:    if (__state_)
        -: 1265:        __state_->__release_shared();
        -: 1266:}
        -: 1267:
        -: 1268:template <class _Rp>
        -: 1269:_Rp&
        -: 1270:future<_Rp&>::get()
        -: 1271:{
        -: 1272:    unique_ptr<__shared_count, __release_shared_count> __(__state_);
        -: 1273:    __assoc_state<_Rp&>* __s = __state_;
        -: 1274:    __state_ = nullptr;
        -: 1275:    return __s->copy();
        -: 1276:}
        -: 1277:
        -: 1278:template <>
        -: 1279:class _LIBCPP_TYPE_VIS _LIBCPP_AVAILABILITY_FUTURE future<void>
        -: 1280:{
        -: 1281:    __assoc_sub_state* __state_;
        -: 1282:
        -: 1283:    explicit future(__assoc_sub_state* __state);
        -: 1284:
        -: 1285:    template <class> friend class promise;
        -: 1286:    template <class> friend class shared_future;
        -: 1287:
        -: 1288:#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -: 1289:    template <class _R1, class _Fp>
        -: 1290:        friend future<_R1> __make_deferred_assoc_state(_Fp&& __f);
        -: 1291:    template <class _R1, class _Fp>
        -: 1292:        friend future<_R1> __make_async_assoc_state(_Fp&& __f);
        -: 1293:#else
        -: 1294:    template <class _R1, class _Fp>
        -: 1295:        friend future<_R1> __make_deferred_assoc_state(_Fp __f);
        -: 1296:    template <class _R1, class _Fp>
        -: 1297:        friend future<_R1> __make_async_assoc_state(_Fp __f);
        -: 1298:#endif
        -: 1299:
        -: 1300:public:
        -: 1301:    _LIBCPP_INLINE_VISIBILITY
        -: 1302:    future() _NOEXCEPT : __state_(nullptr) {}
        -: 1303:#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -: 1304:    _LIBCPP_INLINE_VISIBILITY
        -: 1305:    future(future&& __rhs) _NOEXCEPT
        -: 1306:        : __state_(__rhs.__state_) {__rhs.__state_ = nullptr;}
        -: 1307:    future(const future&) = delete;
        -: 1308:    future& operator=(const future&) = delete;
        -: 1309:    _LIBCPP_INLINE_VISIBILITY
        -: 1310:    future& operator=(future&& __rhs) _NOEXCEPT
        -: 1311:        {
        -: 1312:            future(std::move(__rhs)).swap(*this);
        -: 1313:            return *this;
        -: 1314:        }
        -: 1315:#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -: 1316:private:
        -: 1317:    future(const future&);
        -: 1318:    future& operator=(const future&);
        -: 1319:public:
        -: 1320:#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -: 1321:    ~future();
        -: 1322:    _LIBCPP_INLINE_VISIBILITY
        -: 1323:    shared_future<void> share();
        -: 1324:
        -: 1325:    // retrieving the value
        -: 1326:    void get();
        -: 1327:
        -: 1328:    _LIBCPP_INLINE_VISIBILITY
        -: 1329:    void swap(future& __rhs) _NOEXCEPT {_VSTD::swap(__state_, __rhs.__state_);}
        -: 1330:
        -: 1331:    // functions to check state
        -: 1332:    _LIBCPP_INLINE_VISIBILITY
        -: 1333:    bool valid() const _NOEXCEPT {return __state_ != nullptr;}
        -: 1334:
        -: 1335:    _LIBCPP_INLINE_VISIBILITY
        -: 1336:    void wait() const {__state_->wait();}
        -: 1337:    template <class _Rep, class _Period>
        -: 1338:        _LIBCPP_INLINE_VISIBILITY
        -: 1339:        future_status
        -: 1340:        wait_for(const chrono::duration<_Rep, _Period>& __rel_time) const
        -: 1341:            {return __state_->wait_for(__rel_time);}
        -: 1342:    template <class _Clock, class _Duration>
        -: 1343:        _LIBCPP_INLINE_VISIBILITY
        -: 1344:        future_status
        -: 1345:        wait_until(const chrono::time_point<_Clock, _Duration>& __abs_time) const
        -: 1346:            {return __state_->wait_until(__abs_time);}
        -: 1347:};
        -: 1348:
        -: 1349:template <class _Rp>
        -: 1350:inline _LIBCPP_INLINE_VISIBILITY
        -: 1351:void
        -: 1352:swap(future<_Rp>& __x, future<_Rp>& __y) _NOEXCEPT
        -: 1353:{
        -: 1354:    __x.swap(__y);
        -: 1355:}
        -: 1356:
        -: 1357:// promise<R>
        -: 1358:
        -: 1359:template <class _Callable> class packaged_task;
        -: 1360:
        -: 1361:template <class _Rp>
        -: 1362:class _LIBCPP_TYPE_VIS_ONLY _LIBCPP_AVAILABILITY_FUTURE promise
        -: 1363:{
        -: 1364:    __assoc_state<_Rp>* __state_;
        -: 1365:
        -: 1366:    _LIBCPP_INLINE_VISIBILITY
        -: 1367:    explicit promise(nullptr_t) _NOEXCEPT : __state_(nullptr) {}
        -: 1368:
        -: 1369:    template <class> friend class packaged_task;
        -: 1370:public:
        -: 1371:    promise();
        -: 1372:    template <class _Alloc>
        -: 1373:        promise(allocator_arg_t, const _Alloc& __a);
        -: 1374:#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -: 1375:    _LIBCPP_INLINE_VISIBILITY
        -: 1376:    promise(promise&& __rhs) _NOEXCEPT
        -: 1377:        : __state_(__rhs.__state_) {__rhs.__state_ = nullptr;}
        -: 1378:    promise(const promise& __rhs) = delete;
        -: 1379:#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -: 1380:private:
        -: 1381:    promise(const promise& __rhs);
        -: 1382:public:
        -: 1383:#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -: 1384:    ~promise();
        -: 1385:
        -: 1386:    // assignment
        -: 1387:#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -: 1388:    _LIBCPP_INLINE_VISIBILITY
        -: 1389:    promise& operator=(promise&& __rhs) _NOEXCEPT
        -: 1390:        {
        -: 1391:            promise(std::move(__rhs)).swap(*this);
        -: 1392:            return *this;
        -: 1393:        }
        -: 1394:    promise& operator=(const promise& __rhs) = delete;
        -: 1395:#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -: 1396:private:
        -: 1397:    promise& operator=(const promise& __rhs);
        -: 1398:public:
        -: 1399:#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -: 1400:    _LIBCPP_INLINE_VISIBILITY
        -: 1401:    void swap(promise& __rhs) _NOEXCEPT {_VSTD::swap(__state_, __rhs.__state_);}
        -: 1402:
        -: 1403:    // retrieving the result
        -: 1404:    future<_Rp> get_future();
        -: 1405:
        -: 1406:    // setting the result
        -: 1407:    void set_value(const _Rp& __r);
        -: 1408:#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -: 1409:    void set_value(_Rp&& __r);
        -: 1410:#endif
        -: 1411:    void set_exception(exception_ptr __p);
        -: 1412:
        -: 1413:    // setting the result with deferred notification
        -: 1414:    void set_value_at_thread_exit(const _Rp& __r);
        -: 1415:#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -: 1416:    void set_value_at_thread_exit(_Rp&& __r);
        -: 1417:#endif
        -: 1418:    void set_exception_at_thread_exit(exception_ptr __p);
        -: 1419:};
        -: 1420:
        -: 1421:template <class _Rp>
        -: 1422:promise<_Rp>::promise()
        -: 1423:    : __state_(new __assoc_state<_Rp>)
        -: 1424:{
        -: 1425:}
        -: 1426:
        -: 1427:template <class _Rp>
        -: 1428:template <class _Alloc>
        -: 1429:promise<_Rp>::promise(allocator_arg_t, const _Alloc& __a0)
        -: 1430:{
        -: 1431:    typedef __assoc_state_alloc<_Rp, _Alloc> _State;
        -: 1432:    typedef typename __allocator_traits_rebind<_Alloc, _State>::type _A2;
        -: 1433:    typedef __allocator_destructor<_A2> _D2;
        -: 1434:    _A2 __a(__a0);
        -: 1435:    unique_ptr<_State, _D2> __hold(__a.allocate(1), _D2(__a, 1));
        -: 1436:    ::new(static_cast<void*>(_VSTD::addressof(*__hold.get()))) _State(__a0);
        -: 1437:    __state_ = _VSTD::addressof(*__hold.release());
        -: 1438:}
        -: 1439:
        -: 1440:template <class _Rp>
        -: 1441:promise<_Rp>::~promise()
        -: 1442:{
        -: 1443:    if (__state_)
        -: 1444:    {
        -: 1445:        if (!__state_->__has_value() && __state_->use_count() > 1)
        -: 1446:            __state_->set_exception(make_exception_ptr(
        -: 1447:                      future_error(make_error_code(future_errc::broken_promise))
        -: 1448:                                                      ));
        -: 1449:        __state_->__release_shared();
        -: 1450:    }
        -: 1451:}
        -: 1452:
        -: 1453:template <class _Rp>
        -: 1454:future<_Rp>
        -: 1455:promise<_Rp>::get_future()
        -: 1456:{
        -: 1457:#ifndef _LIBCPP_NO_EXCEPTIONS
        -: 1458:    if (__state_ == nullptr)
        -: 1459:        throw future_error(make_error_code(future_errc::no_state));
        -: 1460:#endif
        -: 1461:    return future<_Rp>(__state_);
        -: 1462:}
        -: 1463:
        -: 1464:template <class _Rp>
        -: 1465:void
        -: 1466:promise<_Rp>::set_value(const _Rp& __r)
        -: 1467:{
        -: 1468:#ifndef _LIBCPP_NO_EXCEPTIONS
        -: 1469:    if (__state_ == nullptr)
        -: 1470:        throw future_error(make_error_code(future_errc::no_state));
        -: 1471:#endif
        -: 1472:    __state_->set_value(__r);
        -: 1473:}
        -: 1474:
        -: 1475:#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -: 1476:
        -: 1477:template <class _Rp>
        -: 1478:void
        -: 1479:promise<_Rp>::set_value(_Rp&& __r)
        -: 1480:{
        -: 1481:#ifndef _LIBCPP_NO_EXCEPTIONS
        -: 1482:    if (__state_ == nullptr)
        -: 1483:        throw future_error(make_error_code(future_errc::no_state));
        -: 1484:#endif
        -: 1485:    __state_->set_value(_VSTD::move(__r));
        -: 1486:}
        -: 1487:
        -: 1488:#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -: 1489:
        -: 1490:template <class _Rp>
        -: 1491:void
        -: 1492:promise<_Rp>::set_exception(exception_ptr __p)
        -: 1493:{
        -: 1494:#ifndef _LIBCPP_NO_EXCEPTIONS
        -: 1495:    if (__state_ == nullptr)
        -: 1496:        throw future_error(make_error_code(future_errc::no_state));
        -: 1497:#endif
        -: 1498:    __state_->set_exception(__p);
        -: 1499:}
        -: 1500:
        -: 1501:template <class _Rp>
        -: 1502:void
        -: 1503:promise<_Rp>::set_value_at_thread_exit(const _Rp& __r)
        -: 1504:{
        -: 1505:#ifndef _LIBCPP_NO_EXCEPTIONS
        -: 1506:    if (__state_ == nullptr)
        -: 1507:        throw future_error(make_error_code(future_errc::no_state));
        -: 1508:#endif
        -: 1509:    __state_->set_value_at_thread_exit(__r);
        -: 1510:}
        -: 1511:
        -: 1512:#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -: 1513:
        -: 1514:template <class _Rp>
        -: 1515:void
        -: 1516:promise<_Rp>::set_value_at_thread_exit(_Rp&& __r)
        -: 1517:{
        -: 1518:#ifndef _LIBCPP_NO_EXCEPTIONS
        -: 1519:    if (__state_ == nullptr)
        -: 1520:        throw future_error(make_error_code(future_errc::no_state));
        -: 1521:#endif
        -: 1522:    __state_->set_value_at_thread_exit(_VSTD::move(__r));
        -: 1523:}
        -: 1524:
        -: 1525:#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -: 1526:
        -: 1527:template <class _Rp>
        -: 1528:void
        -: 1529:promise<_Rp>::set_exception_at_thread_exit(exception_ptr __p)
        -: 1530:{
        -: 1531:#ifndef _LIBCPP_NO_EXCEPTIONS
        -: 1532:    if (__state_ == nullptr)
        -: 1533:        throw future_error(make_error_code(future_errc::no_state));
        -: 1534:#endif
        -: 1535:    __state_->set_exception_at_thread_exit(__p);
        -: 1536:}
        -: 1537:
        -: 1538:// promise<R&>
        -: 1539:
        -: 1540:template <class _Rp>
        -: 1541:class _LIBCPP_TYPE_VIS_ONLY _LIBCPP_AVAILABILITY_FUTURE promise<_Rp&>
        -: 1542:{
        -: 1543:    __assoc_state<_Rp&>* __state_;
        -: 1544:
        -: 1545:    _LIBCPP_INLINE_VISIBILITY
        -: 1546:    explicit promise(nullptr_t) _NOEXCEPT : __state_(nullptr) {}
        -: 1547:
        -: 1548:    template <class> friend class packaged_task;
        -: 1549:
        -: 1550:public:
        -: 1551:    promise();
        -: 1552:    template <class _Allocator>
        -: 1553:        promise(allocator_arg_t, const _Allocator& __a);
        -: 1554:#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -: 1555:    _LIBCPP_INLINE_VISIBILITY
        -: 1556:    promise(promise&& __rhs) _NOEXCEPT
        -: 1557:        : __state_(__rhs.__state_) {__rhs.__state_ = nullptr;}
        -: 1558:    promise(const promise& __rhs) = delete;
        -: 1559:#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -: 1560:private:
        -: 1561:    promise(const promise& __rhs);
        -: 1562:public:
        -: 1563:#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -: 1564:    ~promise();
        -: 1565:
        -: 1566:    // assignment
        -: 1567:#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -: 1568:    _LIBCPP_INLINE_VISIBILITY
        -: 1569:    promise& operator=(promise&& __rhs) _NOEXCEPT
        -: 1570:        {
        -: 1571:            promise(std::move(__rhs)).swap(*this);
        -: 1572:            return *this;
        -: 1573:        }
        -: 1574:    promise& operator=(const promise& __rhs) = delete;
        -: 1575:#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -: 1576:private:
        -: 1577:    promise& operator=(const promise& __rhs);
        -: 1578:public:
        -: 1579:#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -: 1580:    _LIBCPP_INLINE_VISIBILITY
        -: 1581:    void swap(promise& __rhs) _NOEXCEPT {_VSTD::swap(__state_, __rhs.__state_);}
        -: 1582:
        -: 1583:    // retrieving the result
        -: 1584:    future<_Rp&> get_future();
        -: 1585:
        -: 1586:    // setting the result
        -: 1587:    void set_value(_Rp& __r);
        -: 1588:    void set_exception(exception_ptr __p);
        -: 1589:
        -: 1590:    // setting the result with deferred notification
        -: 1591:    void set_value_at_thread_exit(_Rp&);
        -: 1592:    void set_exception_at_thread_exit(exception_ptr __p);
        -: 1593:};
        -: 1594:
        -: 1595:template <class _Rp>
        -: 1596:promise<_Rp&>::promise()
        -: 1597:    : __state_(new __assoc_state<_Rp&>)
        -: 1598:{
        -: 1599:}
        -: 1600:
        -: 1601:template <class _Rp>
        -: 1602:template <class _Alloc>
        -: 1603:promise<_Rp&>::promise(allocator_arg_t, const _Alloc& __a0)
        -: 1604:{
        -: 1605:    typedef __assoc_state_alloc<_Rp&, _Alloc> _State;
        -: 1606:    typedef typename __allocator_traits_rebind<_Alloc, _State>::type _A2;
        -: 1607:    typedef __allocator_destructor<_A2> _D2;
        -: 1608:    _A2 __a(__a0);
        -: 1609:    unique_ptr<_State, _D2> __hold(__a.allocate(1), _D2(__a, 1));
        -: 1610:    ::new(static_cast<void*>(_VSTD::addressof(*__hold.get()))) _State(__a0);
        -: 1611:    __state_ = _VSTD::addressof(*__hold.release());
        -: 1612:}
        -: 1613:
        -: 1614:template <class _Rp>
        -: 1615:promise<_Rp&>::~promise()
        -: 1616:{
        -: 1617:    if (__state_)
        -: 1618:    {
        -: 1619:        if (!__state_->__has_value() && __state_->use_count() > 1)
        -: 1620:            __state_->set_exception(make_exception_ptr(
        -: 1621:                      future_error(make_error_code(future_errc::broken_promise))
        -: 1622:                                                      ));
        -: 1623:        __state_->__release_shared();
        -: 1624:    }
        -: 1625:}
        -: 1626:
        -: 1627:template <class _Rp>
        -: 1628:future<_Rp&>
        -: 1629:promise<_Rp&>::get_future()
        -: 1630:{
        -: 1631:#ifndef _LIBCPP_NO_EXCEPTIONS
        -: 1632:    if (__state_ == nullptr)
        -: 1633:        throw future_error(make_error_code(future_errc::no_state));
        -: 1634:#endif
        -: 1635:    return future<_Rp&>(__state_);
        -: 1636:}
        -: 1637:
        -: 1638:template <class _Rp>
        -: 1639:void
        -: 1640:promise<_Rp&>::set_value(_Rp& __r)
        -: 1641:{
        -: 1642:#ifndef _LIBCPP_NO_EXCEPTIONS
        -: 1643:    if (__state_ == nullptr)
        -: 1644:        throw future_error(make_error_code(future_errc::no_state));
        -: 1645:#endif
        -: 1646:    __state_->set_value(__r);
        -: 1647:}
        -: 1648:
        -: 1649:template <class _Rp>
        -: 1650:void
        -: 1651:promise<_Rp&>::set_exception(exception_ptr __p)
        -: 1652:{
        -: 1653:#ifndef _LIBCPP_NO_EXCEPTIONS
        -: 1654:    if (__state_ == nullptr)
        -: 1655:        throw future_error(make_error_code(future_errc::no_state));
        -: 1656:#endif
        -: 1657:    __state_->set_exception(__p);
        -: 1658:}
        -: 1659:
        -: 1660:template <class _Rp>
        -: 1661:void
        -: 1662:promise<_Rp&>::set_value_at_thread_exit(_Rp& __r)
        -: 1663:{
        -: 1664:#ifndef _LIBCPP_NO_EXCEPTIONS
        -: 1665:    if (__state_ == nullptr)
        -: 1666:        throw future_error(make_error_code(future_errc::no_state));
        -: 1667:#endif
        -: 1668:    __state_->set_value_at_thread_exit(__r);
        -: 1669:}
        -: 1670:
        -: 1671:template <class _Rp>
        -: 1672:void
        -: 1673:promise<_Rp&>::set_exception_at_thread_exit(exception_ptr __p)
        -: 1674:{
        -: 1675:#ifndef _LIBCPP_NO_EXCEPTIONS
        -: 1676:    if (__state_ == nullptr)
        -: 1677:        throw future_error(make_error_code(future_errc::no_state));
        -: 1678:#endif
        -: 1679:    __state_->set_exception_at_thread_exit(__p);
        -: 1680:}
        -: 1681:
        -: 1682:// promise<void>
        -: 1683:
        -: 1684:template <>
        -: 1685:class _LIBCPP_TYPE_VIS _LIBCPP_AVAILABILITY_FUTURE promise<void>
        -: 1686:{
        -: 1687:    __assoc_sub_state* __state_;
        -: 1688:
        -: 1689:    _LIBCPP_INLINE_VISIBILITY
        -: 1690:    explicit promise(nullptr_t) _NOEXCEPT : __state_(nullptr) {}
        -: 1691:
        -: 1692:    template <class> friend class packaged_task;
        -: 1693:
        -: 1694:public:
        -: 1695:    promise();
        -: 1696:    template <class _Allocator>
        -: 1697:        promise(allocator_arg_t, const _Allocator& __a);
        -: 1698:#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -: 1699:    _LIBCPP_INLINE_VISIBILITY
        -: 1700:    promise(promise&& __rhs) _NOEXCEPT
        -: 1701:        : __state_(__rhs.__state_) {__rhs.__state_ = nullptr;}
        -: 1702:    promise(const promise& __rhs) = delete;
        -: 1703:#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -: 1704:private:
        -: 1705:    promise(const promise& __rhs);
        -: 1706:public:
        -: 1707:#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -: 1708:    ~promise();
        -: 1709:
        -: 1710:    // assignment
        -: 1711:#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -: 1712:    _LIBCPP_INLINE_VISIBILITY
        -: 1713:    promise& operator=(promise&& __rhs) _NOEXCEPT
        -: 1714:        {
        -: 1715:            promise(std::move(__rhs)).swap(*this);
        -: 1716:            return *this;
        -: 1717:        }
        -: 1718:    promise& operator=(const promise& __rhs) = delete;
        -: 1719:#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -: 1720:private:
        -: 1721:    promise& operator=(const promise& __rhs);
        -: 1722:public:
        -: 1723:#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -: 1724:    _LIBCPP_INLINE_VISIBILITY
        -: 1725:    void swap(promise& __rhs) _NOEXCEPT {_VSTD::swap(__state_, __rhs.__state_);}
        -: 1726:
        -: 1727:    // retrieving the result
        -: 1728:    future<void> get_future();
        -: 1729:
        -: 1730:    // setting the result
        -: 1731:    void set_value();
        -: 1732:    void set_exception(exception_ptr __p);
        -: 1733:
        -: 1734:    // setting the result with deferred notification
        -: 1735:    void set_value_at_thread_exit();
        -: 1736:    void set_exception_at_thread_exit(exception_ptr __p);
        -: 1737:};
        -: 1738:
        -: 1739:template <class _Alloc>
        -: 1740:promise<void>::promise(allocator_arg_t, const _Alloc& __a0)
        -: 1741:{
        -: 1742:    typedef __assoc_sub_state_alloc<_Alloc> _State;
        -: 1743:    typedef typename __allocator_traits_rebind<_Alloc, _State>::type _A2;
        -: 1744:    typedef __allocator_destructor<_A2> _D2;
        -: 1745:    _A2 __a(__a0);
        -: 1746:    unique_ptr<_State, _D2> __hold(__a.allocate(1), _D2(__a, 1));
        -: 1747:    ::new(static_cast<void*>(_VSTD::addressof(*__hold.get()))) _State(__a0);
        -: 1748:    __state_ = _VSTD::addressof(*__hold.release());
        -: 1749:}
        -: 1750:
        -: 1751:template <class _Rp>
        -: 1752:inline _LIBCPP_INLINE_VISIBILITY
        -: 1753:void
        -: 1754:swap(promise<_Rp>& __x, promise<_Rp>& __y) _NOEXCEPT
        -: 1755:{
        -: 1756:    __x.swap(__y);
        -: 1757:}
        -: 1758:
        -: 1759:template <class _Rp, class _Alloc>
        -: 1760:    struct _LIBCPP_TYPE_VIS_ONLY uses_allocator<promise<_Rp>, _Alloc>
        -: 1761:        : public true_type {};
        -: 1762:
        -: 1763:#ifndef _LIBCPP_HAS_NO_VARIADICS
        -: 1764:
        -: 1765:// packaged_task
        -: 1766:
        -: 1767:template<class _Fp> class __packaged_task_base;
        -: 1768:
        -: 1769:template<class _Rp, class ..._ArgTypes>
        -: 1770:class _LIBCPP_AVAILABILITY_FUTURE __packaged_task_base<_Rp(_ArgTypes...)>
        -: 1771:{
        -: 1772:    __packaged_task_base(const __packaged_task_base&);
        -: 1773:    __packaged_task_base& operator=(const __packaged_task_base&);
        -: 1774:public:
        -: 1775:    _LIBCPP_INLINE_VISIBILITY
        -: 1776:    __packaged_task_base() {}
        -: 1777:    _LIBCPP_INLINE_VISIBILITY
        -: 1778:    virtual ~__packaged_task_base() {}
        -: 1779:    virtual void __move_to(__packaged_task_base*) _NOEXCEPT = 0;
        -: 1780:    virtual void destroy() = 0;
        -: 1781:    virtual void destroy_deallocate() = 0;
        -: 1782:    virtual _Rp operator()(_ArgTypes&& ...) = 0;
        -: 1783:};
        -: 1784:
        -: 1785:template<class _FD, class _Alloc, class _FB> class __packaged_task_func;
        -: 1786:
        -: 1787:template<class _Fp, class _Alloc, class _Rp, class ..._ArgTypes>
        -: 1788:class _LIBCPP_AVAILABILITY_FUTURE __packaged_task_func<_Fp, _Alloc, _Rp(_ArgTypes...)>
        -: 1789:    : public  __packaged_task_base<_Rp(_ArgTypes...)>
        -: 1790:{
        -: 1791:    __compressed_pair<_Fp, _Alloc> __f_;
        -: 1792:public:
        -: 1793:    _LIBCPP_INLINE_VISIBILITY
        -: 1794:    explicit __packaged_task_func(const _Fp& __f) : __f_(__f) {}
        -: 1795:    _LIBCPP_INLINE_VISIBILITY
        -: 1796:    explicit __packaged_task_func(_Fp&& __f) : __f_(_VSTD::move(__f)) {}
        -: 1797:    _LIBCPP_INLINE_VISIBILITY
        -: 1798:    __packaged_task_func(const _Fp& __f, const _Alloc& __a)
        -: 1799:        : __f_(__f, __a) {}
        -: 1800:    _LIBCPP_INLINE_VISIBILITY
        -: 1801:    __packaged_task_func(_Fp&& __f, const _Alloc& __a)
        -: 1802:        : __f_(_VSTD::move(__f), __a) {}
        -: 1803:    virtual void __move_to(__packaged_task_base<_Rp(_ArgTypes...)>*) _NOEXCEPT;
        -: 1804:    virtual void destroy();
        -: 1805:    virtual void destroy_deallocate();
        -: 1806:    virtual _Rp operator()(_ArgTypes&& ... __args);
        -: 1807:};
        -: 1808:
        -: 1809:template<class _Fp, class _Alloc, class _Rp, class ..._ArgTypes>
        -: 1810:void
        -: 1811:__packaged_task_func<_Fp, _Alloc, _Rp(_ArgTypes...)>::__move_to(
        -: 1812:                              __packaged_task_base<_Rp(_ArgTypes...)>* __p) _NOEXCEPT
        -: 1813:{
        -: 1814:    ::new (__p) __packaged_task_func(_VSTD::move(__f_.first()), _VSTD::move(__f_.second()));
        -: 1815:}
        -: 1816:
        -: 1817:template<class _Fp, class _Alloc, class _Rp, class ..._ArgTypes>
        -: 1818:void
        -: 1819:__packaged_task_func<_Fp, _Alloc, _Rp(_ArgTypes...)>::destroy()
        -: 1820:{
        -: 1821:    __f_.~__compressed_pair<_Fp, _Alloc>();
        -: 1822:}
        -: 1823:
        -: 1824:template<class _Fp, class _Alloc, class _Rp, class ..._ArgTypes>
        -: 1825:void
        -: 1826:__packaged_task_func<_Fp, _Alloc, _Rp(_ArgTypes...)>::destroy_deallocate()
        -: 1827:{
        -: 1828:    typedef typename __allocator_traits_rebind<_Alloc, __packaged_task_func>::type _Ap;
        -: 1829:    typedef allocator_traits<_Ap> _ATraits;
        -: 1830:    typedef pointer_traits<typename _ATraits::pointer> _PTraits;
        -: 1831:    _Ap __a(__f_.second());
        -: 1832:    __f_.~__compressed_pair<_Fp, _Alloc>();
        -: 1833:    __a.deallocate(_PTraits::pointer_to(*this), 1);
        -: 1834:}
        -: 1835:
        -: 1836:template<class _Fp, class _Alloc, class _Rp, class ..._ArgTypes>
        -: 1837:_Rp
        -: 1838:__packaged_task_func<_Fp, _Alloc, _Rp(_ArgTypes...)>::operator()(_ArgTypes&& ... __arg)
        -: 1839:{
        -: 1840:    return __invoke(__f_.first(), _VSTD::forward<_ArgTypes>(__arg)...);
        -: 1841:}
        -: 1842:
        -: 1843:template <class _Callable> class __packaged_task_function;
        -: 1844:
        -: 1845:template<class _Rp, class ..._ArgTypes>
        -: 1846:class _LIBCPP_AVAILABILITY_FUTURE __packaged_task_function<_Rp(_ArgTypes...)>
        -: 1847:{
        -: 1848:    typedef __packaged_task_base<_Rp(_ArgTypes...)> __base;
        -: 1849:    typename aligned_storage<3*sizeof(void*)>::type __buf_;
        -: 1850:    __base* __f_;
        -: 1851:
        -: 1852:public:
        -: 1853:    typedef _Rp result_type;
        -: 1854:
        -: 1855:    // construct/copy/destroy:
        -: 1856:    _LIBCPP_INLINE_VISIBILITY
        -: 1857:    __packaged_task_function() _NOEXCEPT : __f_(nullptr) {}
        -: 1858:    template<class _Fp>
        -: 1859:      __packaged_task_function(_Fp&& __f);
        -: 1860:    template<class _Fp, class _Alloc>
        -: 1861:      __packaged_task_function(allocator_arg_t, const _Alloc& __a, _Fp&& __f);
        -: 1862:
        -: 1863:    __packaged_task_function(__packaged_task_function&&) _NOEXCEPT;
        -: 1864:    __packaged_task_function& operator=(__packaged_task_function&&) _NOEXCEPT;
        -: 1865:
        -: 1866:    __packaged_task_function(const __packaged_task_function&) =  delete;
        -: 1867:    __packaged_task_function& operator=(const __packaged_task_function&) =  delete;
        -: 1868:
        -: 1869:    ~__packaged_task_function();
        -: 1870:
        -: 1871:    void swap(__packaged_task_function&) _NOEXCEPT;
        -: 1872:
        -: 1873:    _LIBCPP_INLINE_VISIBILITY
        -: 1874:    _Rp operator()(_ArgTypes...) const;
        -: 1875:};
        -: 1876:
        -: 1877:template<class _Rp, class ..._ArgTypes>
        -: 1878:__packaged_task_function<_Rp(_ArgTypes...)>::__packaged_task_function(__packaged_task_function&& __f) _NOEXCEPT
        -: 1879:{
        -: 1880:    if (__f.__f_ == nullptr)
        -: 1881:        __f_ = nullptr;
        -: 1882:    else if (__f.__f_ == (__base*)&__f.__buf_)
        -: 1883:    {
        -: 1884:        __f_ = (__base*)&__buf_;
        -: 1885:        __f.__f_->__move_to(__f_);
        -: 1886:    }
        -: 1887:    else
        -: 1888:    {
        -: 1889:        __f_ = __f.__f_;
        -: 1890:        __f.__f_ = nullptr;
        -: 1891:    }
        -: 1892:}
        -: 1893:
        -: 1894:template<class _Rp, class ..._ArgTypes>
        -: 1895:template <class _Fp>
        -: 1896:__packaged_task_function<_Rp(_ArgTypes...)>::__packaged_task_function(_Fp&& __f)
        -: 1897:    : __f_(nullptr)
        -: 1898:{
        -: 1899:    typedef typename remove_reference<typename decay<_Fp>::type>::type _FR;
        -: 1900:    typedef __packaged_task_func<_FR, allocator<_FR>, _Rp(_ArgTypes...)> _FF;
        -: 1901:    if (sizeof(_FF) <= sizeof(__buf_))
        -: 1902:    {
        -: 1903:        __f_ = (__base*)&__buf_;
        -: 1904:        ::new (__f_) _FF(_VSTD::forward<_Fp>(__f));
        -: 1905:    }
        -: 1906:    else
        -: 1907:    {
        -: 1908:        typedef allocator<_FF> _Ap;
        -: 1909:        _Ap __a;
        -: 1910:        typedef __allocator_destructor<_Ap> _Dp;
        -: 1911:        unique_ptr<__base, _Dp> __hold(__a.allocate(1), _Dp(__a, 1));
        -: 1912:        ::new (__hold.get()) _FF(_VSTD::forward<_Fp>(__f), allocator<_FR>(__a));
        -: 1913:        __f_ = __hold.release();
        -: 1914:    }
        -: 1915:}
        -: 1916:
        -: 1917:template<class _Rp, class ..._ArgTypes>
        -: 1918:template <class _Fp, class _Alloc>
        -: 1919:__packaged_task_function<_Rp(_ArgTypes...)>::__packaged_task_function(
        -: 1920:                                  allocator_arg_t, const _Alloc& __a0, _Fp&& __f)
        -: 1921:    : __f_(nullptr)
        -: 1922:{
        -: 1923:    typedef typename remove_reference<typename decay<_Fp>::type>::type _FR;
        -: 1924:    typedef __packaged_task_func<_FR, _Alloc, _Rp(_ArgTypes...)> _FF;
        -: 1925:    if (sizeof(_FF) <= sizeof(__buf_))
        -: 1926:    {
        -: 1927:        __f_ = (__base*)&__buf_;
        -: 1928:        ::new (__f_) _FF(_VSTD::forward<_Fp>(__f));
        -: 1929:    }
        -: 1930:    else
        -: 1931:    {
        -: 1932:        typedef typename __allocator_traits_rebind<_Alloc, _FF>::type _Ap;
        -: 1933:        _Ap __a(__a0);
        -: 1934:        typedef __allocator_destructor<_Ap> _Dp;
        -: 1935:        unique_ptr<__base, _Dp> __hold(__a.allocate(1), _Dp(__a, 1));
        -: 1936:        ::new (static_cast<void*>(_VSTD::addressof(*__hold.get())))
        -: 1937:            _FF(_VSTD::forward<_Fp>(__f), _Alloc(__a));
        -: 1938:        __f_ = _VSTD::addressof(*__hold.release());
        -: 1939:    }
        -: 1940:}
        -: 1941:
        -: 1942:template<class _Rp, class ..._ArgTypes>
        -: 1943:__packaged_task_function<_Rp(_ArgTypes...)>&
        -: 1944:__packaged_task_function<_Rp(_ArgTypes...)>::operator=(__packaged_task_function&& __f) _NOEXCEPT
        -: 1945:{
        -: 1946:    if (__f_ == (__base*)&__buf_)
        -: 1947:        __f_->destroy();
        -: 1948:    else if (__f_)
        -: 1949:        __f_->destroy_deallocate();
        -: 1950:    __f_ = nullptr;
        -: 1951:    if (__f.__f_ == nullptr)
        -: 1952:        __f_ = nullptr;
        -: 1953:    else if (__f.__f_ == (__base*)&__f.__buf_)
        -: 1954:    {
        -: 1955:        __f_ = (__base*)&__buf_;
        -: 1956:        __f.__f_->__move_to(__f_);
        -: 1957:    }
        -: 1958:    else
        -: 1959:    {
        -: 1960:        __f_ = __f.__f_;
        -: 1961:        __f.__f_ = nullptr;
        -: 1962:    }
        -: 1963:    return *this;
        -: 1964:}
        -: 1965:
        -: 1966:template<class _Rp, class ..._ArgTypes>
        -: 1967:__packaged_task_function<_Rp(_ArgTypes...)>::~__packaged_task_function()
        -: 1968:{
        -: 1969:    if (__f_ == (__base*)&__buf_)
        -: 1970:        __f_->destroy();
        -: 1971:    else if (__f_)
        -: 1972:        __f_->destroy_deallocate();
        -: 1973:}
        -: 1974:
        -: 1975:template<class _Rp, class ..._ArgTypes>
        -: 1976:void
        -: 1977:__packaged_task_function<_Rp(_ArgTypes...)>::swap(__packaged_task_function& __f) _NOEXCEPT
        -: 1978:{
        -: 1979:    if (__f_ == (__base*)&__buf_ && __f.__f_ == (__base*)&__f.__buf_)
        -: 1980:    {
        -: 1981:        typename aligned_storage<sizeof(__buf_)>::type __tempbuf;
        -: 1982:        __base* __t = (__base*)&__tempbuf;
        -: 1983:        __f_->__move_to(__t);
        -: 1984:        __f_->destroy();
        -: 1985:        __f_ = nullptr;
        -: 1986:        __f.__f_->__move_to((__base*)&__buf_);
        -: 1987:        __f.__f_->destroy();
        -: 1988:        __f.__f_ = nullptr;
        -: 1989:        __f_ = (__base*)&__buf_;
        -: 1990:        __t->__move_to((__base*)&__f.__buf_);
        -: 1991:        __t->destroy();
        -: 1992:        __f.__f_ = (__base*)&__f.__buf_;
        -: 1993:    }
        -: 1994:    else if (__f_ == (__base*)&__buf_)
        -: 1995:    {
        -: 1996:        __f_->__move_to((__base*)&__f.__buf_);
        -: 1997:        __f_->destroy();
        -: 1998:        __f_ = __f.__f_;
        -: 1999:        __f.__f_ = (__base*)&__f.__buf_;
        -: 2000:    }
        -: 2001:    else if (__f.__f_ == (__base*)&__f.__buf_)
        -: 2002:    {
        -: 2003:        __f.__f_->__move_to((__base*)&__buf_);
        -: 2004:        __f.__f_->destroy();
        -: 2005:        __f.__f_ = __f_;
        -: 2006:        __f_ = (__base*)&__buf_;
        -: 2007:    }
        -: 2008:    else
        -: 2009:        _VSTD::swap(__f_, __f.__f_);
        -: 2010:}
        -: 2011:
        -: 2012:template<class _Rp, class ..._ArgTypes>
        -: 2013:inline
        -: 2014:_Rp
        -: 2015:__packaged_task_function<_Rp(_ArgTypes...)>::operator()(_ArgTypes... __arg) const
        -: 2016:{
        -: 2017:    return (*__f_)(_VSTD::forward<_ArgTypes>(__arg)...);
        -: 2018:}
        -: 2019:
        -: 2020:template<class _Rp, class ..._ArgTypes>
        -: 2021:class _LIBCPP_TYPE_VIS_ONLY _LIBCPP_AVAILABILITY_FUTURE packaged_task<_Rp(_ArgTypes...)>
        -: 2022:{
        -: 2023:public:
        -: 2024:    typedef _Rp result_type;
        -: 2025:
        -: 2026:private:
        -: 2027:    __packaged_task_function<result_type(_ArgTypes...)> __f_;
        -: 2028:    promise<result_type>                                __p_;
        -: 2029:
        -: 2030:public:
        -: 2031:    // construction and destruction
        -: 2032:    _LIBCPP_INLINE_VISIBILITY
        -: 2033:    packaged_task() _NOEXCEPT : __p_(nullptr) {}
        -: 2034:    template <class _Fp,
        -: 2035:              class = typename enable_if
        -: 2036:              <
        -: 2037:                  !is_same<
        -: 2038:                      typename decay<_Fp>::type, 
        -: 2039:                      packaged_task
        -: 2040:                      >::value
        -: 2041:                  >::type
        -: 2042:             >
        -: 2043:        _LIBCPP_INLINE_VISIBILITY
        -: 2044:        explicit packaged_task(_Fp&& __f) : __f_(_VSTD::forward<_Fp>(__f)) {}
        -: 2045:    template <class _Fp, class _Allocator,
        -: 2046:              class = typename enable_if
        -: 2047:              <
        -: 2048:                  !is_same<
        -: 2049:                      typename decay<_Fp>::type, 
        -: 2050:                      packaged_task
        -: 2051:                      >::value
        -: 2052:                  >::type
        -: 2053:              >
        -: 2054:        _LIBCPP_INLINE_VISIBILITY
        -: 2055:        packaged_task(allocator_arg_t, const _Allocator& __a, _Fp&& __f)
        -: 2056:             : __f_(allocator_arg, __a, _VSTD::forward<_Fp>(__f)),
        -: 2057:               __p_(allocator_arg, __a) {}
        -: 2058:    // ~packaged_task() = default;
        -: 2059:
        -: 2060:    // no copy
        -: 2061:    packaged_task(const packaged_task&) = delete;
        -: 2062:    packaged_task& operator=(const packaged_task&) = delete;
        -: 2063:
        -: 2064:    // move support
        -: 2065:    _LIBCPP_INLINE_VISIBILITY
        -: 2066:    packaged_task(packaged_task&& __other) _NOEXCEPT
        -: 2067:        : __f_(_VSTD::move(__other.__f_)), __p_(_VSTD::move(__other.__p_)) {}
        -: 2068:    _LIBCPP_INLINE_VISIBILITY
        -: 2069:    packaged_task& operator=(packaged_task&& __other) _NOEXCEPT
        -: 2070:    {
        -: 2071:        __f_ = _VSTD::move(__other.__f_);
        -: 2072:        __p_ = _VSTD::move(__other.__p_);
        -: 2073:        return *this;
        -: 2074:    }
        -: 2075:    _LIBCPP_INLINE_VISIBILITY
        -: 2076:    void swap(packaged_task& __other) _NOEXCEPT
        -: 2077:    {
        -: 2078:        __f_.swap(__other.__f_);
        -: 2079:        __p_.swap(__other.__p_);
        -: 2080:    }
        -: 2081:
        -: 2082:    _LIBCPP_INLINE_VISIBILITY
        -: 2083:    bool valid() const _NOEXCEPT {return __p_.__state_ != nullptr;}
        -: 2084:
        -: 2085:    // result retrieval
        -: 2086:    _LIBCPP_INLINE_VISIBILITY
        -: 2087:    future<result_type> get_future() {return __p_.get_future();}
        -: 2088:
        -: 2089:    // execution
        -: 2090:    void operator()(_ArgTypes... __args);
        -: 2091:    void make_ready_at_thread_exit(_ArgTypes... __args);
        -: 2092:
        -: 2093:    void reset();
        -: 2094:};
        -: 2095:
        -: 2096:template<class _Rp, class ..._ArgTypes>
        -: 2097:void
        -: 2098:packaged_task<_Rp(_ArgTypes...)>::operator()(_ArgTypes... __args)
        -: 2099:{
        -: 2100:#ifndef _LIBCPP_NO_EXCEPTIONS
        -: 2101:    if (__p_.__state_ == nullptr)
        -: 2102:        throw future_error(make_error_code(future_errc::no_state));
        -: 2103:    if (__p_.__state_->__has_value())
        -: 2104:        throw future_error(make_error_code(future_errc::promise_already_satisfied));
        -: 2105:    try
        -: 2106:    {
        -: 2107:#endif  // _LIBCPP_NO_EXCEPTIONS
        -: 2108:        __p_.set_value(__f_(_VSTD::forward<_ArgTypes>(__args)...));
        -: 2109:#ifndef _LIBCPP_NO_EXCEPTIONS
        -: 2110:    }
        -: 2111:    catch (...)
        -: 2112:    {
        -: 2113:        __p_.set_exception(current_exception());
        -: 2114:    }
        -: 2115:#endif  // _LIBCPP_NO_EXCEPTIONS
        -: 2116:}
        -: 2117:
        -: 2118:template<class _Rp, class ..._ArgTypes>
        -: 2119:void
        -: 2120:packaged_task<_Rp(_ArgTypes...)>::make_ready_at_thread_exit(_ArgTypes... __args)
        -: 2121:{
        -: 2122:#ifndef _LIBCPP_NO_EXCEPTIONS
        -: 2123:    if (__p_.__state_ == nullptr)
        -: 2124:        throw future_error(make_error_code(future_errc::no_state));
        -: 2125:    if (__p_.__state_->__has_value())
        -: 2126:        throw future_error(make_error_code(future_errc::promise_already_satisfied));
        -: 2127:    try
        -: 2128:    {
        -: 2129:#endif  // _LIBCPP_NO_EXCEPTIONS
        -: 2130:        __p_.set_value_at_thread_exit(__f_(_VSTD::forward<_ArgTypes>(__args)...));
        -: 2131:#ifndef _LIBCPP_NO_EXCEPTIONS
        -: 2132:    }
        -: 2133:    catch (...)
        -: 2134:    {
        -: 2135:        __p_.set_exception_at_thread_exit(current_exception());
        -: 2136:    }
        -: 2137:#endif  // _LIBCPP_NO_EXCEPTIONS
        -: 2138:}
        -: 2139:
        -: 2140:template<class _Rp, class ..._ArgTypes>
        -: 2141:void
        -: 2142:packaged_task<_Rp(_ArgTypes...)>::reset()
        -: 2143:{
        -: 2144:#ifndef _LIBCPP_NO_EXCEPTIONS
        -: 2145:    if (!valid())
        -: 2146:        throw future_error(make_error_code(future_errc::no_state));
        -: 2147:#endif  // _LIBCPP_NO_EXCEPTIONS
        -: 2148:    __p_ = promise<result_type>();
        -: 2149:}
        -: 2150:
        -: 2151:template<class ..._ArgTypes>
        -: 2152:class _LIBCPP_TYPE_VIS_ONLY _LIBCPP_AVAILABILITY_FUTURE packaged_task<void(_ArgTypes...)>
        -: 2153:{
        -: 2154:public:
        -: 2155:    typedef void result_type;
        -: 2156:
        -: 2157:private:
        -: 2158:    __packaged_task_function<result_type(_ArgTypes...)> __f_;
        -: 2159:    promise<result_type>                                __p_;
        -: 2160:
        -: 2161:public:
        -: 2162:    // construction and destruction
        -: 2163:    _LIBCPP_INLINE_VISIBILITY
        -: 2164:    packaged_task() _NOEXCEPT : __p_(nullptr) {}
        -: 2165:    template <class _Fp,
        -: 2166:              class = typename enable_if
        -: 2167:              <
        -: 2168:                  !is_same<
        -: 2169:                      typename decay<_Fp>::type, 
        -: 2170:                      packaged_task
        -: 2171:                      >::value
        -: 2172:                  >::type
        -: 2173:              >
        -: 2174:        _LIBCPP_INLINE_VISIBILITY
        -: 2175:        explicit packaged_task(_Fp&& __f) : __f_(_VSTD::forward<_Fp>(__f)) {}
        -: 2176:    template <class _Fp, class _Allocator,
        -: 2177:              class = typename enable_if
        -: 2178:              <
        -: 2179:                  !is_same<
        -: 2180:                      typename decay<_Fp>::type, 
        -: 2181:                      packaged_task
        -: 2182:                      >::value
        -: 2183:                  >::type
        -: 2184:              >    
        -: 2185:        _LIBCPP_INLINE_VISIBILITY
        -: 2186:        packaged_task(allocator_arg_t, const _Allocator& __a, _Fp&& __f)
        -: 2187:             : __f_(allocator_arg, __a, _VSTD::forward<_Fp>(__f)),
        -: 2188:               __p_(allocator_arg, __a) {}
        -: 2189:    // ~packaged_task() = default;
        -: 2190:
        -: 2191:    // no copy
        -: 2192:    packaged_task(const packaged_task&) = delete;
        -: 2193:    packaged_task& operator=(const packaged_task&) = delete;
        -: 2194:
        -: 2195:    // move support
        -: 2196:    _LIBCPP_INLINE_VISIBILITY
        -: 2197:    packaged_task(packaged_task&& __other) _NOEXCEPT
        -: 2198:        : __f_(_VSTD::move(__other.__f_)), __p_(_VSTD::move(__other.__p_)) {}
        -: 2199:    _LIBCPP_INLINE_VISIBILITY
        -: 2200:    packaged_task& operator=(packaged_task&& __other) _NOEXCEPT
        -: 2201:    {
        -: 2202:        __f_ = _VSTD::move(__other.__f_);
        -: 2203:        __p_ = _VSTD::move(__other.__p_);
        -: 2204:        return *this;
        -: 2205:    }
        -: 2206:    _LIBCPP_INLINE_VISIBILITY
        -: 2207:    void swap(packaged_task& __other) _NOEXCEPT
        -: 2208:    {
        -: 2209:        __f_.swap(__other.__f_);
        -: 2210:        __p_.swap(__other.__p_);
        -: 2211:    }
        -: 2212:
        -: 2213:    _LIBCPP_INLINE_VISIBILITY
        -: 2214:    bool valid() const _NOEXCEPT {return __p_.__state_ != nullptr;}
        -: 2215:
        -: 2216:    // result retrieval
        -: 2217:    _LIBCPP_INLINE_VISIBILITY
        -: 2218:    future<result_type> get_future() {return __p_.get_future();}
        -: 2219:
        -: 2220:    // execution
        -: 2221:    void operator()(_ArgTypes... __args);
        -: 2222:    void make_ready_at_thread_exit(_ArgTypes... __args);
        -: 2223:
        -: 2224:    void reset();
        -: 2225:};
        -: 2226:
        -: 2227:template<class ..._ArgTypes>
        -: 2228:void
        -: 2229:packaged_task<void(_ArgTypes...)>::operator()(_ArgTypes... __args)
        -: 2230:{
        -: 2231:#ifndef _LIBCPP_NO_EXCEPTIONS
        -: 2232:    if (__p_.__state_ == nullptr)
        -: 2233:        throw future_error(make_error_code(future_errc::no_state));
        -: 2234:    if (__p_.__state_->__has_value())
        -: 2235:        throw future_error(make_error_code(future_errc::promise_already_satisfied));
        -: 2236:    try
        -: 2237:    {
        -: 2238:#endif  // _LIBCPP_NO_EXCEPTIONS
        -: 2239:        __f_(_VSTD::forward<_ArgTypes>(__args)...);
        -: 2240:        __p_.set_value();
        -: 2241:#ifndef _LIBCPP_NO_EXCEPTIONS
        -: 2242:    }
        -: 2243:    catch (...)
        -: 2244:    {
        -: 2245:        __p_.set_exception(current_exception());
        -: 2246:    }
        -: 2247:#endif  // _LIBCPP_NO_EXCEPTIONS
        -: 2248:}
        -: 2249:
        -: 2250:template<class ..._ArgTypes>
        -: 2251:void
        -: 2252:packaged_task<void(_ArgTypes...)>::make_ready_at_thread_exit(_ArgTypes... __args)
        -: 2253:{
        -: 2254:#ifndef _LIBCPP_NO_EXCEPTIONS
        -: 2255:    if (__p_.__state_ == nullptr)
        -: 2256:        throw future_error(make_error_code(future_errc::no_state));
        -: 2257:    if (__p_.__state_->__has_value())
        -: 2258:        throw future_error(make_error_code(future_errc::promise_already_satisfied));
        -: 2259:    try
        -: 2260:    {
        -: 2261:#endif  // _LIBCPP_NO_EXCEPTIONS
        -: 2262:        __f_(_VSTD::forward<_ArgTypes>(__args)...);
        -: 2263:        __p_.set_value_at_thread_exit();
        -: 2264:#ifndef _LIBCPP_NO_EXCEPTIONS
        -: 2265:    }
        -: 2266:    catch (...)
        -: 2267:    {
        -: 2268:        __p_.set_exception_at_thread_exit(current_exception());
        -: 2269:    }
        -: 2270:#endif  // _LIBCPP_NO_EXCEPTIONS
        -: 2271:}
        -: 2272:
        -: 2273:template<class ..._ArgTypes>
        -: 2274:void
        -: 2275:packaged_task<void(_ArgTypes...)>::reset()
        -: 2276:{
        -: 2277:#ifndef _LIBCPP_NO_EXCEPTIONS
        -: 2278:    if (!valid())
        -: 2279:        throw future_error(make_error_code(future_errc::no_state));
        -: 2280:#endif  // _LIBCPP_NO_EXCEPTIONS
        -: 2281:    __p_ = promise<result_type>();
        -: 2282:}
        -: 2283:
        -: 2284:template <class _Callable>
        -: 2285:inline _LIBCPP_INLINE_VISIBILITY
        -: 2286:void
        -: 2287:swap(packaged_task<_Callable>& __x, packaged_task<_Callable>& __y) _NOEXCEPT
        -: 2288:{
        -: 2289:    __x.swap(__y);
        -: 2290:}
        -: 2291:
        -: 2292:template <class _Callable, class _Alloc>
        -: 2293:struct _LIBCPP_TYPE_VIS_ONLY uses_allocator<packaged_task<_Callable>, _Alloc>
        -: 2294:    : public true_type {};
        -: 2295:
        -: 2296:template <class _Rp, class _Fp>
        -: 2297:future<_Rp>
        -: 2298:#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -: 2299:__make_deferred_assoc_state(_Fp&& __f)
        -: 2300:#else
        -: 2301:__make_deferred_assoc_state(_Fp __f)
        -: 2302:#endif
        -: 2303:{
        -: 2304:    unique_ptr<__deferred_assoc_state<_Rp, _Fp>, __release_shared_count>
    #####: 2305:        __h(new __deferred_assoc_state<_Rp, _Fp>(_VSTD::forward<_Fp>(__f)));
    #####: 2306:    return future<_Rp>(__h.get());
    #####: 2307:}
        -: 2308:
        -: 2309:template <class _Rp, class _Fp>
        -: 2310:future<_Rp>
        -: 2311:#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -: 2312:__make_async_assoc_state(_Fp&& __f)
        -: 2313:#else
        -: 2314:__make_async_assoc_state(_Fp __f)
        -: 2315:#endif
        -: 2316:{
        -: 2317:    unique_ptr<__async_assoc_state<_Rp, _Fp>, __release_shared_count>
       40: 2318:        __h(new __async_assoc_state<_Rp, _Fp>(_VSTD::forward<_Fp>(__f)));
       60: 2319:    _VSTD::thread(&__async_assoc_state<_Rp, _Fp>::__execute, __h.get()).detach();
       20: 2320:    return future<_Rp>(__h.get());
       20: 2321:}
        -: 2322:
        -: 2323:template <class _Fp, class... _Args>
        -: 2324:class __async_func
        -: 2325:{
        -: 2326:    tuple<_Fp, _Args...> __f_;
        -: 2327:
        -: 2328:public:
        -: 2329:    typedef typename __invoke_of<_Fp, _Args...>::type _Rp;
        -: 2330:
        -: 2331:    _LIBCPP_INLINE_VISIBILITY
        -: 2332:    explicit __async_func(_Fp&& __f, _Args&&... __args)
       40: 2333:        : __f_(_VSTD::move(__f), _VSTD::move(__args)...) {}
        -: 2334:
        -: 2335:    _LIBCPP_INLINE_VISIBILITY
       40: 2336:    __async_func(__async_func&& __f) : __f_(_VSTD::move(__f.__f_)) {}
        -: 2337:
        -: 2338:    _Rp operator()()
        -: 2339:    {
        -: 2340:        typedef typename __make_tuple_indices<1+sizeof...(_Args), 1>::type _Index;
       20: 2341:        return __execute(_Index());
        -: 2342:    }
        -: 2343:private:
        -: 2344:    template <size_t ..._Indices>
        -: 2345:    _Rp
        -: 2346:    __execute(__tuple_indices<_Indices...>)
        -: 2347:    {
       20: 2348:        return __invoke(_VSTD::move(_VSTD::get<0>(__f_)), _VSTD::move(_VSTD::get<_Indices>(__f_))...);
        -: 2349:    }
        -: 2350:};
        -: 2351:
        -: 2352:inline _LIBCPP_INLINE_VISIBILITY bool __does_policy_contain(launch __policy, launch __value )
       20: 2353:{ return (int(__policy) & int(__value)) != 0; }
        -: 2354:
        -: 2355:template <class _Fp, class... _Args>
        -: 2356:future<typename __invoke_of<typename decay<_Fp>::type, typename decay<_Args>::type...>::type>
        -: 2357:async(launch __policy, _Fp&& __f, _Args&&... __args)
        -: 2358:{
        -: 2359:    typedef __async_func<typename decay<_Fp>::type, typename decay<_Args>::type...> _BF;
        -: 2360:    typedef typename _BF::_Rp _Rp;
        -: 2361:
        -: 2362:#ifndef _LIBCPP_NO_EXCEPTIONS
        -: 2363:    try
        -: 2364:    {
        -: 2365:#endif
       40: 2366:        if (__does_policy_contain(__policy, launch::async))
       80: 2367:        return _VSTD::__make_async_assoc_state<_Rp>(_BF(__decay_copy(_VSTD::forward<_Fp>(__f)),
        -: 2368:                                                     __decay_copy(_VSTD::forward<_Args>(__args))...));
        -: 2369:#ifndef _LIBCPP_NO_EXCEPTIONS
    #####: 2370:    }
    #####: 2371:    catch ( ... ) { if (__policy == launch::async) throw ; }
        -: 2372:#endif
        -: 2373:
    #####: 2374:    if (__does_policy_contain(__policy, launch::deferred))
    #####: 2375:        return _VSTD::__make_deferred_assoc_state<_Rp>(_BF(__decay_copy(_VSTD::forward<_Fp>(__f)),
        -: 2376:                                                        __decay_copy(_VSTD::forward<_Args>(__args))...));
    #####: 2377:    return future<_Rp>{};
       20: 2378:}
        -: 2379:
        -: 2380:template <class _Fp, class... _Args>
        -: 2381:inline _LIBCPP_INLINE_VISIBILITY
        -: 2382:future<typename __invoke_of<typename decay<_Fp>::type, typename decay<_Args>::type...>::type>
        -: 2383:async(_Fp&& __f, _Args&&... __args)
        -: 2384:{
        -: 2385:    return _VSTD::async(launch::any, _VSTD::forward<_Fp>(__f),
        -: 2386:                                    _VSTD::forward<_Args>(__args)...);
        -: 2387:}
        -: 2388:
        -: 2389:#endif  // _LIBCPP_HAS_NO_VARIADICS
        -: 2390:
        -: 2391:// shared_future
        -: 2392:
        -: 2393:template <class _Rp>
        -: 2394:class _LIBCPP_TYPE_VIS_ONLY shared_future
        -: 2395:{
        -: 2396:    __assoc_state<_Rp>* __state_;
        -: 2397:
        -: 2398:public:
        -: 2399:    _LIBCPP_INLINE_VISIBILITY
        -: 2400:    shared_future() _NOEXCEPT : __state_(nullptr) {}
        -: 2401:    _LIBCPP_INLINE_VISIBILITY
        -: 2402:    shared_future(const shared_future& __rhs) : __state_(__rhs.__state_)
        -: 2403:        {if (__state_) __state_->__add_shared();}
        -: 2404:#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -: 2405:    _LIBCPP_INLINE_VISIBILITY
        -: 2406:    shared_future(future<_Rp>&& __f) _NOEXCEPT : __state_(__f.__state_)
        -: 2407:        {__f.__state_ = nullptr;}
        -: 2408:    _LIBCPP_INLINE_VISIBILITY
        -: 2409:    shared_future(shared_future&& __rhs) _NOEXCEPT : __state_(__rhs.__state_)
        -: 2410:        {__rhs.__state_ = nullptr;}
        -: 2411:#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -: 2412:    ~shared_future();
        -: 2413:    shared_future& operator=(const shared_future& __rhs);
        -: 2414:#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -: 2415:    _LIBCPP_INLINE_VISIBILITY
        -: 2416:    shared_future& operator=(shared_future&& __rhs) _NOEXCEPT
        -: 2417:        {
        -: 2418:            shared_future(std::move(__rhs)).swap(*this);
        -: 2419:            return *this;
        -: 2420:        }
        -: 2421:#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -: 2422:
        -: 2423:    // retrieving the value
        -: 2424:    _LIBCPP_INLINE_VISIBILITY
        -: 2425:    const _Rp& get() const {return __state_->copy();}
        -: 2426:
        -: 2427:    _LIBCPP_INLINE_VISIBILITY
        -: 2428:    void swap(shared_future& __rhs) _NOEXCEPT {_VSTD::swap(__state_, __rhs.__state_);}
        -: 2429:
        -: 2430:    // functions to check state
        -: 2431:    _LIBCPP_INLINE_VISIBILITY
        -: 2432:    bool valid() const _NOEXCEPT {return __state_ != nullptr;}
        -: 2433:
        -: 2434:    _LIBCPP_INLINE_VISIBILITY
        -: 2435:    void wait() const {__state_->wait();}
        -: 2436:    template <class _Rep, class _Period>
        -: 2437:        _LIBCPP_INLINE_VISIBILITY
        -: 2438:        future_status
        -: 2439:        wait_for(const chrono::duration<_Rep, _Period>& __rel_time) const
        -: 2440:            {return __state_->wait_for(__rel_time);}
        -: 2441:    template <class _Clock, class _Duration>
        -: 2442:        _LIBCPP_INLINE_VISIBILITY
        -: 2443:        future_status
        -: 2444:        wait_until(const chrono::time_point<_Clock, _Duration>& __abs_time) const
        -: 2445:            {return __state_->wait_until(__abs_time);}
        -: 2446:};
        -: 2447:
        -: 2448:template <class _Rp>
        -: 2449:shared_future<_Rp>::~shared_future()
        -: 2450:{
        -: 2451:    if (__state_)
        -: 2452:        __state_->__release_shared();
        -: 2453:}
        -: 2454:
        -: 2455:template <class _Rp>
        -: 2456:shared_future<_Rp>&
        -: 2457:shared_future<_Rp>::operator=(const shared_future& __rhs)
        -: 2458:{
        -: 2459:    if (__rhs.__state_)
        -: 2460:        __rhs.__state_->__add_shared();
        -: 2461:    if (__state_)
        -: 2462:        __state_->__release_shared();
        -: 2463:    __state_ = __rhs.__state_;
        -: 2464:    return *this;
        -: 2465:}
        -: 2466:
        -: 2467:template <class _Rp>
        -: 2468:class _LIBCPP_TYPE_VIS_ONLY shared_future<_Rp&>
        -: 2469:{
        -: 2470:    __assoc_state<_Rp&>* __state_;
        -: 2471:
        -: 2472:public:
        -: 2473:    _LIBCPP_INLINE_VISIBILITY
        -: 2474:    shared_future() _NOEXCEPT : __state_(nullptr) {}
        -: 2475:    _LIBCPP_INLINE_VISIBILITY
        -: 2476:    shared_future(const shared_future& __rhs) : __state_(__rhs.__state_)
        -: 2477:        {if (__state_) __state_->__add_shared();}
        -: 2478:#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -: 2479:    _LIBCPP_INLINE_VISIBILITY
        -: 2480:    shared_future(future<_Rp&>&& __f) _NOEXCEPT : __state_(__f.__state_)
        -: 2481:        {__f.__state_ = nullptr;}
        -: 2482:    _LIBCPP_INLINE_VISIBILITY
        -: 2483:    shared_future(shared_future&& __rhs) _NOEXCEPT : __state_(__rhs.__state_)
        -: 2484:        {__rhs.__state_ = nullptr;}
        -: 2485:#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -: 2486:    ~shared_future();
        -: 2487:    shared_future& operator=(const shared_future& __rhs);
        -: 2488:#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -: 2489:    _LIBCPP_INLINE_VISIBILITY
        -: 2490:    shared_future& operator=(shared_future&& __rhs) _NOEXCEPT
        -: 2491:        {
        -: 2492:            shared_future(std::move(__rhs)).swap(*this);
        -: 2493:            return *this;
        -: 2494:        }
        -: 2495:#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -: 2496:
        -: 2497:    // retrieving the value
        -: 2498:    _LIBCPP_INLINE_VISIBILITY
        -: 2499:    _Rp& get() const {return __state_->copy();}
        -: 2500:
        -: 2501:    _LIBCPP_INLINE_VISIBILITY
        -: 2502:    void swap(shared_future& __rhs) _NOEXCEPT {_VSTD::swap(__state_, __rhs.__state_);}
        -: 2503:
        -: 2504:    // functions to check state
        -: 2505:    _LIBCPP_INLINE_VISIBILITY
        -: 2506:    bool valid() const _NOEXCEPT {return __state_ != nullptr;}
        -: 2507:
        -: 2508:    _LIBCPP_INLINE_VISIBILITY
        -: 2509:    void wait() const {__state_->wait();}
        -: 2510:    template <class _Rep, class _Period>
        -: 2511:        _LIBCPP_INLINE_VISIBILITY
        -: 2512:        future_status
        -: 2513:        wait_for(const chrono::duration<_Rep, _Period>& __rel_time) const
        -: 2514:            {return __state_->wait_for(__rel_time);}
        -: 2515:    template <class _Clock, class _Duration>
        -: 2516:        _LIBCPP_INLINE_VISIBILITY
        -: 2517:        future_status
        -: 2518:        wait_until(const chrono::time_point<_Clock, _Duration>& __abs_time) const
        -: 2519:            {return __state_->wait_until(__abs_time);}
        -: 2520:};
        -: 2521:
        -: 2522:template <class _Rp>
        -: 2523:shared_future<_Rp&>::~shared_future()
        -: 2524:{
        -: 2525:    if (__state_)
        -: 2526:        __state_->__release_shared();
        -: 2527:}
        -: 2528:
        -: 2529:template <class _Rp>
        -: 2530:shared_future<_Rp&>&
        -: 2531:shared_future<_Rp&>::operator=(const shared_future& __rhs)
        -: 2532:{
        -: 2533:    if (__rhs.__state_)
        -: 2534:        __rhs.__state_->__add_shared();
        -: 2535:    if (__state_)
        -: 2536:        __state_->__release_shared();
        -: 2537:    __state_ = __rhs.__state_;
        -: 2538:    return *this;
        -: 2539:}
        -: 2540:
        -: 2541:template <>
        -: 2542:class _LIBCPP_TYPE_VIS _LIBCPP_AVAILABILITY_FUTURE shared_future<void>
        -: 2543:{
        -: 2544:    __assoc_sub_state* __state_;
        -: 2545:
        -: 2546:public:
        -: 2547:    _LIBCPP_INLINE_VISIBILITY
        -: 2548:    shared_future() _NOEXCEPT : __state_(nullptr) {}
        -: 2549:    _LIBCPP_INLINE_VISIBILITY
        -: 2550:    shared_future(const shared_future& __rhs) : __state_(__rhs.__state_)
        -: 2551:        {if (__state_) __state_->__add_shared();}
        -: 2552:#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -: 2553:    _LIBCPP_INLINE_VISIBILITY
        -: 2554:    shared_future(future<void>&& __f) _NOEXCEPT : __state_(__f.__state_)
        -: 2555:        {__f.__state_ = nullptr;}
        -: 2556:    _LIBCPP_INLINE_VISIBILITY
        -: 2557:    shared_future(shared_future&& __rhs) _NOEXCEPT : __state_(__rhs.__state_)
        -: 2558:        {__rhs.__state_ = nullptr;}
        -: 2559:#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -: 2560:    ~shared_future();
        -: 2561:    shared_future& operator=(const shared_future& __rhs);
        -: 2562:#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -: 2563:    _LIBCPP_INLINE_VISIBILITY
        -: 2564:    shared_future& operator=(shared_future&& __rhs) _NOEXCEPT
        -: 2565:        {
        -: 2566:            shared_future(std::move(__rhs)).swap(*this);
        -: 2567:            return *this;
        -: 2568:        }
        -: 2569:#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -: 2570:
        -: 2571:    // retrieving the value
        -: 2572:    _LIBCPP_INLINE_VISIBILITY
        -: 2573:    void get() const {__state_->copy();}
        -: 2574:
        -: 2575:    _LIBCPP_INLINE_VISIBILITY
        -: 2576:    void swap(shared_future& __rhs) _NOEXCEPT {_VSTD::swap(__state_, __rhs.__state_);}
        -: 2577:
        -: 2578:    // functions to check state
        -: 2579:    _LIBCPP_INLINE_VISIBILITY
        -: 2580:    bool valid() const _NOEXCEPT {return __state_ != nullptr;}
        -: 2581:
        -: 2582:    _LIBCPP_INLINE_VISIBILITY
        -: 2583:    void wait() const {__state_->wait();}
        -: 2584:    template <class _Rep, class _Period>
        -: 2585:        _LIBCPP_INLINE_VISIBILITY
        -: 2586:        future_status
        -: 2587:        wait_for(const chrono::duration<_Rep, _Period>& __rel_time) const
        -: 2588:            {return __state_->wait_for(__rel_time);}
        -: 2589:    template <class _Clock, class _Duration>
        -: 2590:        _LIBCPP_INLINE_VISIBILITY
        -: 2591:        future_status
        -: 2592:        wait_until(const chrono::time_point<_Clock, _Duration>& __abs_time) const
        -: 2593:            {return __state_->wait_until(__abs_time);}
        -: 2594:};
        -: 2595:
        -: 2596:template <class _Rp>
        -: 2597:inline _LIBCPP_INLINE_VISIBILITY
        -: 2598:void
        -: 2599:swap(shared_future<_Rp>& __x, shared_future<_Rp>& __y) _NOEXCEPT
        -: 2600:{
        -: 2601:    __x.swap(__y);
        -: 2602:}
        -: 2603:
        -: 2604:template <class _Rp>
        -: 2605:inline
        -: 2606:shared_future<_Rp>
        -: 2607:future<_Rp>::share()
        -: 2608:{
        -: 2609:    return shared_future<_Rp>(_VSTD::move(*this));
        -: 2610:}
        -: 2611:
        -: 2612:template <class _Rp>
        -: 2613:inline
        -: 2614:shared_future<_Rp&>
        -: 2615:future<_Rp&>::share()
        -: 2616:{
        -: 2617:    return shared_future<_Rp&>(_VSTD::move(*this));
        -: 2618:}
        -: 2619:
        -: 2620:#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -: 2621:
        -: 2622:inline
        -: 2623:shared_future<void>
        -: 2624:future<void>::share()
        -: 2625:{
        -: 2626:    return shared_future<void>(_VSTD::move(*this));
        -: 2627:}
        -: 2628:
        -: 2629:#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -: 2630:
        -: 2631:_LIBCPP_END_NAMESPACE_STD
        -: 2632:
        -: 2633:#endif // !_LIBCPP_HAS_NO_THREADS
        -: 2634:
        -: 2635:#endif  // _LIBCPP_FUTURE
