        -:    0:Source:/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/thread
        -:    0:Graph:/Users/wjp/Desktop/workspace/libasync/libasync/build/tests/CMakeFiles/tests.dir/ChaseLevDequeTOT.cc.gcno
        -:    0:Data:-
        -:    0:Runs:0
        -:    0:Programs:0
        -:    1:// -*- C++ -*-
        -:    2://===--------------------------- thread -----------------------------------===//
        -:    3://
        -:    4://                     The LLVM Compiler Infrastructure
        -:    5://
        -:    6:// This file is dual licensed under the MIT and the University of Illinois Open
        -:    7:// Source Licenses. See LICENSE.TXT for details.
        -:    8://
        -:    9://===----------------------------------------------------------------------===//
        -:   10:
        -:   11:#ifndef _LIBCPP_THREAD
        -:   12:#define _LIBCPP_THREAD
        -:   13:
        -:   14:/*
        -:   15:
        -:   16:    thread synopsis
        -:   17:
        -:   18:#define __STDCPP_THREADS__ __cplusplus
        -:   19:
        -:   20:namespace std
        -:   21:{
        -:   22:
        -:   23:class thread
        -:   24:{
        -:   25:public:
        -:   26:    class id;
        -:   27:    typedef pthread_t native_handle_type;
        -:   28:
        -:   29:    thread() noexcept;
        -:   30:    template <class F, class ...Args> explicit thread(F&& f, Args&&... args);
        -:   31:    ~thread();
        -:   32:
        -:   33:    thread(const thread&) = delete;
        -:   34:    thread(thread&& t) noexcept;
        -:   35:
        -:   36:    thread& operator=(const thread&) = delete;
        -:   37:    thread& operator=(thread&& t) noexcept;
        -:   38:
        -:   39:    void swap(thread& t) noexcept;
        -:   40:
        -:   41:    bool joinable() const noexcept;
        -:   42:    void join();
        -:   43:    void detach();
        -:   44:    id get_id() const noexcept;
        -:   45:    native_handle_type native_handle();
        -:   46:
        -:   47:    static unsigned hardware_concurrency() noexcept;
        -:   48:};
        -:   49:
        -:   50:void swap(thread& x, thread& y) noexcept;
        -:   51:
        -:   52:class thread::id
        -:   53:{
        -:   54:public:
        -:   55:    id() noexcept;
        -:   56:};
        -:   57:
        -:   58:bool operator==(thread::id x, thread::id y) noexcept;
        -:   59:bool operator!=(thread::id x, thread::id y) noexcept;
        -:   60:bool operator< (thread::id x, thread::id y) noexcept;
        -:   61:bool operator<=(thread::id x, thread::id y) noexcept;
        -:   62:bool operator> (thread::id x, thread::id y) noexcept;
        -:   63:bool operator>=(thread::id x, thread::id y) noexcept;
        -:   64:
        -:   65:template<class charT, class traits>
        -:   66:basic_ostream<charT, traits>&
        -:   67:operator<<(basic_ostream<charT, traits>& out, thread::id id);
        -:   68:
        -:   69:namespace this_thread
        -:   70:{
        -:   71:
        -:   72:thread::id get_id() noexcept;
        -:   73:
        -:   74:void yield() noexcept;
        -:   75:
        -:   76:template <class Clock, class Duration>
        -:   77:void sleep_until(const chrono::time_point<Clock, Duration>& abs_time);
        -:   78:
        -:   79:template <class Rep, class Period>
        -:   80:void sleep_for(const chrono::duration<Rep, Period>& rel_time);
        -:   81:
        -:   82:}  // this_thread
        -:   83:
        -:   84:}  // std
        -:   85:
        -:   86:*/
        -:   87:
        -:   88:#include <__config>
        -:   89:#include <iosfwd>
        -:   90:#include <__functional_base>
        -:   91:#include <type_traits>
        -:   92:#include <cstddef>
        -:   93:#include <functional>
        -:   94:#include <memory>
        -:   95:#include <system_error>
        -:   96:#include <chrono>
        -:   97:#include <__mutex_base>
        -:   98:#ifndef _LIBCPP_HAS_NO_VARIADICS
        -:   99:#include <tuple>
        -:  100:#endif
        -:  101:#include <pthread.h>
        -:  102:#include <sched.h>
        -:  103:
        -:  104:#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
        -:  105:#pragma GCC system_header
        -:  106:#endif
        -:  107:
        -:  108:#define __STDCPP_THREADS__ __cplusplus
        -:  109:
        -:  110:#ifdef _LIBCPP_HAS_NO_THREADS
        -:  111:#error <thread> is not supported on this single threaded system
        -:  112:#else // !_LIBCPP_HAS_NO_THREADS
        -:  113:
        -:  114:_LIBCPP_BEGIN_NAMESPACE_STD
        -:  115:
        -:  116:template <class _Tp> class __thread_specific_ptr;
        -:  117:class _LIBCPP_TYPE_VIS __thread_struct;
        -:  118:class _LIBCPP_HIDDEN __thread_struct_imp;
        -:  119:class __assoc_sub_state;
        -:  120:
        -:  121:_LIBCPP_FUNC_VIS __thread_specific_ptr<__thread_struct>& __thread_local_data();
        -:  122:
        -:  123:class _LIBCPP_TYPE_VIS __thread_struct
        -:  124:{
        -:  125:    __thread_struct_imp* __p_;
        -:  126:
        -:  127:    __thread_struct(const __thread_struct&);
        -:  128:    __thread_struct& operator=(const __thread_struct&);
        -:  129:public:
        -:  130:    __thread_struct();
        -:  131:    ~__thread_struct();
        -:  132:
        -:  133:    void notify_all_at_thread_exit(condition_variable*, mutex*);
        -:  134:    void __make_ready_at_thread_exit(__assoc_sub_state*);
        -:  135:};
        -:  136:
        -:  137:template <class _Tp>
        -:  138:class __thread_specific_ptr
        -:  139:{
        -:  140:    pthread_key_t __key_;
        -:  141:
        -:  142:     // Only __thread_local_data() may construct a __thread_specific_ptr
        -:  143:     // and only with _Tp == __thread_struct.
        -:  144:    static_assert((is_same<_Tp, __thread_struct>::value), "");
        -:  145:    __thread_specific_ptr();
        -:  146:    friend _LIBCPP_FUNC_VIS __thread_specific_ptr<__thread_struct>& __thread_local_data();
        -:  147:
        -:  148:    __thread_specific_ptr(const __thread_specific_ptr&);
        -:  149:    __thread_specific_ptr& operator=(const __thread_specific_ptr&);
        -:  150:
        -:  151:    static void __at_thread_exit(void*);
        -:  152:public:
        -:  153:    typedef _Tp* pointer;
        -:  154:
        -:  155:    ~__thread_specific_ptr();
        -:  156:
        -:  157:    _LIBCPP_INLINE_VISIBILITY
    #####:  158:    pointer get() const {return static_cast<_Tp*>(pthread_getspecific(__key_));}
        -:  159:    _LIBCPP_INLINE_VISIBILITY
        -:  160:    pointer operator*() const {return *get();}
        -:  161:    _LIBCPP_INLINE_VISIBILITY
        -:  162:    pointer operator->() const {return get();}
        -:  163:    pointer release();
        -:  164:    void reset(pointer __p = nullptr);
        -:  165:};
        -:  166:
        -:  167:template <class _Tp>
        -:  168:void
        -:  169:__thread_specific_ptr<_Tp>::__at_thread_exit(void* __p)
        -:  170:{
        -:  171:    delete static_cast<pointer>(__p);
        -:  172:}
        -:  173:
        -:  174:template <class _Tp>
        -:  175:__thread_specific_ptr<_Tp>::__thread_specific_ptr()
        -:  176:{
        -:  177:    int __ec = pthread_key_create(&__key_, &__thread_specific_ptr::__at_thread_exit);
        -:  178:#ifndef _LIBCPP_NO_EXCEPTIONS
        -:  179:    if (__ec)
        -:  180:        throw system_error(error_code(__ec, system_category()),
        -:  181:                           "__thread_specific_ptr construction failed");
        -:  182:#endif
        -:  183:}
        -:  184:
        -:  185:template <class _Tp>
        -:  186:__thread_specific_ptr<_Tp>::~__thread_specific_ptr()
        -:  187:{
        -:  188:    // __thread_specific_ptr is only created with a static storage duration
        -:  189:    // so this destructor is only invoked during program termination. Invoking
        -:  190:    // pthread_key_delete(__key_) may prevent other threads from deleting their
        -:  191:    // thread local data. For this reason we leak the key.
        -:  192:}
        -:  193:
        -:  194:template <class _Tp>
        -:  195:typename __thread_specific_ptr<_Tp>::pointer
        -:  196:__thread_specific_ptr<_Tp>::release()
        -:  197:{
        -:  198:    pointer __p = get();
        -:  199:    pthread_setspecific(__key_, 0);
        -:  200:    return __p;
        -:  201:}
        -:  202:
        -:  203:template <class _Tp>
        -:  204:void
        -:  205:__thread_specific_ptr<_Tp>::reset(pointer __p)
        -:  206:{
    #####:  207:    pointer __p_old = get();
    #####:  208:    pthread_setspecific(__key_, __p);
    #####:  209:    delete __p_old;
    #####:  210:}
        -:  211:
        -:  212:class _LIBCPP_TYPE_VIS thread;
        -:  213:class _LIBCPP_TYPE_VIS __thread_id;
        -:  214:
        -:  215:namespace this_thread
        -:  216:{
        -:  217:
        -:  218:_LIBCPP_INLINE_VISIBILITY __thread_id get_id() _NOEXCEPT;
        -:  219:
        -:  220:}  // this_thread
        -:  221:
        -:  222:template<> struct _LIBCPP_TYPE_VIS_ONLY hash<__thread_id>;
        -:  223:
        -:  224:class _LIBCPP_TYPE_VIS_ONLY __thread_id
        -:  225:{
        -:  226:    // FIXME: pthread_t is a pointer on Darwin but a long on Linux.
        -:  227:    // NULL is the no-thread value on Darwin.  Someone needs to check
        -:  228:    // on other platforms.  We assume 0 works everywhere for now.
        -:  229:    pthread_t __id_;
        -:  230:
        -:  231:public:
        -:  232:    _LIBCPP_INLINE_VISIBILITY
        -:  233:    __thread_id() _NOEXCEPT : __id_(0) {}
        -:  234:
        -:  235:    friend _LIBCPP_INLINE_VISIBILITY
        -:  236:        bool operator==(__thread_id __x, __thread_id __y) _NOEXCEPT
        -:  237:        {return __x.__id_ == __y.__id_;}
        -:  238:    friend _LIBCPP_INLINE_VISIBILITY
        -:  239:        bool operator!=(__thread_id __x, __thread_id __y) _NOEXCEPT
        -:  240:        {return !(__x == __y);}
        -:  241:    friend _LIBCPP_INLINE_VISIBILITY
        -:  242:        bool operator< (__thread_id __x, __thread_id __y) _NOEXCEPT
        -:  243:        {return __x.__id_ < __y.__id_;}
        -:  244:    friend _LIBCPP_INLINE_VISIBILITY
        -:  245:        bool operator<=(__thread_id __x, __thread_id __y) _NOEXCEPT
        -:  246:        {return !(__y < __x);}
        -:  247:    friend _LIBCPP_INLINE_VISIBILITY
        -:  248:        bool operator> (__thread_id __x, __thread_id __y) _NOEXCEPT
        -:  249:        {return   __y < __x ;}
        -:  250:    friend _LIBCPP_INLINE_VISIBILITY
        -:  251:        bool operator>=(__thread_id __x, __thread_id __y) _NOEXCEPT
        -:  252:        {return !(__x < __y);}
        -:  253:
        -:  254:    template<class _CharT, class _Traits>
        -:  255:    friend
        -:  256:    _LIBCPP_INLINE_VISIBILITY
        -:  257:    basic_ostream<_CharT, _Traits>&
        -:  258:    operator<<(basic_ostream<_CharT, _Traits>& __os, __thread_id __id)
        -:  259:        {return __os << __id.__id_;}
        -:  260:
        -:  261:private:
        -:  262:    _LIBCPP_INLINE_VISIBILITY
        -:  263:    __thread_id(pthread_t __id) : __id_(__id) {}
        -:  264:
        -:  265:    friend __thread_id this_thread::get_id() _NOEXCEPT;
        -:  266:    friend class _LIBCPP_TYPE_VIS thread;
        -:  267:    friend struct _LIBCPP_TYPE_VIS_ONLY hash<__thread_id>;
        -:  268:};
        -:  269:
        -:  270:template<>
        -:  271:struct _LIBCPP_TYPE_VIS_ONLY hash<__thread_id>
        -:  272:    : public unary_function<__thread_id, size_t>
        -:  273:{
        -:  274:    _LIBCPP_INLINE_VISIBILITY
        -:  275:    size_t operator()(__thread_id __v) const
        -:  276:    {
        -:  277:        return hash<pthread_t>()(__v.__id_);
        -:  278:    }
        -:  279:};
        -:  280:
        -:  281:namespace this_thread
        -:  282:{
        -:  283:
        -:  284:inline _LIBCPP_INLINE_VISIBILITY
        -:  285:__thread_id
        -:  286:get_id() _NOEXCEPT
        -:  287:{
        -:  288:    return pthread_self();
        -:  289:}
        -:  290:
        -:  291:}  // this_thread
        -:  292:
        -:  293:class _LIBCPP_TYPE_VIS thread
        -:  294:{
        -:  295:    pthread_t __t_;
        -:  296:
        -:  297:    thread(const thread&);
        -:  298:    thread& operator=(const thread&);
        -:  299:public:
        -:  300:    typedef __thread_id id;
        -:  301:    typedef pthread_t native_handle_type;
        -:  302:
        -:  303:    _LIBCPP_INLINE_VISIBILITY
        -:  304:    thread() _NOEXCEPT : __t_(0) {}
        -:  305:#ifndef _LIBCPP_HAS_NO_VARIADICS
        -:  306:    template <class _Fp, class ..._Args,
        -:  307:              class = typename enable_if
        -:  308:              <
        -:  309:                   !is_same<typename decay<_Fp>::type, thread>::value
        -:  310:              >::type
        -:  311:             >
        -:  312:        explicit thread(_Fp&& __f, _Args&&... __args);
        -:  313:#else  // _LIBCPP_HAS_NO_VARIADICS
        -:  314:    template <class _Fp> explicit thread(_Fp __f);
        -:  315:#endif
        -:  316:    ~thread();
        -:  317:
        -:  318:#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -:  319:    _LIBCPP_INLINE_VISIBILITY
        -:  320:    thread(thread&& __t) _NOEXCEPT : __t_(__t.__t_) {__t.__t_ = 0;}
        -:  321:    _LIBCPP_INLINE_VISIBILITY
        -:  322:    thread& operator=(thread&& __t) _NOEXCEPT;
        -:  323:#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -:  324:
        -:  325:    _LIBCPP_INLINE_VISIBILITY
        -:  326:    void swap(thread& __t) _NOEXCEPT {_VSTD::swap(__t_, __t.__t_);}
        -:  327:
        -:  328:    _LIBCPP_INLINE_VISIBILITY
        -:  329:    bool joinable() const _NOEXCEPT {return __t_ != 0;}
        -:  330:    void join();
        -:  331:    void detach();
        -:  332:    _LIBCPP_INLINE_VISIBILITY
        -:  333:    id get_id() const _NOEXCEPT {return __t_;}
        -:  334:    _LIBCPP_INLINE_VISIBILITY
        -:  335:    native_handle_type native_handle() _NOEXCEPT {return __t_;}
        -:  336:
        -:  337:    static unsigned hardware_concurrency() _NOEXCEPT;
        -:  338:};
        -:  339:
        -:  340:#ifndef _LIBCPP_HAS_NO_VARIADICS
        -:  341:
        -:  342:template <class _Fp, class ..._Args, size_t ..._Indices>
        -:  343:inline _LIBCPP_INLINE_VISIBILITY
        -:  344:void
        -:  345:__thread_execute(tuple<_Fp, _Args...>& __t, __tuple_indices<_Indices...>)
        -:  346:{
    #####:  347:    __invoke(_VSTD::move(_VSTD::get<0>(__t)), _VSTD::move(_VSTD::get<_Indices>(__t))...);
    #####:  348:}
        -:  349:
        -:  350:template <class _Fp>
        -:  351:void*
        -:  352:__thread_proxy(void* __vp)
        -:  353:{
    #####:  354:    __thread_local_data().reset(new __thread_struct);
    #####:  355:    std::unique_ptr<_Fp> __p(static_cast<_Fp*>(__vp));
        -:  356:    typedef typename __make_tuple_indices<tuple_size<_Fp>::value, 1>::type _Index;
    #####:  357:    __thread_execute(*__p, _Index());
        -:  358:    return nullptr;
    #####:  359:}
        -:  360:
        -:  361:template <class _Fp, class ..._Args,
        -:  362:          class
        -:  363:         >
        -:  364:thread::thread(_Fp&& __f, _Args&&... __args)
    #####:  365:{
        -:  366:    typedef tuple<typename decay<_Fp>::type, typename decay<_Args>::type...> _Gp;
    #####:  367:    _VSTD::unique_ptr<_Gp> __p(new _Gp(__decay_copy(_VSTD::forward<_Fp>(__f)),
    #####:  368:                                __decay_copy(_VSTD::forward<_Args>(__args))...));
    #####:  369:    int __ec = pthread_create(&__t_, 0, &__thread_proxy<_Gp>, __p.get());
    #####:  370:    if (__ec == 0)
    #####:  371:        __p.release();
        -:  372:    else
    #####:  373:        __throw_system_error(__ec, "thread constructor failed");
    #####:  374:}
        -:  375:
        -:  376:#else  // _LIBCPP_HAS_NO_VARIADICS
        -:  377:
        -:  378:template <class _Fp>
        -:  379:void*
        -:  380:__thread_proxy(void* __vp)
        -:  381:{
        -:  382:    __thread_local_data().reset(new __thread_struct);
        -:  383:    std::unique_ptr<_Fp> __p(static_cast<_Fp*>(__vp));
        -:  384:    (*__p)();
        -:  385:    return nullptr;
        -:  386:}
        -:  387:
        -:  388:template <class _Fp>
        -:  389:thread::thread(_Fp __f)
        -:  390:{
        -:  391:    std::unique_ptr<_Fp> __p(new _Fp(__f));
        -:  392:    int __ec = pthread_create(&__t_, 0, &__thread_proxy<_Fp>, __p.get());
        -:  393:    if (__ec == 0)
        -:  394:        __p.release();
        -:  395:    else
        -:  396:        __throw_system_error(__ec, "thread constructor failed");
        -:  397:}
        -:  398:
        -:  399:#endif  // _LIBCPP_HAS_NO_VARIADICS
        -:  400:
        -:  401:#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -:  402:
        -:  403:inline
        -:  404:thread&
        -:  405:thread::operator=(thread&& __t) _NOEXCEPT
        -:  406:{
        -:  407:    if (__t_ != 0)
        -:  408:        terminate();
        -:  409:    __t_ = __t.__t_;
        -:  410:    __t.__t_ = 0;
        -:  411:    return *this;
        -:  412:}
        -:  413:
        -:  414:#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -:  415:
        -:  416:inline _LIBCPP_INLINE_VISIBILITY
        -:  417:void swap(thread& __x, thread& __y) _NOEXCEPT {__x.swap(__y);}
        -:  418:
        -:  419:namespace this_thread
        -:  420:{
        -:  421:
        -:  422:_LIBCPP_FUNC_VIS void sleep_for(const chrono::nanoseconds& ns);
        -:  423:
        -:  424:template <class _Rep, class _Period>
        -:  425:void
        -:  426:sleep_for(const chrono::duration<_Rep, _Period>& __d)
        -:  427:{
        -:  428:    using namespace chrono;
    #####:  429:    if (__d > duration<_Rep, _Period>::zero())
        -:  430:    {
        -:  431:        _LIBCPP_CONSTEXPR duration<long double> _Max = nanoseconds::max();
        -:  432:        nanoseconds __ns;
    #####:  433:        if (__d < _Max)
        -:  434:        {
    #####:  435:            __ns = duration_cast<nanoseconds>(__d);
    #####:  436:            if (__ns < __d)
    #####:  437:                ++__ns;
    #####:  438:        }
        -:  439:        else
    #####:  440:            __ns = nanoseconds::max();
    #####:  441:        sleep_for(__ns);
    #####:  442:    }
    #####:  443:}
        -:  444:
        -:  445:template <class _Clock, class _Duration>
        -:  446:void
        -:  447:sleep_until(const chrono::time_point<_Clock, _Duration>& __t)
        -:  448:{
        -:  449:    using namespace chrono;
        -:  450:    mutex __mut;
        -:  451:    condition_variable __cv;
        -:  452:    unique_lock<mutex> __lk(__mut);
        -:  453:    while (_Clock::now() < __t)
        -:  454:        __cv.wait_until(__lk, __t);
        -:  455:}
        -:  456:
        -:  457:template <class _Duration>
        -:  458:inline _LIBCPP_INLINE_VISIBILITY
        -:  459:void
        -:  460:sleep_until(const chrono::time_point<chrono::steady_clock, _Duration>& __t)
        -:  461:{
        -:  462:    using namespace chrono;
        -:  463:    sleep_for(__t - steady_clock::now());
        -:  464:}
        -:  465:
        -:  466:inline _LIBCPP_INLINE_VISIBILITY
        -:  467:void yield() _NOEXCEPT {sched_yield();}
        -:  468:
        -:  469:}  // this_thread
        -:  470:
        -:  471:_LIBCPP_END_NAMESPACE_STD
        -:  472:
        -:  473:#endif // !_LIBCPP_HAS_NO_THREADS
        -:  474:
        -:  475:#endif  // _LIBCPP_THREAD
